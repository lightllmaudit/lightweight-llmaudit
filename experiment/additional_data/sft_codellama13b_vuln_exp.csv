vuln_code,ground_truth,llm_output
"function syncDeps(IRegistry _registry) public onlyGovernance {
        vusd = IERC20(_registry.vusd());
        marginAccount = _registry.marginAccount();
    }","The `Governance` address can call `InsuranceFund.sol#syncDeps()` to change the contract address of `vusd` anytime.

However, since the tx to set a new address for `vusd` can get in between users' txs to deposit and withdraw, in some edge cases, it can result in users' loss of funds.

### Proof of Concept

1.  Alice deposited `1,000,000 VUSD` to `InsuranceFund`;
2.  Gov called `syncDeps()` and set `vusd` to the address of `VUSDv2`;
3.  Alice called `withdraw()` with all the `shares` and get back `0 VUSDv2`.

As a result, Alice suffered a fund loss of `1,000,000 VUSD`.","The `syncDeps` function of `MarginToVUSD` allows governance to update all dependencies at once, but it does not check if any of these addresses actually implement their respective interfaces (e.g., `vusd`). If one of them doesn't, then this will fail with an error that might be hard for users to understand or debug. It would also make sense to have a way to revert back to previous values when something goes wrong during updates."
"function deposit(uint256 _amount) external whenNotPaused {
        _depositWithAuthorization(_amount, new bytes32[](0));
    }

function deposit(uint256 _amount, bytes32[] memory proof)
        external
        whenNotPaused
    {
        _depositWithAuthorization(_amount, proof);
    }

function _depositFor(address _recipient, uint256 _amount)
        internal
        nonReentrant
    {
        require(_recipient != address(0), ""Address 0"");
        require(_amount != 0, ""Amount 0"");
        require(!pausedDeposit, ""pausedDeposit""); // dev: deposits are paused

        uint256 _pool = balance();
        uint256 _before = token.balanceOf(address(this));
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 _after = token.balanceOf(address(this));
        _mintSharesFor(_recipient, _after - _before, _pool);
    }

function _mintSharesFor(
        address recipient,
        uint256 _amount,
        uint256 _pool
    ) internal {
        uint256 shares;
        if (totalSupply() == 0) {
            shares = _amount;
        } else {
            shares = (_amount * totalSupply()) / _pool;
        }
        _mint(recipient, shares);
    }","An attacker can become the first depositor for a recently created StakedCitadel contract, providing a tiny amount of Citadel tokens by calling deposit(1) (raw values here, 1 is 1 wei, 1e18 is 1 Citadel as it has 18 decimals). Then the attacker can directly transfer, for example, 10^6*1e18 - 1 Citadel to StakedCitadel, effectively setting the cost of 1 of the vault token to be 10^6 * 1e18 Citadel. The attacker will still own 100% of the StakedCitadel's pool being the only depositor.

All subsequent depositors will have their Citadel token investments rounded to 10^6 * 1e18, due to the lack of precision which initial tiny deposit caused, with the remainder divided between all current depositors, i.e. the subsequent depositors lose value to the attacker.

For example, if the second depositor brings in 1.9*10^6 * 1e18 Citadel, only 1 of new vault to be issued as 1.9*10^6 * 1e18 divided by 10^6 * 1e18 will yield just 1, which means that 2.9*10^6 * 1e18 total Citadel pool will be divided 50/50 between the second depositor and the attacker, as each have 1 wei of the total 2 wei of vault tokens, i.e. the depositor lost and the attacker gained 0.45*10^6 * 1e18 Citadel tokens.

As there are no penalties to exit with StakedCitadel.withdraw(), the attacker can remain staked for an arbitrary time, gathering the share of all new deposits' remainder amounts.

Placing severity to be high as this is principal funds loss scenario for many users (most of depositors), easily executable, albeit only for the new StakedCitadel contract.

Any deposit lower than total attacker's stake will be fully stolen from the depositor as 0 vault tokens will be issued in this case.

The issue is similar to the TOB-YEARN-003 one of the Trail of Bits audit of Yearn Finance.","The `HybridPool` has a `deposit()` function that allows users to directly transfer tokens into it without any permission or authorization. However, this function does not have an equivalent withdrawal functionality as there's no way for users to retrieve their funds from the pool. As a result, all of the funds will be locked inside the pool forever.

Proof of Concept

1. Alice wants to add liquidity to the Hybrid Pool by sending some DAI tokens to the pool. She calls the `deposit()` function with her desired amount of DAI tokens.
2. Bob tries to remove his share of the liquidity but he can’t because the protocol doesn’t allow him to do so. He cannot call the `_withdraw()` function either since the pool is currently frozen due to the emergency pause.
3. Charlie decides to take advantage of the situation and sends more DAI tokens to the pool. Now the value of the pool increases significantly.
4. After a while, the owner unfreezes the pool again and then Alice can finally withdraw her original amount of DAI tokens she sent earlier. But now she finds out that she only received back half of what she originally sent!

Impact

This issue affects the entire ecosystem of the project. Users who want to provide liquidity to the Hybrid Pool would lose most of their funds. It also makes the protocol less attractive to use.

### Proof of Concept

Alice wants to add liquidity to the Hybrid Pool by sending some DAI tokens to the pool. She calls the `deposit()` function with her desired amount of DAI tokens.

Bob tries to remove his share of the liquidity but he can’t because the protocol doesn’t allow him to do so. He cannot call the `_withdraw()` function either since the pool is currently frozen due to the emergency pause.

Charlie decides to take advantage of the situation and sends more DAI tokens to the pool. Now the value of the pool increases significantly.

After a while, the owner unfreezes the pool again and then Alice can finally withdraw her original amount of DAI tokens she sent earlier. But now she finds out that she only received back half of what she originally sent!"
"function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    IERC20Upgradeable _depositToken = IERC20Upgradeable(yieldSource.depositToken());

    _burnShares(amount);

    uint256 redeemableBalance = yieldSource.redeemToken(amount);
    _depositToken.safeTransferFrom(address(this), msg.sender, redeemableBalance);

    return redeemableBalance;
  }","The `SwappableYieldSource.redeemToken` function transfers tokens from the contract back to the sender, however, it uses the `ERC20.transferFrom(address(this), msg.sender, redeemableBalance)` function for this. Some deposit token implementations might fail as `transferFrom` checks if the contract approved itself for the `redeemableBalance` instead of skipping the allowance check in case the sender is the `from` address. This can make the transaction revert and the deposited funds will be unrecoverable for the user.","The `YieldSource` interface has a method called `redeemToken`. It takes an argument of type `uint256`, which represents the number of shares that should be burned when calling this method. However, it's not clear what happens if you call this method with a value smaller than one share or larger than the total supply of shares.

In the implementation of `redeemToken()` for most Yield Source implementations, there will be checks on these boundaries. For example, see the implementation here: https://github.com/yearn/brownie-mix/blob/master/contracts/YearnGovernance.sol#L137

However, some other implementations don't have such boundary checking. An attacker can then use flashloan attacks to steal funds from the vault by exploiting this lack of boundary check. See proof of concept below."
"function mint(
        uint256 maturity,
        address liquidityTo,
        address dueTo,
        uint112 xIncrease,
        uint112 yIncrease,
        uint112 zIncrease,
        bytes calldata data
    )
        external
        override
        lock
        returns (
            uint256 liquidityOut,
            uint256 id,
            Due memory dueOut
        )
    {
        require(block.timestamp < maturity, 'E202');
        require(maturity - block.timestamp < 0x100000000, 'E208');
        require(liquidityTo != address(0) && dueTo != address(0), 'E201');
        require(liquidityTo != address(this) && dueTo != address(this), 'E204');
        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205');
        
        Pool storage pool = pools[maturity];

        if (pool.state.totalLiquidity == 0) {
            uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);
            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);

            pool.state.totalLiquidity += liquidityTotal;
            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;
        } else {
            uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);
            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);

            pool.state.totalLiquidity += liquidityTotal;
            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;
        }
        require(liquidityOut > 0, 'E212');
        pool.liquidities[liquidityTo] += liquidityOut;

        dueOut.debt = MintMath.getDebt(maturity, xIncrease, yIncrease);
        dueOut.collateral = MintMath.getCollateral(maturity, zIncrease);
        dueOut.startBlock = BlockNumber.get();

        Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data);

        id = pool.dues[dueTo].insert(dueOut);

        pool.state.reserves.asset += xIncrease;
        pool.state.reserves.collateral += dueOut.collateral;
        pool.state.totalDebtCreated += dueOut.debt;

        pool.state.x += xIncrease;
        pool.state.y += yIncrease;
        pool.state.z += zIncrease;

        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Mint(maturity, msg.sender, liquidityTo, dueTo, xIncrease, liquidityOut, id, dueOut);
    }","The current implementation of TimeswapPair.sol#mint() allows the caller to specify an arbitrary value for yIncrease.

However, since state.y is expected to be a large number based at 2**32, once the initial state.y is set to a small number (1 wei for example), the algorithm won't effectively change state.y with regular market operations (borrow, lend and mint).

The pair with the maturity will malfunction and can only be abandoned.

A malicious user/attacker can use this to frontrun other users or the platform's newLiquidity() call to initiate a griefing attack.

If the desired maturity is a meaningful value for the user/platform, eg, end of year/quarter. This can be a noteworthy issue.","The `Pool` struct has a field called `state`. It's used as an internal cache for various values that can be calculated from other fields of this struct. However, it doesn't seem like any of these cached values should ever change after initialization. If they do, then there will likely be unforeseen consequences throughout the rest of the system. As such, I believe it would make sense to mark all of these variables as immutable (`view`) instead of mutable (`var`)."
"function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, ""Not enough tokens to shift"");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }",The `shiftTokens` function of `Staker` checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the `shiftTokens` function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked.,"The `batcher` can be used by anyone who wants to add liquidity or remove liquidity from a pool. However, it's possible for an attacker to front-run this transaction and steal funds from the pool.

An attacker could do the following:
1.  Observe the mempool of transactions on Ethereum and wait until there is a transaction with a nonce equal to their own next nonce. They know they will get mined before any other transaction with a lower nonce than themselves.
2.  When they see such a transaction, they immediately send another transaction which spends all the same inputs as the previous transaction but sends the value to their own account instead. Since the second transaction was sent earlier, it gets mined before the original transaction. As a result, the attacker now controls all the input UTXOs of the original transaction.
3.  The attacker then waits until the `batcher`'s `addLiquidity()`/`removeLiquidity()` functions are called again. Once these calls happen, the attacker can spend the stolen UTXO set using the `batcher`. By doing so, they effectively steal the entirety of the rewards paid out during each call to `addLiquidity()`.
4.  An attacker may also use this method to steal funds from the `swapFeePool`, since the `swapFeePool` uses the `batcher` to manage its funding.

This issue affects the `Batcher` contract because it allows users to deposit and withdraw assets at will without proper access control restrictions. It would allow an attacker to steal funds from the protocol."
"function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }","Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.

Proof of Concept:

```solidity
    function claimGovFees() public {
        address[] memory assets = bondNFT.getAssets();

        for (uint i=0; i < assets.length; i++) {
            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));
            IGovNFT(govNFT).claim(assets[i]);
            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));
            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);// @audit this could fail always with some tokens, 
            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);
        }
    }
```","The `BondNFT` contract has a function called `claimGovFees()` which claims all available fees from the governance NFT, distributes them among the current holders of bonds with that asset as collateral, then approves the new amount so it can be deposited into Compound. However, if there's an issue with any of these steps or if the total supply of bonds changes during this process, funds could get stuck in the BondNFT contract.

Proof of Concept

1.  Alice buys a bond using USDC as collateral.
2.  Bob calls `claimGovFees()`.
3.  An attacker frontruns Bob by calling `setFeeTo()`, setting the fee recipient to their own account.
4.  Now when Bob tries to call `claimGovFees()`, they will receive less tokens than expected because the attacker stole some of the rewards. As a result, the protocol loses out on those rewards."
"function deposit(uint256 _amount)
        external
        override
        nonReentrant
        returns (uint256)
    {
        require(_depositsAllowed, ""Deposits not allowed"");
        _baseToken.safeTransferFrom(msg.sender, address(this), _amount);
        // Calculate fees and shares to mint including latent contract funds
        uint256 _amountToDeposit = _baseToken.balanceOf(address(this));
        // Record deposit before fee is taken
        if (address(_depositHook) != address(0)) {
            _depositHook.hook(msg.sender, _amount, _amountToDeposit);
        }
        /**
         * Add 1 to avoid rounding to zero, only process deposit if user is
         * depositing an amount large enough to pay a fee.
         */
        uint256 _fee = (_amountToDeposit * _mintingFee) / FEE_DENOMINATOR + 1;
        require(_amountToDeposit > _fee, ""Deposit amount too small"");
        _baseToken.safeTransfer(_treasury, _fee);
        _amountToDeposit -= _fee;

        uint256 _valueBefore = _strategyController.totalValue();
        _baseToken.approve(address(_strategyController), _amountToDeposit);
        _strategyController.deposit(_amountToDeposit);
        uint256 _valueAfter = _strategyController.totalValue();
        _amountToDeposit = _valueAfter - _valueBefore;

        uint256 _shares = 0;
        if (totalSupply() == 0) {
            _shares = _amountToDeposit;
        } else {
            /**
             * # of shares owed = amount deposited / cost per share, cost per
             * share = total supply / total value.
             */
            _shares = (_amountToDeposit * totalSupply()) / (_valueBefore);
        }
        _mint(msg.sender, _shares);
        return _shares;
    }","The attack vector and impact is the same as TOB-YEARN-003, where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.

Proof of Concept

*   Attacker deposits 2 wei (so that it is greater than min fee) to mint 1 share
*   Attacker transfers exorbitant amount to _strategyController to greatly inflate the share’s price. Note that the _strategyController deposits its entire balance to the strategy when its deposit() function is called.
*   Subsequent depositors instead have to deposit an equivalent sum to avoid minting 0 shares. Otherwise, their deposits accrue to the attacker who holds the only share.

it(""will cause 0 share issuance"", async () => {
	// 1. first user deposits 2 wei because 1 wei will be deducted for fee
	let firstDepositAmount = ethers.BigNumber.from(2)
	await transferAndApproveForDeposit(
	    user,
	    collateral.address,
	    firstDepositAmount
	)
	
	await collateral
	    .connect(user)
	    .deposit(firstDepositAmount)
	
	// 2. do huge transfer of 1M to strategy to controller
	// to greatly inflate share price
	await baseToken.transfer(strategyController.address, ethers.utils.parseEther(""1000000""));
	
	// 3. deployer tries to deposit reasonable amount of 10_000
	let subsequentDepositAmount = ethers.utils.parseEther(""10000"");
	await transferAndApproveForDeposit(
	    deployer,
	    collateral.address,
	    subsequentDepositAmount
	)

	await collateral
	    .connect(deployer)
	    .deposit(subsequentDepositAmount)
	
	// receives 0 shares in return
	expect(await collateral.balanceOf(deployer.address)).to.be.eq(0)
});","The `ConvexStakingWrapper` allows users to deposit tokens into it by calling the `deposit()` function. However, there's no way for users to withdraw their tokens from this wrapper as the `_withdraw()` function doesn't exist. As a result, all the underlying tokens will be locked forever inside the contract.

This issue can happen when someone accidentally sends his token to the wrong contract or he wants to use another strategy but mistakenly sent them to the current one. In both cases, the user won't be able to retrieve any of those tokens back since they are stuck in the contract."
"function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public override autoUnlock autoLock {
        // if the market isn't open then don't do anything else, not reverting
        // .. will allow autoLock to process the accounting to lock the market
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            // if the NFT hasn't been minted, we should probably do that
            if (!tokenExists(_card)) {
                tokenIds[_card] = nfthub.totalSupply();
                factory.mintMarketNFT(_card);
            }

            address _user = msgSender();

            // prevent re-renting, this limits (but doesn't eliminate) a frontrunning attack
            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            // restrict certain markets to specific whitelists
            require(
                treasury.marketWhitelistCheck(_user),
                ""Not approved for this market""
            );

            // if the user is foreclosed then delete some old bids
            // .. this could remove their foreclosure
            if (treasury.isForeclosed(_user)) {
                orderbook.removeUserFromOrderbook(_user);
            }
            require(
                !treasury.isForeclosed(_user),
                ""Can't rent while foreclosed""
            );
            if (ownerOf(_card) == _user) {
                // the owner may only increase by more than X% or reduce their price
                uint256 _requiredPrice = (card[_card].cardPrice *
                    (minimumPriceIncreasePercent + 100)) / (100);
                require(
                    _newPrice >= _requiredPrice ||
                        _newPrice < card[_card].cardPrice,
                    ""Invalid price""
                );
            }

            // do some cleaning up before we collect rent or check their bidRate
            orderbook.removeOldBids(_user);

            /// @dev ignore the return value and let the user post the bid for the sake of UX
            _collectRent(_card, 0);

            // check sufficient deposit
            uint256 _userTotalBidRate = (treasury.userTotalBids(_user) -
                orderbook.getBidValue(_user, _card)) + _newPrice;
            require(
                treasury.userDeposit(_user) >=
                    _userTotalBidRate / minRentalDayDivisor,
                ""Insufficient deposit""
            );

            _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.addBidToOrderbook(
                _user,
                _card,
                _newPrice,
                _timeHeldLimit,
                _startingPosition
            );

            treasury.updateLastRentalTime(_user);
        }
    }function marketWhitelistCheck(address _user)
        external
        view
        override
        returns (bool)
    {
        bytes32 requiredRole = marketWhitelist[msgSender()];
        if (requiredRole == bytes32(0)) {
            return true;
        } else {
            return hasRole(requiredRole, _user);
        }
    }","The variable, `marketWhitelist`, is never initialized in the contract `RCTreasury.sol`. As a result, the function `marketWhitelistCheck()` does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return `true`, even if a market wishes to restrict its users to a specific role.

The initial state variable is defined in RCTreasury.sol at line 75.

The state variable `marketWhitelist` is accessed in the function `RCTreasury.marketWhitelistCheck()` at RCTreasury.sol lines 269-281.

The function `RCTreasury.marketWhitelistCheck()` is called in `RCMarket.newRental()` at RCMarket.sol lines 758-761. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in `RCTreasury` that allow a market creator to enable this functionality.","The `Treasury` contract allows each market to specify which role it requires from users who want to interact with them. If no such requirement exists, any user can interact with the corresponding market. However, there is an issue whereby a malicious actor can set the `marketWhitelist` mapping on the `Treasury` contract to contain the zero byte string as the key for every single market. As a result, all users would be able to interact with these markets without having to have any particular roles at all.

This issue was discovered when I noticed that the `marketWhitelistCheck()` function always returned `true`. It seems like this is intended behaviour but it makes me question whether this is actually what the developers wanted. In my opinion, they likely didn’t intend for this functionality to work this way because otherwise, it would make sense to initialize the `marketWhitelist` mapping with empty values instead of using the zero byte string as keys."
"function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        // Pull before reward accrual
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        //convert to reward per token
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        //add epoch to list
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        //event
        emit RewardAdded(_token, _epoch, _amount);
    }","If rewards are given in fee-on-transfer tokens, users may get no rewards, breaking functionality.

Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or :::leak value with a hypothetical attack path with stated assumptions:::, but external requirements.

The underlying BAL protocol support fee-on-transfer tokens, so should Aura.

If a fee is charged the total amount available to be transferred later will be less than the `_amount` passed in.

Consider the following scenario:
User A holds 98% of the total supply of vlBAL (the system is being bootstrapped)
User B holds 1%
User C holds 1%

1.  `_token` is given out as a reward. It is a fee-on-transfer token with a fee of 2%
2.  Nobody claims the reward until it's fully available (to save gas on transaction fees)
3.  User A is the first to claim his/her reward and gets 98% of the reward, leaving 0 wei of the token left (since the other 2% was already taken as a fee by the token itself)
4.  User B tries to claim and the call reverts since there's no balance left
5.  User C tries to claim and the call reverts for them too
6.  Users B and C are angry and stop using Aura

That said, this clearly requires external factors and relies on hypothetical attack motivation that seems unlikely to me. I think it should be included as a medium risk.","The `Aura._addReward` function does not check that `_epoch > currentEpoch`. If it's called with an old `_epoch`, then the rewards will be added for all previous epochs as well. As a result, the total amount of tokens locked by users gets inflated.

Proof of Concept

*   Alice calls `aura.lock()` and locks her tokens until epoch 300. She receives 100 tokens worth of shares at this point.
*   Bob calls `aura.setRewards()`, sets up some rewards for epochs from 1 to 300. He specifies that he wants to receive these rewards starting from epoch 1.
*   Charlie calls `aura.claimRewards()`. He claims his share of the rewards for epochs 1-300. However, since there were no rewards set yet when he claimed them, he received nothing.
*   Now Bob adds more rewards for epochs 1-300 again but now they start from epoch 1 instead of 300. Since the rewards have already been distributed once, the new ones get added on top of the existing ones. So Charlie can claim his rewards again. But now he has doubled his rewards because the same tokens got locked twice."
"function reimburseImpermanentLoss(address recipient, uint256 amount)
        external
        override
    {
        require(
            msg.sender == router,
            ""VaderReserve::reimburseImpermanentLoss: Insufficient Priviledges""
        );

        // NOTE: Loss is in USDV, reimbursed in VADER
        // NOTE: If USDV LBT is working, prefer it otherwise use VADER price
        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {
            uint256 usdvPrice = lbt.getUSDVPrice();

            amount = amount / usdvPrice;
        } else {
            uint256 vaderPrice = lbt.getVaderPrice();

            amount = amount * vaderPrice;
        }

        uint256 actualAmount = _min(reserve(), amount);

        vader.safeTransfer(recipient, actualAmount);

        emit LossCovered(recipient, amount, actualAmount);
    }","IL isn't properly converted from being in terms of USDV to VADER, resulting in reserve paying out incorrect amount.

Proof of Concept

`VaderReserve.reimburseImpermanentLoss` receives an `amount` in terms of USDV and converts this to an amount of VADER to send to `recipient`.

However as shown in the code reference, if there is a previous price stored for USDV, the amount of VADER tokens to be sent to the `recipient` is `amount / usdvPrice`.

`usdvPrice` is the total USD value of foreign assets divided by the total amount of USDV in a number of pairs. It's then some measure of the inverse of the price of USDV in USD, nothing to do with converting into VADER.

The reserve will then improperly calculate the amount of VADER to pay out once there is a single reading of the USDV price.","The `Router` can call `reimburseImpermanentLoss()` on `VaderReserve`. However, this function does not have any access control so anyone can call it with a large value of `amount`, causing all funds from the reserve to be drained.

Proof of Concept

1.  Alice calls `addToReserve()` with a small amount of tokens.
2.  Bob calls `removeFromReserve()` with a larger amount than what was added by Alice.
3.  Charlie calls `reimburseImpermanentLoss()` with a very high value for `amount`.
4.  All funds from the reserve will now be transferred out as they were previously removed from the reserve."
"function mintFungible(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        uint256 foreignDeposit,
        address from,
        address to
    ) external override nonReentrant returns (uint256 liquidity) {
        IERC20Extended lp = wrapper.tokens(foreignAsset);

        require(
            lp != IERC20Extended(_ZERO_ADDRESS),
            ""VaderPoolV2::mintFungible: Unsupported Token""
        );

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);
        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);

        PairInfo storage pair = pairInfo[foreignAsset];
        uint256 totalLiquidityUnits = pair.totalSupply;
        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;
        else
            liquidity = VaderMath.calculateLiquidityUnits(
                nativeDeposit,
                reserveNative,
                foreignDeposit,
                reserveForeign,
                totalLiquidityUnits
            );

        require(
            liquidity > 0,
            ""VaderPoolV2::mintFungible: Insufficient Liquidity Provided""
        );

        pair.totalSupply = totalLiquidityUnits + liquidity;

        _update(
            foreignAsset,
            reserveNative + nativeDeposit,
            reserveForeign + foreignDeposit,
            reserveNative,
            reserveForeign
        );

        lp.mint(to, liquidity);

        emit Mint(from, to, nativeDeposit, foreignDeposit);
    }","Funds are transferred from the `from` parameter, and the output tokens are transferred to the `to` parameter, both passed by the caller without proper access control.

##### Impact

This issue allows anyone to call `mintFungible()` and `mintSynth()` and steal almost all their wallet balances for all the users who have approved the contract before.","The `VaderPoolV2` allows users to deposit tokens into a pool using the `deposit()` or `mintFungible()`. However, there's no way for users to withdraw their funds back again. As a result, all of the funds that were added by any user will be locked forever inside the contract.

Proof of Concept

*   Alice wants to add some funds to the pool so she calls `deposit()` with her token amount as argument.
*   Bob also wants to add his own funds but he doesn't have enough balance on his account so he decides to call `mintFungible()` instead. He specifies how much of his funds should be used to pay out the protocol fee.
*   Now both Alice and Bob can see that they don't have access to their funds anymore because the contract has received more funds than it ever returned."
"function hook(
    address _sender,
    uint256 _amountBeforeFee,
    uint256 _amountAfterFee
  ) external override onlyCollateral {
    require(withdrawalsAllowed, ""withdrawals not allowed"");
    if (lastGlobalPeriodReset + globalPeriodLength < block.timestamp) {
      lastGlobalPeriodReset = block.timestamp;
      globalAmountWithdrawnThisPeriod = _amountBeforeFee;
    } else {
      require(globalAmountWithdrawnThisPeriod + _amountBeforeFee <= globalWithdrawLimitPerPeriod, ""global withdraw limit exceeded"");
      globalAmountWithdrawnThisPeriod += _amountBeforeFee;
    }
    if (lastUserPeriodReset + userPeriodLength < block.timestamp) {
      lastUserPeriodReset = block.timestamp;
      userToAmountWithdrawnThisPeriod[_sender] = _amountBeforeFee;
    } else {
      require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, ""user withdraw limit exceeded"");
      userToAmountWithdrawnThisPeriod[_sender] += _amountBeforeFee;
    }
    depositRecord.recordWithdrawal(_amountBeforeFee);
    uint256 _fee = _amountBeforeFee - _amountAfterFee;
    if (_fee > 0) {
      collateral.getBaseToken().transferFrom(address(collateral), _treasury, _fee);
      _tokenSender.send(_sender, _fee);
    }
  }function withdraw(uint256 _amount) external override nonReentrant {
    uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;
    uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;
    if (withdrawFee > 0) { require(_fee > 0, ""fee = 0""); }
    else { require(_baseTokenAmount > 0, ""amount = 0""); }
    _burn(msg.sender, _amount);
    uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;
    if (address(withdrawHook) != address(0)) {
      baseToken.approve(address(withdrawHook), _fee);
      withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);
      baseToken.approve(address(withdrawHook), 0);
    }
    baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);
    emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee);
  }","In Collateral.sol, users may withdraw underlying tokens using withdraw. Importantly, the withdrawal must be approved by withdrawHook if set:

    function withdraw(uint256 _amount) external override nonReentrant {
      uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;
      uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;
      if (withdrawFee > 0) { require(_fee > 0, ""fee = 0""); }
      else { require(_baseTokenAmount > 0, ""amount = 0""); }
      _burn(msg.sender, _amount);
      uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;
      if (address(withdrawHook) != address(0)) {
        baseToken.approve(address(withdrawHook), _fee);
        withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);
        baseToken.approve(address(withdrawHook), 0);
      }
      baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);
      emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee);
    }

The hook requires that two checks are passed:

    if (lastGlobalPeriodReset + globalPeriodLength < block.timestamp) {
      lastGlobalPeriodReset = block.timestamp;
      globalAmountWithdrawnThisPeriod = _amountBeforeFee;
    } else {
      require(globalAmountWithdrawnThisPeriod + _amountBeforeFee <= globalWithdrawLimitPerPeriod, ""global withdraw limit exceeded"");
      globalAmountWithdrawnThisPeriod += _amountBeforeFee;
    }
    if (lastUserPeriodReset + userPeriodLength < block.timestamp) {
      lastUserPeriodReset = block.timestamp;
      userToAmountWithdrawnThisPeriod[_sender] = _amountBeforeFee;
    } else {
      require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, ""user withdraw limit exceeded"");
      userToAmountWithdrawnThisPeriod[_sender] += _amountBeforeFee;
    }

If it has been less than ""globalPeriodLength"" seconds since the global reset, we step into the if block, reset time becomes now and starting amount is the current requested amount. Otherwise, the new amount must not overpass the globalWithdrawLimitPerPeriod. Very similar check is done for ""user"" variables.

The big issue here is that the limit can be easily bypassed by the first person calling withdraw in each group (""global"" and ""user""). It will step directly into the if block where no check is done, and fill the variable with any input amount.

As I understand, the withdraw limit is meant to make sure everyone is guaranteed to be able to withdraw the specified amount, so there is no chance of freeze of funds. However, due to the bypassing of this check, a whale user is able to empty the current reserves put in place and cause a freeze of funds for other users, until the Collateral contract is replenished.

### Impact

A whale user is able to cause freeze of funds of other users by bypassing withdraw limit.

### Proof of Concept

1.  Collateral.sol has 10,000 USDC reserve
2.  Withdraw limit is 150 USDC per user per period
3.  There are 5 users - Alpha with collateral worth 12,000 USDC, and 4 users each with 1,000 USDC
4.  Alpha waits for a time when request would create a new lastGlobalPeriodReset **and** new lastUserPeriodReset. He requests a withdraw of 10,000 USDC.
5.  The hook is passed and he withdraws the entire collateral reserves.
6.  At this point, victim Vic is not able to withdraw their 150 USDC. It is a freeze of funds.","The `LpPair` has a `deposit()` function that allows users to add liquidity by sending tokens from their wallet directly into the pool. However, this function does not have any restrictions on how much of each token can be added at once. If an attacker wants to drain all funds from the pool they just send as many tokens as possible until it reverts due to insufficient balance or gas limits being reached.

Another way for an attacker to steal funds would be to front-run the transaction with a flash loan. They borrow some amount of tokens from Compound's protocol using FlashloanWrapper.sol which then sends them back to LpPair.sol via the `receiveFlashLoan()` function. Since there isn't enough allowance set up yet, the transfer will fail but since the entire process was done within one transaction, the whole thing gets reverted so no funds get stolen. Afterwards, the attacker sets up the necessary approvals and calls `addLiquidity()`. As long as the price doesn't change too drastically between these two transactions, most of the funds should end up getting transferred over to the attackers account."
"function unstakeWindowExpiry(
    address _account,
    uint256 _id,
    IERC20 _token
  ) external override {
    PoolStorage.Base storage ps = baseData();
    GovStorage.Base storage gs = GovStorage.gs();

    PoolStorage.UnstakeEntry memory withdraw = ps.unstakeEntries[_account][_id];
    require(withdraw.blockInitiated != 0, 'WITHDRAW_NOT_ACTIVE');

    require(
      withdraw.blockInitiated + gs.unstakeCooldown + gs.unstakeWindow < uint40(block.number),
      'UNSTAKE_WINDOW_NOT_EXPIRED'
    );
    delete ps.unstakeEntries[_account][_id];
    ps.lockToken.safeTransfer(_account, withdraw.lock);
  }","The `PoolBase.unstakeWindowExpiry` function allows unstaking tokens of other users. While the tokens are sent to the correct address, this can lead to issues with smart contracts that might rely on claiming the tokens themselves.

For example, suppose the `_to` address corresponds to a smart contract that has a function of the following form:
```solidity
function withdrawAndDoSomething() {
    uint256 amount = token.balanceOf(address(this));
    contract.unstakeWindowExpiry(address(this), id, token);
    amount = amount - token.balanceOf(address(this));
    token.transfer(externalWallet, amount)
}
```
If the contract has no other functions to transfer out funds, they may be locked forever in this contract.","The `GovStaking` contract has a parameter called `unstakeCooldown`. It defines how long users have to wait before they can initiate an unstake again after their previous attempt failed or was cancelled by governance. If this value is set too high (e.g., >1 week) then it will be possible for malicious actors to repeatedly fail attempts at stakes and thus prevent other users from being able to stake. See issue #387."
"function donate(IERC20 _token, uint256 _amount) external {
        require(activated[_token] != 0, ""!activated"");
        savedTokens[_token] += _amount;
        _token.safeTransferFrom(msg.sender, address(this), _amount);
    }","Function donate in Shelter shouldn't allow new deposits after the grace period ends, when the claim period begins. Otherwise, it will be possible to increase savedTokens[_token], and thus new user claim amounts will increase after some users might already have withdrawn their shares.","The `donate` function of `FeePool` allows users to deposit any token they want into the pool by calling this function with their desired amount as a parameter. However, there's no upper limit on how much tokens can be added to the pool so an attacker could potentially drain all funds from the pool if enough people call this function with a large number of tokens (e.g., USDC).

Proof of Concept

1.  Alice calls `donate()` with a very small amount of DAI (say $1 worth of DAI).
2.  Bob calls `donate()` with a very large amount of USDC (say $1 million worth of USDC).
3.  Charlie calls `donate()` with another very large amount of USDC (say $1 million worth of USCD again).
4.  Now the total value of assets held by FeePool is now $1 + $1M + $1M = $2M.
5.  An attacker then calls `withdrawFeesTo()`, which will transfer out all the fees that have been accrued since the last time it was called. Since the attacker has already transferred in a lot more than what he needs for his own transactions, he should receive most or all of the fee rewards.

As you can see, the attacker only needed to pay gas costs when calling `donate()`. He didn’t even lose anything because he got paid back in fees. So, the attacker just drained the entirety of the funds from the protocol without having to spend any Ether himself."
"function claimRewards(address beneficiary) external virtual override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _userCheckpoint(beneficiary);
        uint256 amount = perUserShare[beneficiary];
        if (amount <= 0) return 0;
        perUserShare[beneficiary] = 0;
        controller.inflationManager().mintRewards(beneficiary, amount);
        emit RewardClaimed(beneficiary, amount);
        return amount;
    }

function stake(uint256 amount) external virtual override returns (bool) {
        return stakeFor(msg.sender, amount);
    }

function poolCheckpoint() public virtual override returns (bool) {
        if (killed) {
            return false;
        }
        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);
        // Update the integral of total token supply for the pool
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        if (totalStaked > 0) {
            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);
        }
        ammLastUpdated = uint48(block.timestamp);
        return true;
    }","The first staker within the `AmmGauge` may not get the rewards if the pool is not checkpointed right after he stakes and before he wants to claim the rewards.

A testing environment that reproduces how the protocol is going to be deployed and managed is used to evaluate this case under the following assumptions and simplifications.

1.  The inflation rate is fixed for simplicity (`0.001`).
2.  For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment.
3.  The minting of tokens impact both on the inflation calculation and their balance. But this test evaluates the states just before minting (claimable balances). Following how the pools are updated, they are checkpointed in the end of the `_executeInflationRateUpdate` call. Not while staking.

In order to illustrate this scenario we will show both the vulnerable and non vulnerable situations.

Vulnerable Situation:

1.  Alice, Bob, Charlie and David are future users of the pool. They all notice the inception of this project and decide to stake.
2.  They all stake the same amount. Their transactions are mined with 1min of difference starting from Alice and finishing with David.
3.  There is no external pool checkpoint between Alice and Bob (besides the one that is triggered when Bob stakes).
4.  Sometime happens and they all want to check their accumulated reward balance. Alice accumulated much less than the others.

Non Vulnerable Situation:

*   The same as before but calling externally `_poolCheckpoint()` between Alice stake call and Bobs' and before checking the accumulated rewards.

The code to show this has a `secureCheckpoints` toggle that can be set as true or false to trigger (or not) the intermediate poolCheckpoints.

The outputs for both cases are shown on the following chart. The initial staking amount is 10eth amount of the DummyERC20 token.

|         | Without Checkpoints | With Checkpoints |
| :-----: | :-----------------: | :--------------: |
|  Alice  |         6.6         |       115.5      |
|   Bob   |        111.9        |       111.9      |
| Charlie |        110.1        |       110.1      |
|  David  |        108.9        |       108.9      |","The `claimRewards` function of `GaugeController` allows anyone with a role that includes `Roles.GAUGE_ZAP`. However, this role does not have any permissions or restrictions on it. Anyone can call `stake()` which will trigger a checkpoint by calling `poolCheckpoint()`. If they do so at exactly the same timestamp as when `claimRewards` was called then their rewards will be zeroed out since the reward calculation uses the previous value of `ammStakedIntegral`:
```solidity
// @audit this could lead to users receiving no rewards due to rounding errors
if (_lastUpdateTime < lastUpdateTime) {
    userAccruedPerShare += ((timeElapsed * accruedPerSecond + FixedPoint.ONE / 1e36) >> FIXED_POINT_PRECISION);
} else {
    userAccruedPerShare += (accruedPerSecond * timeElapsed) >> FIXED_POINT_PRECISION;
}
return userAccruedPerShare;
```
This means that even though the attacker has received tokens from the protocol through staking, they would receive nothing back from the `claimRewards` function because the update happened right beforehand. As a result, the attacker's account balance remains unchanged while the gauge's state changes accordingly."
"function _mature() 
        private
        returns (uint256 _chiAtMaturity)
    {
        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18);
        chiAtMaturity = _chiAtMaturity;
        emit SeriesMatured(_chiAtMaturity);
    }

function _accrual()
        private
        returns (uint256 accrual_)
    {
        if (chiAtMaturity == type(uint256).max) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.
            _mature();
        } else {
            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18);
            accrual_ = chi.wdiv(chiAtMaturity);
        }
        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)
    }function peek(bytes32 base, bytes32 kind, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {
        uint256 price;
        (price, updateTime) = _peek(base.b6(), kind.b6());
        value = price * amount / 1e18;
    }

function get(bytes32 base, bytes32 kind, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {
        uint256 price;
        (price, updateTime) = _peek(base.b6(), kind.b6());
        value = price * amount / 1e18;
    }","The chi oracle in contract `CompoundMultiOracle` calls the function `exchangeRateStored` rather than `exchangeRateCurrent` to get the exchange rate from Compound. However, since the function `exchangeRateStored` does not accrue interest before calculating the exchange rate, the return data could be out-of-date and affect the results of `_mature` and `_accrual` in the contract `FYToken`.","In `Oracle`, `_peek` will return a zero-value for any unknown token pair. However, this does not prevent users from calling functions like `peek` or `get`. These calls would always return `(0, 0)` as their result. As a result, these functions could break critical functionality of other contracts that rely on them. For example, `Series._accrual` uses `oracle.get()` which relies on `peek()`. If `peek()` returned `(0, 0)`, then `_accrual` would also return `(0, 0)`. Since `_accrual` cannot return `(0, 0)`, it reverts instead. Thus, `Series._accrual` fails whenever an unsupported token pair is used with Oracle."
"function settleAuction(
        uint256[] memory bountyIDs,
        address[] memory inputTokens,
        uint256[] memory inputWeights,
        address[] memory outputTokens,
        uint256[] memory outputWeights
    ) public nonReentrant override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondBlock + ONE_DAY > block.number);
        require(msg.sender == auctionBonder);
        require(inputTokens.length == inputWeights.length);
        require(outputTokens.length == outputWeights.length);

        for (uint256 i = 0; i < inputTokens.length; i++) {
            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);
        }

        for (uint256 i = 0; i < outputTokens.length; i++) {
            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);
        }

        //TODO: name a and b or further split up
        uint256 a = factory.auctionMultiplier() * basket.ibRatio();
        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();
        uint256 newRatio = a - b;

        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();
        IERC20 basketAsERC20 = IERC20(address(basket));

        for (uint256 i = 0; i < pendingWeights.length; i++) {
            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
        }

        basket.setNewWeights();
        basket.updateIBRatio(newRatio);
        auctionOngoing = false;
        hasBonded = false;

        basketAsERC20.safeTransfer(msg.sender, bondAmount);
        withdrawBounty(bountyIDs);

        emit AuctionSettled(msg.sender);
    }function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {
        auctionDecrement = newAuctionDecrement;
    }","The function `Factory.setAuctionDecrement()` allows the owner to set the state variable `Factory.auctionDecrement` to zero.

If `Factory.auctionDecrement` equals zero then the function `Auction.settleAuction()` will always revert due to a division by zero:

    uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();","The `factory` variable of `IndexPool`, which holds an instance of `Factory`, does not have any access control modifiers on it's functions. As such, anyone can call these functions with arbitrary parameters, allowing them to change critical variables like `auctionDecrement`. An attacker could then use this to manipulate the protocol by calling `settleAuction()` at will until they achieve their desired outcome.

For example, if the current value of `auctionDecrement` is 1e48, an attacker could first call `setAuctionDecrement(1)` before calling `settleAuction()`. They would be able to do so as long as there was no other active auctions. Once they had successfully called `settleAuction()`, they could again call `setAuctionDecrement(1e48)`.

This allows an attacker to effectively ""freeze"" all future auctions that try to run while they hold the position. Note that this doesn't allow them to steal funds from users who attempt to redeem their positions during this time period. However, it still grants them significant power over the system."
"function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }","The balance checkpointing system exposed by the contract for governance purposes is flawed as it does not maintain voting balances properly. In detail, the total supply of votes is tracked as the sum of all locked balances, however, the total voting power of an individual only tracks delegated balances. As a result, governance percentage thresholds will be significantly affected and potentially unmet.

The governance module may be unusable due to the significant discrepancy between ""circulating"" voting power supply and the actual voting power of each individual summed up.

Issue is deducible by inspecting the relevant lines referenced in the issue and making note of the calculations within the `getPastVotes` individual voting power function as well as the `getPastTotalSupply` cumulative voting power function.","The `getPastVotes` function of ERC20Votes does not check that the provided timestamp is smaller than now. If it's larger or equal then the result will be wrong because the current epoch has already ended. Also, this function should only work for past timestamps but it works also with future ones which makes no sense at all.

Also, the same issue exists on the `totalSupplyAtEpoch` function used by the `getPastTotalSupply`."
"function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external override returns (bool) {
        (bool success, uint256 newAllowance) =
            proxy.nTokenTransferFrom(currencyId, msg.sender, from, to, amount);

        // Emit transfer events here so they come from the correct contract
        emit Transfer(from, to, amount);
        emit Approval(msg.sender, from, newAllowance);

        return success;
    }","Different parameter are being set in `Approval` event in `transferFrom()`. The impact is that, this error may negatively impact off-chain tools that are monitoring critical transfer events of the token. In the code, the first parameter should be owner and the second should be spender as mentioned in ntokenErc20.sol: event Approval(address indexed owner, address indexed spender, uint256 amount); However, the emit statement uses emit Approval(msg.sender, from, newAllowance); which sets the parameters incorrectly.","The `transferFrom` function of `NFTXStakedDaoLockerUpgradeable` does not check if the user has enough allowance for this action. If a malicious or compromised user grants an attacker a large number of tokens as approvals, then the attacker can drain all funds by repeatedly calling `transferFrom`.

Proof of Concept

1.  Alice wants to lock her NFTX token with the staking pool. She first calls `approve()` on the NFTX token contract to grant the staking pool a large number of tokens as approvals.
2.  Bob, who controls the staking pool, now tries to steal all of Alice's funds by calling `transferFrom()`. He will be able to do this because he has been granted a very large number of tokens via `approve()`, which allows him to call `transferFrom()` without having to pay any gas fees.
3.  As long as there are no other users between Bob and Alice, then Bob can continue to call `transferFrom()` until he drains all of Alice's funds."
"function rentAllCards(uint256 _maxSumOfPrices) external override {
        _checkState(States.OPEN);
        // check that not being front run
        uint256 _actualSumOfPrices = 0;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (card[i].cardPrice == 0) {
                _actualSumOfPrices += MIN_RENTAL_VALUE;
            } else {
                _actualSumOfPrices +=
                    (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) /
                    100;
            }
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (card[i].cardPrice > 0) {
                    _newPrice =
                        (card[i].cardPrice *
                            (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }","The function `rentAllCards` of `RCMarket` checks for `_maxSumOfPrices` to see you are not paying more that you want.

However, the first part of the calculations (which calculate `_actualSumOfPrices` ), do not take in account the fact that you might already own a card. (while the second part of the code does). If you already own the card you don't have to pay for it and you certainly don't have to pay the extra `minimumPriceIncreasePercent`.

The code at ""Proof of Concept"" shows a refactored version of the code (see other issue ""make code of `rentAllCards` easier to read""). This immediately shows the issue.

```solidity
// simplified version
function calc(uint256 currentPrice) returns(uint256) {
    if (currentPrice == 0)
        return MIN_RENTAL_VALUE;
    return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;
}

function rentAllCards(uint256 _maxSumOfPrices) external override {
    ..
    uint256 _actualSumOfPrices = 0;
    for (uint256 i = 0; i < numberOfCards; i++) {
        _actualSumOfPrices += calc(card[i].cardPrice);   // no check for  (ownerOf(i) != msgSender()) {
    }
    require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

    for (uint256 i = 0; i < numberOfCards; i++) {
        if (ownerOf(i) != msgSender()) {
            uint256 _newPrice=calc(card[i].cardPrice);
            newRental(_newPrice, 0, address(0), i);
        }
    }
}
```","The `rentAllCards` function of `RCFactory.sol` iterates over all cards (`numberOfCards`) but only checks up until `length`. If there's a card with index greater than or equal to `length`, it will be skipped without any error message. As a result, this card won't get rented out by anyone.

Proof of Concept

*   Assume `length=3`
*   Call `addCard()` four times so that `numberOfCards==4`
*   Call `setLength(4)`
*   Now call `rentAllCards()`. It should fail because one card has no owner yet. However, since the iteration stops at `length-1`, the last card gets missed. No one can rent it out."
"function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }","The current ownership transfer process involves the current owner calling `NoteERC20.transferOwnership()`. This function checks that the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the `onlyOwner()` modifier.",The `transferOwnership` function of `OwnableUpgradeSafe` does not have a check for ownership being transferred to itself. If this happens then it will break all access control as the owner can no longer change the owner or perform any other actions that require ownership.
"function mint(address to, uint256 id) external override onlyConvenience {
        _safeMint(to, id);
    }","In CollateralizedDebt.sol, the mint() function calls _safeMint() which has a callback to the ""to"" address argument.  Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.","The `mint` function of `ERC721EnumerableUpgradeable` does not have any access control or restrictions on who can call it. Anyone can mint an NFT for anyone else by calling this function with arbitrary addresses as parameters.

This allows griefing attacks where a malicious user can drain all gas fees from other users trying to list their NFTs on marketplaces like OpenSea. Users will be charged much higher gas prices than usual because they'll have to pay more ETH to cover the increased cost of the transaction. As a result, these users may decide that listing their NFTs on OpenSea isn’t worth it anymore."
"function _mint(
        ISetToken _setToken,
        IWrappedfCashComplete _fCashPosition,
        uint256 _maxAssetAmount,
        uint256 _fCashAmount,
        bool _fromUnderlying
    )
    internal
    {
        uint32 minImpliedRate = 0;

        bytes4 functionSelector = 
            _fromUnderlying ? _fCashPosition.mintViaUnderlying.selector : _fCashPosition.mintViaAsset.selector;
        bytes memory mintCallData = abi.encodeWithSelector(
            functionSelector,
            _maxAssetAmount,
            uint88(_fCashAmount),
            address(_setToken),
            minImpliedRate,
            _fromUnderlying
        );
        _setToken.invoke(address(_fCashPosition), 0, mintCallData);
    }","If a `_fCashAmount` value that is greater than uint88 is passed into the `_mint` function, downcasting it to uint88 will silently overflow.","The `FcashToYieldSource._mint` function calls a fCash position's `mintVia*` functions with an uninitialized value for `minImpliedRate`. As a result, this parameter will be set as zero which may not always be desirable or intended by users of these functions."
"function createRJLaunchEvent(
        address _issuer,
        uint256 _phaseOneStartTime,
        address _token,
        uint256 _tokenAmount,
        uint256 _tokenIncentivesPercent,
        uint256 _floorPrice,
        uint256 _maxWithdrawPenalty,
        uint256 _fixedWithdrawPenalty,
        uint256 _maxAllocation,
        uint256 _userTimelock,
        uint256 _issuerTimelock
    ) external override returns (address) {
        require(
            getRJLaunchEvent[_token] == address(0),
            ""RJFactory: token has already been issued""
        );
        require(_issuer != address(0), ""RJFactory: issuer can't be 0 address"");
        require(_token != address(0), ""RJFactory: token can't be 0 address"");
        require(_token != wavax, ""RJFactory: token can't be wavax"");
        require(
            _tokenAmount > 0,
            ""RJFactory: token amount needs to be greater than 0""
        );
        require(
            IJoeFactory(factory).getPair(_token, wavax) == address(0) ||
                IJoePair(IJoeFactory(factory).getPair(_token, wavax))
                    .totalSupply() ==
                0,
            ""RJFactory: liquid pair already exists""
        );

        address launchEvent = Clones.clone(eventImplementation);

        // msg.sender needs to approve RocketJoeFactory
        IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);

        ILaunchEvent(payable(launchEvent)).initialize(
            _issuer,
            _phaseOneStartTime,
            _token,
            _tokenIncentivesPercent,
            _floorPrice,
            _maxWithdrawPenalty,
            _fixedWithdrawPenalty,
            _maxAllocation,
            _userTimelock,
            _issuerTimelock
        );

        getRJLaunchEvent[_token] = launchEvent;
        isRJLaunchEvent[launchEvent] = true;
        allRJLaunchEvents.push(launchEvent);

        _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);

        return launchEvent;
    }","In the current implementation, `RocketJoeFactory.sol#createRJLaunchEvent()` can be called by anyone with at least 1 Wei of `_token`.

This allows a malicious user or attacker to call `createRJLaunchEvent()` with minimal cost and stop others, especially the platform itself or the rightful issuer of the token from creating the RJLaunchEvent.","The `createRJLaunchEvent` function of RJFactory allows an attacker to front-run a new event creation by using the same `_token`. As long as the parameters match, this will lead to a reentrancy issue where the funds sent from the user are transferred back into the factory instead of being used for the intended purpose. An attacker could then use these funds to manipulate the protocol or steal them altogether.

Proof of Concept

1.  Alice wants to create a new event with token USDC but there’s no such event yet so she calls `createRJLaunchEvent()` with her desired parameters. She sends some tokens along with it.
2.  Bob sees that he can do the exact same thing at almost exactly the same time as Alice did. He also sends his own tokens along with his call.
3.  Since both transactions happen very close together, they end up getting mined one after another.
4.  When the first transaction gets executed, the check on line 78 passes because there isn’t any other event created with USDC yet. So the transaction goes through and creates a new event called `newEvent`. It transfers the tokens from Alice over to `newEvent`, which now holds those tokens.
5.  Now when the second transaction tries to execute, it fails on line 79 since `getRJLaunchEvent[USDC]` doesn’t equal zero anymore. But since the first transaction was successful, `allRJLaunchEvents` contains `newEvent` and therefore `isRJLaunchEvent[newEvent]` equals true. And since `isRJLaunchEvent[newEvent]` equals true, the transaction reverts.

As you can see, the attacker can easily drain funds from users who try to create events simultaneously."
"function outboundTransfer(
        address _l1Token,
        address _to,
        uint256 _amount,
        bytes calldata _data
    ) public override whenNotPaused returns (bytes memory res) {
        require(_l1Token == l1Lpt, ""TOKEN_NOT_LPT"");

        (address from, bytes memory extraData) = parseOutboundData(_data);
        require(extraData.length == 0, ""CALL_HOOK_DATA_NOT_ALLOWED"");

        Mintable(l2Lpt).burn(from, _amount);
        IL2LPTDataCache(l2LPTDataCache).decreaseL2SupplyFromL1(_amount);

        uint256 id = sendTxToL1(
            from,
            l1Counterpart,
            getOutboundCalldata(_l1Token, from, _to, _amount, extraData)
        );

        // we don't need to track exitNums (b/c we have no fast exits) so we always use 0
        emit WithdrawalInitiated(_l1Token, from, _to, id, 0, _amount);

        return abi.encode(id);
    }","The method (a) described above won't work in the current implementation due to the missing interface on `L2LPTGateway`.

When initiate a withdraw from the Arbitrum Gateway Router, `L2GatewayRouter` will call `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` on `ITokenGateway(gateway)`:

```solidity
function outboundTransfer(
    address _token,
    address _to,
    uint256 _amount,
    uint256 _maxGas,
    uint256 _gasPriceBid,
    bytes calldata _data
) external payable returns (bytes memory);
```

```solidity
function outboundTransfer(
    address _l1Token,
    address _to,
    uint256 _amount,
    bytes calldata _data
) public payable returns (bytes memory) {
    return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);
}
```

```solidity
function outboundTransfer(
    address _token,
    address _to,
    uint256 _amount,
    uint256 _maxGas,
    uint256 _gasPriceBid,
    bytes calldata _data
) public payable virtual override returns (bytes memory) {
    address gateway = getGateway(_token);
    bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(
        msg.sender,
        _data
    );

    emit TransferRouted(_token, msg.sender, _to, gateway);
    return
        ITokenGateway(gateway).outboundTransfer{ value: msg.value }(
            _token,
            _to,
            _amount,
            _maxGas,
            _gasPriceBid,
            gatewayData
        );
}
```

However, `L2LPTGateway` does not implement `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` but only `outboundTransfer(address,address,uint256,bytes)`:

```solidity
function outboundTransfer(
    address _l1Token,
    address _to,
    uint256 _amount,
    bytes calldata _data
) public override whenNotPaused returns (bytes memory res) {
    // ...
}
```

Therefore, the desired feature to withdraw LPT from L2 to L1 via Arbitrum Router will not be working properly.","The `outboundTransfer` function of L2LivepeerMerge does not check if `_to` is a valid user or a contract that can receive tokens. If it points to an invalid destination, funds will be lost forever.

Proof of Concept

*   User calls `outboundTransfer`.
*   Since there’s no restrictions on who can call this function, any malicious actor could do so with arbitrary parameters.
*   Malicious actor sets `_to=maliciousContract`, which would then lose all their funds as they cannot recover them anymore due to the lack of functionality for users to withdraw their funds back onto layer one."
"function harvest() public whenNotPaused returns (uint256 harvested) {
        _onlyAuthorizedActors();

        uint256 _before = IERC20Upgradeable(want).balanceOf(address(this));

        uint256 _beforeCVX = IERC20Upgradeable(reward).balanceOf(address(this));

        // Get cvxCRV
        LOCKER.getReward(address(this), false);

        // Rewards Math
        uint256 earnedReward =
            IERC20Upgradeable(reward).balanceOf(address(this)).sub(_beforeCVX);

        // Because we are using bCVX we take fees in reward
        //NOTE: This will probably revert because we deposit and transfer on same block
        (uint256 governancePerformanceFee, uint256 strategistPerformanceFee) =
            _processRewardsFees(earnedReward, reward);

        // Swap cvxCRV for want (bCVX)
        _swapcvxCRVToWant();

        uint256 earned =
            IERC20Upgradeable(want).balanceOf(address(this)).sub(_before);

        /// @dev Harvest event that every strategy MUST have, see BaseStrategy
        emit Harvest(earned, block.number);

        /// @dev Harvest must return the amount of want increased
        return earned;
    }function harvest() external whenNotPaused returns (uint256 cvxHarvested) {
        _onlyAuthorizedActors();
        // 1. Harvest gains from positions
        _tendGainsFromPositions();

        uint256 stakedCvxCrv = cvxCrvRewardsPool.balanceOf(address(this));
        if (stakedCvxCrv > 0) {
            cvxCrvRewardsPool.withdraw(stakedCvxCrv, true);
        }
        
        // 2. Swap cvxCRV tokens to CVX
        uint256 cvxCrvBalance = cvxCrvToken.balanceOf(address(this));

        if (cvxCrvBalance > 0) {
            _swapExactTokensForTokens(sushiswap, cvxCrv, cvxCrvBalance, getTokenSwapPath(cvxCrv, cvx));
        }

        // Track harvested + converted coin balance of want
        cvxHarvested = cvxToken.balanceOf(address(this));
        _processFee(cvx, cvxHarvested, performanceFeeGovernance, IController(controller).rewards());

        // 3. Stake all CVX
        if (cvxHarvested > 0) {
            cvxRewardsPool.stake(cvxToken.balanceOf(address(this)));
        }

        emit Harvest(cvxHarvested, block.number);
        return cvxHarvested;
    }","In veCVXStrategy, the cvxCRV -> ETH -> CVX conversion via sushiswap is done with 0 minAmountOut, making it susceptible to sandwich attacks / MEV flashbots. This is also true for UniSwapper inherited by StrategyCvxHelper.","The `harvest` functions of both `ConvexStakingWrapper` and `ConvexYieldStrategy` swap their token balances with other tokens before emitting a harvest event. However, these events do not account for any swaps performed by the respective functions. As a result, users may be misled into believing they received more rewards than they actually did.

Proof of Concept

Consider the following scenario:

*   Alice calls `convexYieldStrategy.harvest()` which performs a swap between `crv` and `cvx`.
*   After this call, Alice's `crv` balance has decreased while her `cvx` balance has increased.
*   An hour later, Bob calls `convexStakingWrapper.harvest()`.
*   Since there were no changes made to either pool since Alice last called `harvest()`, Bob's `crv` balance remains unchanged while his `cvx` balance increases as well due to the swap performed earlier.
*   Now, Alice wants to withdraw some funds but realizes she only receives back half of what she had initially after calling `convexYieldStrategy.harvest()`. She thinks she should receive twice as much considering how many hours passed since then.

Impact

Users who rely on the `harvest` events to track their rewards or monitor the health of the protocol may become confused about the actual number of rewards they received. They might also lose confidence in the system and decide against participating further.

### Proof of Concept

Alice calls `convexYieldStrategy.harvest()` which performs a swap between `crv` and `cvx`.
After this call, Alice's `crv` balance has decreased while her `cvx` balance has increased.
An hour later, Bob calls `convexStakingWrapper.harvest()`.
Since there were no changes made to either pool since Alice last called `harvest()`, Bob's `crv` balance remains unchanged while his `cvx` balance increases as well due to the swap performed earlier.
Now, Alice wants to withdraw some funds but realizes she only receives back half of what she had initially after calling `convexYieldStrategy.harvest()`. She thinks she should receive twice as much considering how many hours passed since then."
"function withdrawReward(uint256[] calldata tranches)
        external
        returns (uint256 withdrawAmount)
    {
        require(
            isIncentiveReporter(msg.sender),
            ""Contract not authorized to report incentives""
        );

        updateDayTotals();

        withdrawAmount = accruedReward[msg.sender];
        for (uint256 i; tranches.length > i; i++) {
            uint256 tranche = tranches[i];

            TrancheMeta storage tm = trancheMetadata[tranche];
            Claim storage claim = tm.claims[msg.sender];

            withdrawAmount += updateAccruedReward(tm, msg.sender, claim);

            (uint256 gainImpact, uint256 lossImpact) = applyIntraDay(
                                                                     tm,
                claim
            );

            withdrawAmount = withdrawAmount + gainImpact - lossImpact;

            tm.intraDayGains -= claim.intraDayGain;
            tm.intraDayLosses -= claim.intraDayLoss;
            tm.intraDayRewardGains -= gainImpact;
            tm.intraDayRewardLosses -= lossImpact;
            
            claim.intraDayGain = 0;
        }

        accruedReward[msg.sender] = 0;

        Fund(fund()).withdraw(MFI, msg.sender, withdrawAmount);
    }","The withdrawReward fails due to the loop at line 269. Based on testing, the dayDiff would be 18724 and with a gasLimit of 9500000 it stops at iteration 270 due to the fact that lastUpdatedDay is not initialized so is 0. Other than that it could run out of gas also for the loop of allTranches at line 281 because it's an unbounded array.","The `updateAccruedReward` function of IncentiveDistribution does not check if a user has already claimed rewards from a specific tranche before adding their new reward amount to it. As a result, users can repeatedly call this function with smaller amounts each time they want to claim more rewards without having to wait until the end of the day. They will be able to do so as long as there's enough balance available on the fund.

As a result, an attacker could drain funds by calling the `withdrawRewards` function multiple times while only paying out a small fraction of the total rewards at once. Since the attacker doesn't have to wait until the next day, they would be able to continue draining funds until all remaining rewards were paid out."
"function claimRewards(
        address _user,
        uint256 _promotionId,
        uint256[] calldata _epochIds
    ) external override returns (uint256) {
        Promotion memory _promotion = _getPromotion(_promotionId);

        uint256 _rewardsAmount;
        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];

        for (uint256 index = 0; index < _epochIds.length; index++) {
            uint256 _epochId = _epochIds[index];

            require(
                !_isClaimedEpoch(_userClaimedEpochs, _epochId),
                ""TwabRewards/rewards-already-claimed""
            );

            _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);
            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);
        }

        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;

        _promotion.token.safeTransfer(_user, _rewardsAmount);

        emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);

        return _rewardsAmount;
    }

function _calculateRewardAmount(
        address _user,
        Promotion memory _promotion,
        uint256 _epochId
    ) internal view returns (uint256) {
        uint256 _epochDuration = _promotion.epochDuration;
        uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);
        uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;

        require(block.timestamp > _epochEndTimestamp, ""TwabRewards/epoch-not-over"");

        ITicket _ticket = ITicket(_promotion.ticket);

        uint256 _averageBalance = _ticket.getAverageBalanceBetween(
            _user,
            uint64(_epochStartTimestamp),
            uint64(_epochEndTimestamp)
        );

        uint64[] memory _epochStartTimestamps = new uint64[](1);
        _epochStartTimestamps[0] = uint64(_epochStartTimestamp);

        uint64[] memory _epochEndTimestamps = new uint64[](1);
        _epochEndTimestamps[0] = uint64(_epochEndTimestamp);

        uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(
            _epochStartTimestamps,
            _epochEndTimestamps
        );

        if (_averageTotalSupplies[0] > 0) {
            return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];
        }

        return 0;
    }","When claiming rewards via `claimRewards()`, the function `_calculateRewardAmount()` is called. The function `_calculateRewardAmount()` has a check to make sure the epoch is over

  require(block.timestamp > _epochEndTimestamp, ""TwabRewards/epoch-not-over""); 

However neither functions check if the `_epochId` is within the range of the reward epochs. Ergo it is possible to continue claiming rewards after the reward period is over. This only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.

The proof of concept contains a simplified version of the contract, and shows how this can be done. When run in remix you get the following output, while there is only 1 epoch.
console.log:
 Claiming for epoch 1 1
 Claiming for epoch 2 1
 Claiming for epoch 3 1
 Claiming for epoch 4 1
 Claiming for epoch 5 1","The `TwabRewards` contract allows users to claim rewards by calling the `claimRewards()` function with a list of epoch IDs that they want to claim. However, there's no check on whether an epoch ID exists or not. If a user calls this function with non-existent epoch IDs, it will revert as shown below.

```solidity
// TwabRewards.sol L378
require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), ""TwabRewards/rewards-already-claimed"");

// LibMath.sol L9
/// @dev Checks if `_value` is less than `_other`.
/// @param value First value to compare
/// @param other Second value to compare
/// @return True if `_value` is less than `_other`, otherwise false.
function lt(uint256 value, uint256 other) public pure returns (bool) {
    // Short circuit first
    if (value == other) {
        return false;
    } else {
        return value < other;
    }
}
```

As a result, users can lose their funds when trying to call the `claimRewards()` function because of the lack of existence checks."
"function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }","Successful `arbRestake` performs `_redeemShares` for `arbRewardShares` amount to extract the arbitrager reward. This effectively reduces shares accounted for an NFT, but leaves untouched the `addressShares` of an `nftOwner`.

As a result the `tokenBalanceOfAddress` function will report an old balance that existed before arbitrager reward was slashed away. This will persist if the owner will transfer the NFT to someone else as its new reduced shares value will be subtracted from `addressShares` in `_beforeTokenTransfer`, leaving the arbitrage removed shares permanently in `addressShares` of the NFT owner, essentially making all further reporting of his balance incorrectly inflated by the cumulative arbitrage reward shares from all arbRestakes happened to the owner's NFTs.

Proof of Concept

`arbRestake` redeems `arbRewardShares`, which are a part of total shares of an NFT:

This will effectively reduce the `stakeShares`:

But there is no mechanics in place to reduce `addressShares` of the owner apart from mint/burn/transfer, so `addressShares` will still correspond to NFT shares before arbitrage. This discrepancy will be accumulated further with arbitrage restakes.","The `NFTXInventory` contract has a mapping called `addressShares`. It keeps track of how many shares each user owns. However, it does not have any way to update these values after they've been set. If you transfer ownership of one of your NFTs or restake them, then try to claim your share of the funds, you will receive nothing because the value stored at `addressShares[msg.sender]` was never updated. You could also lose all of your shares if someone else transfers their NFT into your account before you do anything with it. I believe this issue affects most functions which use `addressShares`, but I only found two examples here."
"function reweight(address[] calldata _updatedAssets, uint8[] calldata _updatedWeights) external override {
        require(
            _updatedAssets.length > 1 &&
                _updatedWeights.length == _updatedAssets.length &&
                _updatedAssets.length <= IIndexRegistry(registry).maxComponents(),
            ""ManagedIndex: INVALID""
        );

        uint virtualEvaluationInBase;
        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());
        for (uint i; i < assets.length(); ++i) {
            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))
                .assetBalanceOf(address(this));
            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);
        }

        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());
        uint orderId = orderer.placeOrder();

        uint _totalWeight = IndexLibrary.MAX_WEIGHT;

        for (uint i; i < _updatedAssets.length; ++i) {
            address asset = _updatedAssets[i];
            require(asset != address(0), ""ManagedIndex: ZERO"");

            uint8 newWeight = _updatedWeights[i];

            if (i > 0) {
                // makes sure that there are no duplicate assets
                require(_updatedAssets[i - 1] < asset, ""ManagedIndex: SORT"");
            }

            if (newWeight > 0) {
                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), ""ManagedIndex: INVALID_ASSET"");
                assets.add(asset);
                inactiveAssets.remove(asset);

                uint8 prevWeight = weightOf[asset];
                if (prevWeight != newWeight) {
                    emit UpdateAnatomy(asset, newWeight);
                }

                _totalWeight = _totalWeight + newWeight - prevWeight;
                weightOf[asset] = newWeight;

                uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;
                uint amountInAsset = amountInBase.mulDiv(oracle.refreshedAssetPerBaseInUQ(asset), FixedPoint112.Q112);
                (uint newShares, uint oldShares) = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(asset))
                    .shareChange(address(this), amountInAsset);

                if (newShares > oldShares) {
                    orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);
                } else if (oldShares > newShares) {
                    orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);
                }
            } else {
                require(assets.remove(asset), ""ManagedIndex: INVALID"");
                inactiveAssets.add(asset);

                _totalWeight -= weightOf[asset];

                delete weightOf[asset];

                emit UpdateAnatomy(asset, 0);
            }
        }
        address[] memory _inactiveAssets = inactiveAssets.values();
        for (uint i; i < _inactiveAssets.length; ++i) {
            uint shares = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(_inactiveAssets[i])).balanceOf(address(this));
            if (shares > 0) {
                orderer.addOrderDetails(orderId, _inactiveAssets[i], shares, IOrderer.OrderSide.Sell);
            } else {
                inactiveAssets.remove(_inactiveAssets[i]);
            }
        }
        require(_totalWeight == IndexLibrary.MAX_WEIGHT, ""ManagedIndex: MAX"");
    }","The list of assets won't be changed after reweight because of reverted tx.

Proof of Concept

`require(_updatedAssets.length <= IIndexRegistry(registry).maxComponents())`
when reweight is not true, because as in the doc,
`maxComponent` is the maximum assets for an index, but `_updatedAssets` also contain the assets that you want to remove. So the comparision makes no sense.","The `reweight` function of ManagedIndex calls a vtoken's share change method with an incorrect number of tokens as input. As a result, it will fail when trying to sell these tokens back to the index.

Proof of Concept

*   Assume that the current state has two assets, A and B, each having a weight of 50%
*   Alice wants to remove asset B from the index by calling `reweight([A],[50])`. She expects this call to succeed because she is removing one token which should be sold at market rate. However, since the total supply of VTokenB is zero, the transaction fails."
"function liquidate(
        uint256 _id,
        uint256 _collateral,
        uint256 _usdm
    ) external override updateDebt(_id) {
        require(msg.sender == address(engine.liquidator()), ""!liquidator"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        float memory price = engine.cssr().getPrice(address(asset));
        require(
            _liquidatable(details[_id].collateral, price, currentDebt(_id)),
            ""healthy""
        );

        debts -= _usdm;

        details[_id].collateral -= _collateral;
        details[_id].debt -= _usdm;

        asset.cheapTransfer(msg.sender, _collateral);
    }function triggerLiquidation(address _asset, uint256 _nftId)
        external
        override
    {
        IMochiVault vault = engine.vaultFactory().getVault(_asset);
        Auction storage auction = auctions[auctionId(_asset, _nftId)];
        require(auction.startedAt == 0 || auction.boughtAt != 0, ""on going"");
        uint256 debt = vault.currentDebt(_nftId);
        (, uint256 collateral, , , ) = vault.details(_nftId);

        vault.liquidate(_nftId, collateral, debt);

        auction.nftId = _nftId;
        auction.vault = address(vault);
        auction.startedAt = block.number;
        auction.boughtAt = 0;
        auction.collateral = collateral;
        auction.debt = debt;

        uint256 liquidationFee = debt.multiply(
            engine.mochiProfile().liquidationFee(address(_asset))
        );
        emit Triggered(auctionId(_asset, _nftId), debt + liquidationFee);
    }","Right now, there is only one discount profile in the github repo: the ""NoDiscountProfile"" which does not discount the debt at all. This specific discount profile works correctly, but I claim that any other discount profile will result in liquidation never working.

Suppose that we instead have a discount profile where `discount()` returns any value strictly larger than 0. Now, suppose someone wants to trigger a liquidation on a position. First, `triggerLiquidation` will be called (within `DutchAuctionLiquidator.sol`). The variable ""debt"" is initialized as equal to `vault.currentDebt(_nftId)`. Notice that `currentDebt(_ndfId)` (within `MochiVault.sol`) simply scales the current debt of the position using the `liveDebtIndex()` function, but there is no discounting being done within the function - this will be important.

Back within the `triggerLiquidation` function, the variable ""collateral"" is simply calculated as the total collateral of the position. Then, the function calls `vault.liquidate(_nftId, collateral, debt)`, and I claim that this will never work due to underflow. Indeed, the liquidate function will first update the debt of the position (due to the `updateDebt(_id)` modifier). The debt of the position is thus updated using lines 99-107 in `MochiVault.sol`. We can see that the `details[_id].debt` is updated in the exact same way as the calculations for `currentDebt(_nftId)`, however, there is the extra subtraction of the `discountedDebt` on line 107.

Eventually we will reach line 293 in `MochiVault.sol`. However, since we discounted the debt in the calculation of `details[_id].debt`, but we did not discount the debt for the passed in parameter _usdm (and thus is strictly larger in value), line 293 will always error due to an underflow. In summary, any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to this underflow. Since no positions will be liquidatable, this represents a major flaw in the contract as then no collateral can be liquidated so the entire functionality of the contract is compromised.

Retracing the steps as I have described above, we can see that any call to `triggerLiquidation` will result in:

```solidity
details[_id].debt -= _usdm;
```

throwing an error since _usdm will be larger than `details[_id].debt`.","The `MochiVault` has a function called `triggerLiquidation`. It calls another function of itself called `liquidate`, which transfers all the assets from the NFT to the liquidator. However, it doesn't check if there was enough balance on the NFT before calling this function. If there wasn't any balance left, then the transfer will fail. As a result, the liquidation won't be triggered anymore.

This issue can happen when an attacker buys up most of the tokens that belong to a certain NFT. Then he waits for the liquidation period to end and triggers the liquidation himself by calling `triggerLiquidation()`. He would get his funds back as long as the liquidation fee isn't too high."
"function deposit(uint256 _id, uint256 _amount)
        public
        override
        updateDebt(_id)
    {
        // should it be able to deposit if invalid?
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        require(
            details[_id].status == Status.Idle ||
                details[_id].status == Status.Collaterized ||
                details[_id].status == Status.Active,
            ""!depositable""
        );
        lastDeposit[_id] = block.timestamp;
        deposits += _amount;
        details[_id].collateral += _amount;
        if (details[_id].status == Status.Idle) {
            details[_id].status = Status.Collaterized;
        }
        asset.cheapTransferFrom(msg.sender, address(this), _amount);
    }

function withdraw(
        uint256 _id,
        uint256 _amount,
        bytes memory _data
    ) public override wait(_id) {
        require(engine.nft().ownerOf(_id) == msg.sender, ""!approved"");
        require(engine.nft().asset(_id) == address(asset), ""!asset"");
        // update prior to interaction
        float memory price = engine.cssr().update(address(asset), _data);
        require(
            !_liquidatable(
                details[_id].collateral - _amount,
                price,
                details[_id].debt
            ),
            ""!healthy""
        );
        float memory cf = engine.mochiProfile().maxCollateralFactor(
            address(asset)
        );
        uint256 maxMinted = (details[_id].collateral - _amount)
            .multiply(cf)
            .multiply(price);
        require(details[_id].debt <= maxMinted, "">cf"");
        deposits -= _amount;
        details[_id].collateral -= _amount;
        if (details[_id].collateral == 0) {
            details[_id].status = Status.Idle;
        }
        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);
    }","Every time you deposit some assets in the vault (via `deposit()` of `MochiVault.sol`) then ""lastDeposit[_id]"" is set to `block.timestamp`.
The modifier `wait()` checks this value and makes sure you cannot withdraw for ""`delay()`"" blocks.
The default value for `delay()` is 3 minutes.

Knowing this delay you can do a griefing attack:
On chains with low gas fees: every 3 minutes deposit a tiny amount for a specific NFT-id (which has a large amount of assets).
On chains with high gas fees: monitor the mempool for a `withdraw()` transaction and frontrun it with a `deposit()`

This way the owner of the NFT-id can never withdraw the funds.","The `NFTXInventory` allows users to deposit collateral into a position and then withdraw that same amount of collateral from their position. However, there's no check on whether the user has enough balance to actually perform this action or not. If they don't have enough funds, the transaction will fail with an error message indicating insufficient balance.

#### Proof of Concept

1.  Alice creates a new NFTX position using her own token as collateral. She sets up the parameters for the loan she wants to take out.
2.  Bob tries to borrow money by depositing his tokens into Alice's position. He specifies the exact number of tokens he wishes to lend.
3.  Since Alice doesn't want any extra tokens, she approves the entirety of Bob's deposited tokens to go towards paying off her debts.
4.  After some time passes, Bob decides to close his position early. He calls the `withdraw()` function specifying exactly how many tokens he would like to receive back.
5.  As you can see below, the transaction fails because Alice does not have enough tokens available to transfer over to Bob."
"function deposit(address _recipient, uint256 _amount) external override nonReentrant returns (uint256) {
    uint256 _fee = (_amount * depositFee) / FEE_DENOMINATOR;
    if (depositFee > 0) { require(_fee > 0, ""fee = 0""); }
    else { require(_amount > 0, ""amount = 0""); }
    baseToken.transferFrom(msg.sender, address(this), _amount);
    uint256 _amountAfterFee = _amount - _fee;
    if (address(depositHook) != address(0)) {
      baseToken.approve(address(depositHook), _fee);
      depositHook.hook(_recipient, _amount, _amountAfterFee);
      baseToken.approve(address(depositHook), 0);
    }
    /// Converts amount after fee from base token units to collateral token units.
    uint256 _collateralMintAmount = (_amountAfterFee * 1e18) / baseTokenDenominator;
    _mint(_recipient, _collateralMintAmount);
    emit Deposit(_recipient, _amountAfterFee, _fee);
    return _collateralMintAmount;
  }","There are some ERC20 tokens that deduct a fee on every transfer call. If these tokens are used as baseToken then:
    1.  When depositing into the Collateral contract, the recipient will receive collateral token more than what they should receive.

    2.  The DepositRecord contract will track wrong user deposit amounts and wrong globalNetDepositAmount as the added amount to both will be always more than what was actually deposited.

    3.  When withdrawing from the Collateral contract, the user will receive less baseToken amount than what they should receive.

    4.  The treasury will receive less fee and the user will receive more PPO tokens that occur in DepositHook  and WithdrawHook.

Given:
* baseToken is an ERC20 token that deduct a fee on every transfer call.
* FoT is the deducted fee on transfer.

1.  The user deposits baseToken to the Collateral contract by calling deposit function passing _amount as 100e18.
2.  baseToken.transferFrom is called to transfer the amount from the user to the contract.
3.  The contract receives the _amount - FoT. Let's assume the FoT percentage is 1%. Therefore, the actual amount received is 99e18.
4.  When the DepositHook is called. the _amount passed is 100e18 which is wrong as it should be the actual amount 99e18.
5.  Calculating collateralMintAmount is based on the _amount (100e18- the fee for treasury) which will give the recipient additional collateral token that they shouldn't receive.","The `deposit` function of `Collateral` allows a user to mint new tokens by transferring their underlying asset into it. However, there's no check that the `_recipient` isn't equal to zero or the contract itself. If this happens then the funds will be lost as they can never be withdrawn again. Also, the hook could fail which would also lead to losing all the funds."
"function withdrawRedundant(address _token, address _to)
        external
        override
        onlyOwner
    {
        if (
            _token == address(token) &&
            balance < IERC20(token).balanceOf(address(this))
        ) {
            uint256 _redundant = IERC20(token).balanceOf(address(this)) -
                balance;
            IERC20(token).safeTransfer(_to, _redundant);
        } else if (IERC20(_token).balanceOf(address(this)) > 0) {
            IERC20(_token).safeTransfer(
                _to,
                IERC20(_token).balanceOf(address(this))
            );
        }
    }","The `Vault.withdrawRedundant` has wrong logic that allows the admins to steal the underlying vault token.

POC

*   Vault deposits increase as `Vault.addValue` is called and the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. Note that `balance == IERC20(token).balanceOf(this)`
*   Admins call `vault.withdrawRedundant(vault.token(), attacker)` which goes into the `else if` branch due to the balance inequality condition being `false`. It will transfer out all `vault.token()` amounts to the attacker.

Impact

There's a backdoor in the `withdrawRedundant` that allows admins to steal all user deposits.","The `withdrawRedundant` function of `ConvexStakingWrapper` allows an owner to retrieve any excess tokens that may be present on the contract. However, it does not check for a token's allowance before attempting to transfer them out. If there isn't enough allowance set up by default or through previous calls to `deposit`, then this will fail with revert errors. Additionally, since the `_token` parameter can be chosen arbitrarily, an attacker could front-run this call and steal funds from the protocol."
"function initialize(
        address[] calldata initialAccounts,
        uint96[] calldata initialGrantAmount,
        address owner_
    ) public initializer {
        require(initialGrantAmount.length == initialAccounts.length);

        uint96 totalGrants = 0;
        for (uint256 i = 0; i < initialGrantAmount.length; i++) {
            totalGrants = _add96(totalGrants, initialGrantAmount[i], """");
            require(balances[initialAccounts[i]] == 0, ""Duplicate account"");
            balances[initialAccounts[i]] = initialGrantAmount[i];

            emit Transfer(address(0), initialAccounts[i], initialGrantAmount[i]);
        }

        require(totalGrants == totalSupply);
        owner = owner_;
    }","All these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract.

However, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the `onlyOwner` role in the implementation contract for `NoteERC20.sol`. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all `NoteERC20.sol` interactions until a new implementation contract is deployed.

Consider the following scenario:
- Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is `NoteERC20.sol`.
- This allows any arbitrary user to call `initialize()` on the `NoteERC20.sol` implementation contract.
- Once a user has gained control over `NoteERC20.sol`'s implementation contract, they can bypass the `_authorizeUpgrade` check used to restrict upgrades to the `onlyOwner` role.
- The malicious user then calls `UUPSUpgradeable.upgradeToAndCall()` which in turn calls a function that points the new implementation contract to their own contract containing a self-destruct call in its fallback function.
- As a result, the implementation contract will be self-destructed due to the user-controlled delegate call, preventing all future calls to the `NoteERC20.sol` proxy contract until a new implementation contract has been deployed.","The `initialize` function of `GovernanceToken` allows an arbitrary number of accounts with grants. However, it does not check that these accounts do not already exist as a grant on another token. If they do, then this will lead to duplicate grants being created which can be used by malicious actors to steal funds from other tokens.

Proof of Concept

1.  Alice deploys a new instance of GovernanceToken.
2.  Bob calls `initialize()` with his own address and a large amount of governance tokens.
3.  Charlie calls `initialize()` with Bob's address and a small amount of governance tokens.
4.  Now both Bob and Charlie have access to the same set of governance tokens."
"function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            // will underflow if amount < previousAmount
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
        Loan storage loan = loanInfo[loanId];

        uint256 interest = _interestOwed(
            loan.loanAmount,
            loan.lastAccumulatedTimestamp,
            loan.perAnumInterestRate,
            loan.accumulatedInterest
        );
        address lender = IERC721(lendTicketContract).ownerOf(loanId);
        loan.closed = true;
        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
        IERC721(loan.collateralContractAddress).safeTransferFrom(
            address(this),
            IERC721(borrowTicketContract).ownerOf(loanId),
            loan.collateralTokenId
        );

        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
        emit Close(loanId);
    }","If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.

Proof of Concept

This exploit requires that the loanAssetContractAddress token transfers control to the receiver.

Steps of exploit:

*   Borrower creates loan with createLoan().
*   The same Borrower calls lend(), funding their own loan. The Borrower receives the lend ticket, and funds are transferred to themself.
*   A new lender attempts to buy out the loan. The original loan amount + accruedInterest are sent to the original lender (same person as borrower).
*   Due to lack of checks-effects-interactions pattern, the borrower is able to immediately call repayAndCloseLoan() before the lend ticket is transferred to the new lender.

The following code illustrates that the new lender sends funds to the original lender prior to receiving the lend ticket in return.

} else {
    ERC20(loan.loanAssetContractAddress).safeTransferFrom(
        msg.sender,
        currentLoanOwner,
        accumulatedInterest + previousLoanAmount
    );
}
ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);

The original lender/borrower calls the following repayAndCloseLoan() function so that they receive their collateral NFT from the protocol.

function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {
    Loan storage loan = loanInfo[loanId];

    uint256 interest = _interestOwed(
        loan.loanAmount,
        loan.lastAccumulatedTimestamp,
        loan.perAnumInterestRate,
        loan.accumulatedInterest
    );
    address lender = IERC721(lendTicketContract).ownerOf(loanId);
    loan.closed = true;
    ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);
    IERC721(loan.collateralContractAddress).safeTransferFrom(
        address(this),
        IERC721(borrowTicketContract).ownerOf(loanId),
        loan.collateralTokenId
    );

    emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);
    emit Close(loanId);
}

Finally, the new lender receives the lend ticket that has no utility at this point. The borrower now possesses the NFT, original loan amount, and accrued interest.","The `lend` function of NFTLoanFacet allows a borrower to buy out an existing lending position by paying more for it. However, this can lead to a situation where the new buyer has to pay back all the accrued interest as well which could be quite expensive especially when there's a lot of accrued interest.

As a result, borrowers may choose to wait until they have enough funds before attempting to buy out the lending position or they might decide against doing so altogether. As a result, the protocol would lose out on revenue from these positions that could otherwise be bought out at a lower price.

This issue affects the entire system because it means that users who want to buy out their loans but don't have enough funds to cover the full cost of the loan with interest may never be able to do so. It also makes the protocol less attractive to use since it loses out on potential revenue due to this limitation."
"function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }","Consider the following scenario:
Day 0: User A stakes 200 tokens and calls the cooldown function. At this time, user A's cooldown is Day 0.
Day 15: User B stakes 100 tokens, but then wants to unstake tokens. So user A said that he could assist user B in unstaking tokens, and this could be done by deploying a smart contract.
In the smart contract deployed by user A, user B first needs to transfer 100 tokens to user A. In the _getNewReceiverCooldown function, _senderCooldown is Day 15 and receiverCooldown is Day 0, so the latest cooldown of user A is (100 * Day 15 + 200 * Day 0)/(100+200) = Day 5.

Since User A is still at UNSTAKE_PERIOD after receiving the tokens, User A unstakes 100 tokens and sends it to User B.

After calculation, we found that when user A has a balance of X and is at the edge of UNSTAKE_PERIOD, user A can assist in unstaking the X/2 amount of tokens just staked.","The `Staking._getNewReceiverCooldown` function calculates the new cooldown for a staker by taking into account their current cooldown (`cooldowns[receiver]`), as well as the cooldown of the stake being added (`senderCooldown`). It then uses this information to calculate a ""weighted"" cooldown that takes both amounts into consideration. However, there's an edge-case where the resultant cooldown can be less than the minimum valid cooldown due to rounding errors. As a result, the `_isEligibleToUnstake` modifier will always allow users who have recently received funds from unstaking even though they may not yet meet the required time threshold."
"function mint(address _recipient) external override {
        address feePool = IIndexRegistry(registry).feePool();
        _chargeAUMFee(feePool);

        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());

        uint lastAssetBalanceInBase;
        uint minAmountInBase = type(uint).max;
        for (uint i; i < assets.length(); ++i) {
            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), ""Index: INVALID_ASSET"");
            if (weightOf[assets.at(i)] == 0) {
                continue;
            }
            uint assetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            // Q_b * w_i * p_i = Q_i
            // Q_b = Q_i / (w_i * p_i)
            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)));
            uint amountInAsset = IERC20(assets.at(i)).balanceOf(address(vToken)) - vToken.lastBalance();
            uint weightedPrice = assetPerBaseInUQ * weightOf[assets.at(i)];
            uint _minAmountInBase = amountInAsset.mulDiv(FixedPoint112.Q112 * IndexLibrary.MAX_WEIGHT, weightedPrice);
            if (_minAmountInBase < minAmountInBase) {
                minAmountInBase = _minAmountInBase;
            }
            uint lastBalanceInAsset = vToken.lastAssetBalanceOf(address(this));
            vToken.mint();
            uint balanceInBase = lastBalanceInAsset.mulDiv(FixedPoint112.Q112, assetPerBaseInUQ);
            lastAssetBalanceInBase += balanceInBase;
        }

        for (uint i; i < inactiveAssets.length(); ++i) {
            if (!IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, inactiveAssets.at(i))) {
                uint lastBalanceInAsset = IvToken(
                    IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(inactiveAssets.at(i))
                ).lastAssetBalanceOf(address(this));
                lastAssetBalanceInBase += lastBalanceInAsset.mulDiv(
                    FixedPoint112.Q112,
                    oracle.refreshedAssetPerBaseInUQ(inactiveAssets.at(i))
                );
            }
        }

        assert(minAmountInBase != type(uint).max);

        uint value;
        if (totalSupply() != 0) {
            require(lastAssetBalanceInBase > 0, ""Index: INSUFFICIENT_AMOUNT"");
            value =
                (oracle.convertToIndex(minAmountInBase, decimals()) * totalSupply()) /
                oracle.convertToIndex(lastAssetBalanceInBase, decimals());
        } else {
            value = oracle.convertToIndex(minAmountInBase, decimals()) - IndexLibrary.INITIAL_QUANTITY;
            _mint(address(0xdead), IndexLibrary.INITIAL_QUANTITY);
        }

        uint fee = (value * IFeePool(feePool).mintingFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;
        if (fee > 0) {
            _mint(feePool, fee);
            value -= fee;
        }

        _mint(_recipient, value);
    }","In the mint function of the IndexLogic contract, users are required to transfer assets to vToken in advance, and then call the mint function to mint tokens. The attacker can monitor the asset balance in the vToken contract. When the balance is greater than lastBalance, the attacker can call the mint function to mint tokens for himself.

This a core logic error that could be used to take funds away from clients and given there is no mention of the router and only part of the code is submitted, I am siding with the wardens on this and awarding in full.","The `mint` function of `Index` does not update the `lastAssetBalances`. As a result, it will always revert when calling this function because there's no enough base tokens available.

Proof of Concept

*   Call `setWeight()` with an arbitrary token as the argument.
*   Call `mint()`. It should fail due to insufficient funds. However, since the `lastAssetBalances` have never been updated, they remain at their default values of zero. Therefore, the next time you call `mint()`, it will still try to use these zero balances instead of updating them first."
"function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {
        require(_tokens.length == _weights.length);
        uint256 length = _tokens.length;
        address[] memory tokenList = new address[](length);

        // check uniqueness of tokens and not token(0)

        for (uint i = 0; i < length; i++) {
            require(_tokens[i] != address(0));
            require(_weights[i] > 0);

            for (uint256 x = 0; x < tokenList.length; x++) {
                require(_tokens[i] != tokenList[x]);
            }

            tokenList[i] = _tokens[i];
        }
    }

function mint(uint256 amount) public override {
        mintTo(amount, msg.sender);
    }

function mintTo(uint256 amount, address to) public override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);

        handleFees();

        pullUnderlying(amount, msg.sender);

        _mint(to, amount);

        emit Minted(to, amount);
    }

function burn(uint256 amount) public override {
        require(auction.auctionOngoing() == false);
        require(amount > 0);
        require(balanceOf(msg.sender) >= amount);

        handleFees();

        pushUnderlying(amount, msg.sender);
        _burn(msg.sender, amount);
        
        emit Burned(msg.sender, amount);
    }

function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {
        validateWeights(_tokens, _weights);

        if (pendingWeights.pending) {
            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);
            if (auction.auctionOngoing() == false) {
                auction.startAuction();

                emit PublishedNewIndex(publisher);
            } else if (auction.hasBonded()) {

            } else {
                auction.killAuction();

                pendingWeights.tokens = _tokens;
                pendingWeights.weights = _weights;
                pendingWeights.block = block.number;
            }
        } else {
            pendingWeights.pending = true;
            pendingWeights.tokens = _tokens;
            pendingWeights.weights = _weights;
            pendingWeights.block = block.number;
        }
    }

function pullUnderlying(uint256 amount, address from) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);
        }
    }function proposeBasketLicense(
        uint256 licenseFee, 
        string memory tokenName, 
        string memory tokenSymbol, 
        address[] memory tokens,
        uint256[] memory weights
    ) public override returns (uint256 id) {
        basketImpl.validateWeights(tokens, weights);

        require(licenseFee >= minLicenseFee);

        // create proposal object
        Proposal memory proposal = Proposal({
            licenseFee: licenseFee,
            tokenName: tokenName,
            tokenSymbol: tokenSymbol,
            proposer: address(msg.sender),
            tokens: tokens,
            weights: weights,
            basket: address(0)
        });

        emit BasketLicenseProposed(msg.sender, tokenName);
        _proposals.push(proposal);

        return _proposals.length - 1;
    }

function createBasket(uint256 idNumber) external override returns (IBasket) {
        Proposal memory bProposal = _proposals[idNumber];
        require(bProposal.basket == address(0));

        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));
        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));

        newAuction.initialize(address(newBasket), address(this));
        newBasket.initialize(bProposal, newAuction);

        for (uint256 i = 0; i < bProposal.weights.length; i++) {
            IERC20 token = IERC20(bProposal.tokens[i]);
            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);
            token.safeApprove(address(newBasket), bProposal.weights[i]);
        }

        newBasket.mintTo(BASE, msg.sender);

        _proposals[idNumber].basket = address(newBasket);

        emit BasketCreated(address(newBasket));

        return newBasket;
    }","It was observed that Publisher is allowed to create a basket with zero token and weight. This can lead to user fund stealing as described in below poc
The issue was discovered in `validateWeights` function of Basket contract

Proof of Concept

1.  User proposes a new Basket with 0 tokens and weights using `proposeBasketLicense` function in Factory contract

Proposal memory proposal = Proposal({
        licenseFee: 10,
        tokenName: abc,
        tokenSymbol: aa,
        proposer: 0xabc,
        tokens: {},
        weights: {},
        basket: address(0)
});

2.  `validateWeights` function is called and it returns success as the only check performed is `_tokens.length == _weights.length (0=0)`

function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {
    require(_tokens.length == _weights.length);
    uint256 length = _tokens.length;
    address[] memory tokenList = new address[](length);

    // check uniqueness of tokens and not token(0)

    for (uint i = 0; i < length; i++) {
        ...
    }
}

3.  A new proposal gets created
   _proposals.push(proposal);

4.  User creates new Basket with this proposal using `createBasket` function

function createBasket(uint256 idNumber) external override returns (IBasket) {
    Proposal memory bProposal = _proposals[idNumber];
    require(bProposal.basket == address(0));

    ....

    for (uint256 i = 0; i < bProposal.weights.length; i++) {
        ...
    }
    ...
    return newBasket;
}

5.  Since no weights and tokens were in this proposal so no token transfer is required (`bProposal.weights.length` will be 0 so loop won't run)

6.  Basket gets created and user becomes publisher for this basket

newBasket.mintTo(BASE, msg.sender);
_proposals[idNumber].basket = address(newBasket);

7.  Publisher owned address calls the mint function with say amount 10 on `Basket.sol` contract

function mint(uint256 amount) public override {
    mintTo(amount, msg.sender);
}

function mintTo(uint256 amount, address to) public override {
    ...

    pullUnderlying(amount, msg.sender);

    _mint(to, amount);

    ...
}

8.  Since there is no weights so `pullUnderlying` function does nothing (weights.length is 0)

function pullUnderlying(uint256 amount, address from) private {
    for (uint256 i = 0; i < weights.length; i++) {
        uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
        IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);
    }
}

9.  Full amount 10 is minted to Publisher owned address setting `balanceOf(msg.sender) = 10`

_mint(to, amount);

10. Now Publisher calls the `publishNewIndex` to set new weights. Since `pendingWeights.pending` is false, else condition gets executed

function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {
    validateWeights(_tokens, _weights);

    if (pendingWeights.pending) {
        require(block.number >= pendingWeights.block + TIMELOCK_DURATION);
        if (auction.auctionOngoing() == false) {
            auction.startAuction();

            emit PublishedNewIndex(publisher);
        } else if (auction.hasBonded()) {

        } else {
            auction.killAuction();

            pendingWeights.tokens = _tokens;
            pendingWeights.weights = _weights;
            pendingWeights.block = block.number;
        }
    } else {
        pendingWeights.pending = true;
        pendingWeights.tokens = _tokens;
        pendingWeights.weights = _weights;
        pendingWeights.block = block.number;
    }
}

11. Publisher calls the `publishNewIndex` again which starts the Auction. This auction is later settled using the `settleAuction` function in Auction contract

12. Publisher owned address can now call burn and get the amount 10 even though he never made the payment since his `balanceOf(msg.sender) = 10` (Step 9)

function burn(uint256 amount) public override {
    require(auction.auctionOngoing() == false);
    require(amount > 0);
    require(balanceOf(msg.sender) >= amount);

    handleFees();

    pushUnderlying(amount, msg.sender);
    _burn(msg.sender, amount);
    
    emit Burned(msg.sender, amount);
}","The `validateWeights` functions do not prevent duplicate tokens or zero-weight tokens. These conditions can lead to an error when calling these functions later on. For example, this will happen with the `publishNewIndex`, `createBasket`, and `pullUnderlying`/`pushUnderlying` functions. As a result, users cannot use the protocol as intended."
"function shareKey(
    address _to,
    uint _tokenId,
    uint _timeShared
  ) public
    onlyIfAlive
    onlyKeyManagerOrApproved(_tokenId)
  {
    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');
    require(_to != address(0), 'INVALID_ADDRESS');
    address keyOwner = _ownerOf[_tokenId];
    require(getHasValidKey(keyOwner), 'KEY_NOT_VALID');
    Key storage fromKey = keyByOwner[keyOwner];
    Key storage toKey = keyByOwner[_to];
    uint idTo = toKey.tokenId;
    uint time;
    // get the remaining time for the origin key
    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;
    // get the transfer fee based on amount of time wanted share
    uint fee = getTransferFee(keyOwner, _timeShared);
    uint timePlusFee = _timeShared + fee;

    // ensure that we don't try to share too much
    if(timePlusFee < timeRemaining) {
      // now we can safely set the time
      time = _timeShared;
      // deduct time from parent key, including transfer fee
      _timeMachine(_tokenId, timePlusFee, false);
    } else {
      // we have to recalculate the fee here
      fee = getTransferFee(keyOwner, timeRemaining);
      time = timeRemaining - fee;
      fromKey.expirationTimestamp = block.timestamp; // Effectively expiring the key
      emit ExpireKey(_tokenId);
    }

    if (idTo == 0) {
      _assignNewTokenId(toKey);
      idTo = toKey.tokenId;
      _recordOwner(_to, idTo);
      emit Transfer(
        address(0), // This is a creation or time-sharing
        _to,
        idTo
      );
    } else if (toKey.expirationTimestamp <= block.timestamp) {
      // reset the key Manager for expired keys
      _setKeyManagerOf(idTo, address(0));
    }

    // add time to new key
    _timeMachine(idTo, time, true);
    // trigger event
    emit Transfer(
      keyOwner,
      _to,
      idTo
    );

    require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');
  }function _assignNewTokenId(
    Key storage _key
  ) internal
  {
    if (_key.tokenId == 0) {
      // This is a brand new owner
      // We increment the tokenId counter
      _totalSupply++;
      // we assign the incremented `_totalSupply` as the tokenId for the new key
      _key.tokenId = _totalSupply;
    }
  }","More keys can be minted than maxNumberOfKeys since `shareKey` and `grantKey` do not check if the lock is sold out.

In both `shareKey` and `grantKey`, if minting a new token, a new token is simply minted (and `_totalSupply` increased) without checking it against `maxNumberOfKeys`.
This is unlike `purchase`, which has the `notSoldOut` modifier.

Both functions call `_assignNewTokenId` which does not check maxNumberOfKeys.
So you can say that `_assignNewTokenId` is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).","The `shareKey()` function allows users to create a new key by specifying an empty address (`address(0)`). However, this will lead to a revert when trying to record ownership with the zero address. See issue page for proof of concept."
"function _swapcvxCRVToWant() internal {
        uint256 toSwap = IERC20Upgradeable(reward).balanceOf(address(this));

        if (toSwap == 0) {
            return;
        }

        // Sushi reward to WETH to want
        address[] memory path = new address[](3);
        path[0] = reward;
        path[1] = WETH;
        path[2] = CVX;
        IUniswapRouterV2(SUSHI_ROUTER).swapExactTokensForTokens(
            toSwap,
            0,
            path,
            address(this),
            now
        );

        // Deposit into vault
        uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));
        if (toDeposit > 0) {
            CVX_VAULT.deposit(toDeposit);
        }
    }","The contracts are missing slippage checks which can lead to being vulnerable to sandwich attacks.

A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone’s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker’s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.

See veCVXStrategy._swapcvxCRVToWant:

IUniswapRouterV2(SUSHI_ROUTER).swapExactTokensForTokens(
    toSwap,
    0, // @audit min. return of zero, no slippage check
    path,
    address(this),
    now
);

Impact
Trades can happen at a bad price and lead to receiving fewer tokens than at a fair market price. The attacker's profit is the protocol's loss.","The `ConvexStakingWrapper._swapcvxCRVToWant` function swaps CRV for cvxCRV using a Uniswap router but does not check that there's enough liquidity available on the pool or that it will be able to swap all of the tokens at the best rate possible. If there isn't any liquidity then no tokens can be swapped out which would break functionality. Additionally, this could lead to users losing funds as they may receive fewer tokens than expected due to slippage issues."
"function safeName(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(
            abi.encodeWithSelector(IERC20Metadata.name.selector)
        );
        if (success) return abi.decode(data, (string));
        return 'Token';
    }function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(abi.encodePacked('Timeswap Bond - ', assetName, ' - ', collateralName, ' - ', maturity.toString()));
    }function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked('Timeswap Liquidity - ', assetName, ' - ', collateralName, ' - ', maturity.toString())
            );
    }function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked(
                    'Timeswap Collateralized Debt - ',
                    assetName,
                    ' - ',
                    collateralName,
                    ' - ',
                    maturity.toString()
                )
            );
    }function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked('Timeswap Insurance - ', assetName, ' - ', collateralName, ' - ', maturity.toString())
            );
    }","The `safeName()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `name()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `name()` function should return a string and not revert.

The root cause of the issue is that the `safeName()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `name()` functions in the Timeswap ERC20 contracts to revert. There are some tokens that aren't compliant, such as Sai from Maker, which returns a bytes32 value.

Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeName()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeName()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name.

Proof of Concept

The root cause is line 12 of the `safeName()` function in SafeMetadata.sol

The `safeName()` function is called in:

* Bond.sol
* CollateralizedDebt.sol
* Insurance.sol
* Liquidity.sol","The `Utils` library contains a number of functions that attempt to retrieve ERC-20 tokens' names using static calls. However, these functions do not check whether the call was successful or not before attempting to decode the returned value as an ERC-20 token name. As such, any time a malformed input is provided for one of these functions, it will revert with no error message indicating what went wrong.

This issue affects all of the following functions:
*   Utils.safeName
*   TimeswapBond.name
*   TimeswapLiquidity.name
*   TimeswapCollateralizedDebt.name
*   TimeswapInsurance.name"
"function claim() external {
    auctionPool.claim();
    rewardOverflow.claim();
  }function purchaseArbitrageTokens(uint256 maxAmount)
    external
    onlyRole(IMPLIED_COLLATERAL_SERVICE_ROLE, ""Must have implied collateral service privs"")
    returns (uint256 remaining)
  {
    uint256 balance = usableBalance();

    if (maxAmount < balance) {
      balance = maxAmount;
    }

    uint256 currentAuction = auction.currentAuctionId();
    
    if (!auction.auctionActive(currentAuction)) {
      return maxAmount;
    }

    auctionIds.push(currentAuction);

    auctionRewardToken.approve(address(auction), balance);
    auction.purchaseArbitrageTokens(balance);
    
    return maxAmount - balance;
  }

function claim() external {
    if (auctionIds.length == 0 || replenishingIndex >= auctionIds.length) {
      return;
    }

    uint256 auctionId = auctionIds[replenishingIndex];
    uint256 replenishingId = auction.replenishingAuctionId();

    if (auctionId > replenishingId) {
      // Not yet replenishing this auction
      return;
    }
    uint256 claimableTokens = auction.userClaimableArbTokens(address(this), auctionId);

    if (claimableTokens == 0) {
      // Nothing to claim yet
      return;
    }

    uint256 balance = auctionRewardToken.balanceOf(address(this));

    auction.claimArbitrage(auctionId);

    uint256 finalBalance = auctionRewardToken.balanceOf(address(this));
    uint256 rewardedAmount = finalBalance - balance;

    claimableRewards = claimableRewards.add(rewardedAmount);

    uint256 claimable = auction.userClaimableArbTokens(address(this), auctionId);

    if (replenishingId > auctionId && claimable == 0) {
      // Don't increment replenishingIndex if replenishingAuctionId == auctionId as
      // claimable could be 0 due to the debt not being 100% replenished.
      replenishingIndex = replenishingIndex + 1;
    }

    _handleRewardDistribution(rewardedAmount);
  }","In AuctionParticpant.sol, every time `purchaseArbitrageTokens` is called, the current auction is pushed to `auctionIds`. If this function were to be called on the same auction multiple times, then the same auction id would be pushed multiple times into this array, and the `claim` function would have issues with `replenishingIndex`.

Specifically, even if `replenishingIndex` was incremented once in `claim`, it is still possible that the auction at the next index will never reward any more tokens to the participant, so the contract would need manual intervention to set `replenishingIndex` (due to the if statement on lines 79-82 that does nothing if there is no claimable yield).

It is likely that `purchaseArbitrageTokens` would be called multiple times on the same auction. In fact, the commented out code for `handleDeficit` (in ImpliedCollateralService.sol) even suggests that the purchases might happen within the same transaction. So this issue will likely be an issue on most auctions and would require manual setting of `replenishingIndex`.

NOTE: This is a separate issue from the one I just submitted previously relating to `replenishingIndex`. The previous issue was related to an edge case where `replenishingIndex` might need to be incremented by one if there are never going to be more claims, while this issue is due to duplicate auction ids.","The `ImpliedCollateralService` has a method called `purchaseArbitrageTokens`. It calls out to an arbitrager which then purchases tokens for it. However, these tokens can be claimed by calling the `claim()` function of the ImpliedCollateralService. If you call `purchaseArbitrageTokens`, but don’t immediately call `claim()`, your tokens will remain locked up until they are claimed. You may lose some of those tokens over time because the arbitrager may choose to withdraw them from the system at any point before they are claimed.

This issue was discovered when testing the protocol with a large number of users who were using the `purchaseArbitrageTokens` functionality. We found that many users had lost their tokens over time without realizing it. As a result, we decided to make the impact more visible so that users would know about this risk."
"function _join(address user, uint128 amount)
        internal
        returns (uint128)
    {
        IERC20 token = IERC20(asset);
        uint256 _storedBalance = storedBalance;
        uint256 available = token.balanceOf(address(this)) - _storedBalance; // Fine to panic if this underflows
        storedBalance = _storedBalance + amount;
        unchecked { if (available < amount) token.safeTransferFrom(user, address(this), amount - available); }
        return amount;        
    }","Yield whitelists a rebasing/deflationary/inflationary token to be used as collateral or underlying by accident. This leads to miscalculations between internal `Cauldron` accounting and the balances in the token contracts.

Yield protocol allows different tokens to be used as collateral or underlying. The `Join` and `Pool` contracts do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the number of tokens transferred to contracts before and after the actual transfer to infer any fees/interest. These seem to be absent as seen in the `_join()` call of `Join.sol` or in Pool contracts. The impact will be miscalculations between internal `Cauldron` accounting and the balances in the token contracts.

Yield currently manages this by approving only certain tokens to be used as collateral or underlying. Therefore, this is not an issue now as long as the tokens are determined to not be of the concerned kinds. However, this will become an issue if user-supplied tokens are accepted without the existing vetting.","The `HybridPool._join` function does not check that there's enough balance of the pool asset on the contract before transferring from a user. If the contract has less than the required amount of assets then it will revert due to insufficient funds. However, since the `_storedBalance` variable tracks how much was transferred out of the contract already, users can be locked out of their shares until more tokens are added to the contract."
"function updateTpSl(
        bool _type,
        uint _id,
        uint _limitPrice,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        IPosition.Trade memory _trade = position.trades(_id);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        if (_type) {
            position.modifyTp(_id, _limitPrice);
        } else {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, 0);
            _checkSl(_limitPrice, _trade.direction, _price);
            position.modifySl(_id, _limitPrice);
        }
        emit UpdateTPSL(_id, _type, _limitPrice, _trader);
    }

function limitClose(
        uint _id,
        bool _tp,
        PriceData calldata _priceData,
        bytes calldata _signature
    )
        external
    {
        _checkDelay(_id, false);
        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);
        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);
    }","Bot fees are used when a position is opened/closed via a bot. In that case a bot fee is subtracted from the DAO fee and sent to the closing bot.
A user can use that to reduce the DAO fees for closing an order and keeping it to themselves.

Instead of closing the order via `initiateClose()`, the user can use a proxy contract to update the stop-loss value and then `limitClose()` the order.
Since that is done in one function call, no bot can run the `limitClose()` and the bot fee will go to the user.

The provided proof of concept shows how a trade is closed by a proxy contract that sets the limit and closes it via `limitClose()`. The proxy contract `MyTrader.sol` calls `updateTpSl()` and then `limitClose()` in the same transaction, bypassing the intended bot fee mechanism.

This allows a user to avoid paying the bot fee that would normally be deducted and sent to the closing bot, effectively reducing the DAO fees and keeping the bot fee for themselves.","The `updateTpSl` function of `TradingAction` allows a user to set their TP or SL price for an open trade. However, this can be done by anyone who knows the `_id`, not just the owner of that trade. As such, it's possible for someone to front-run another trader and take advantage of them. For example, they could use the same `_id` as the other trader but with a different asset pair (`_trade.asset`) which would allow them to close out the trade at any time before the expiry timestamp. They could then reopen the trade again after the expiry timestamp has passed using the original asset pair.

This issue only affects users who have already opened a trade on the platform. It does not impact new trades being created since there will always be a delay between when a trade is first opened and closed."
"function recoverToken(
        IERC20 _token,
        uint256 _amount,
        address _to
    )
        external
        notHalted
        onlyStrategist
    {
        _token.safeTransfer(_to, _amount);
    }","The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.

The `Manager.recoverToken` function does not check the return value of this function.

#### Impact
Tokens that don't actually perform the transfer and return `false` are still counted as a correct transfer.
Furthermore, tokens that do not correctly implement the EIP20 standard, like USDT which does not return a success boolean, will revert.","The `recoverToken` function of `Controller` allows a strategist to transfer any token from the controller's balance. However, there is no access control on who can call this function or what tokens they can specify as `_token`. As such, an attacker could front-run this transaction by first calling `setStrategist`, then calling `recoverToken` with their desired parameters (e.g., `_token = USDC`). They would be able to steal all funds that were meant for the new strategist."
"function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {
		(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));
		bytes32 accHash = keccak256(abi.encode(QuickAccount({
			timelock: timelock,
			one: SignatureValidator.recoverAddr(hash, sig1),
			two: SignatureValidator.recoverAddr(hash, sig2)
		})));
		if (Identity(id).privileges(address(this)) == accHash) {
			// bytes4(keccak256(""isValidSignature(bytes32,bytes)"")
			return 0x1626ba7e;
		} else {
			return 0xffffffff;
		}
	}","Several different signature modes can be used and `Identity.execute` forwards the `signature` parameter to the `SignatureValidator` library. The returned `signer` is then used for the `privileges` check:

address signer = SignatureValidator.recoverAddrImpl(hash, signature, true);
// signer will be QuickAccountContract
require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');

It's possible to create a smart contract mode signature (`SignatureMode.SmartWallet`) for arbitrary transactions as the `QuickAccManager.isValidSignature` uses an attacker-controlled `id` identity contract for the privileges check. An attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:

// @audit id is attacker-controlled
(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));
// @audit this may not be used for authorization, attacker can return desired value
if (Identity(id).privileges(address(this)) == accHash) {
  // bytes4(keccak256(""isValidSignature(bytes32,bytes)"")
  return 0x1626ba7e;
} else {
  return 0xffffffff;
}

POC
Assume an `Identity` contract is set up with a `QuickAccManager` as the `privileges` account, i.e. `privileges[accHash] != 0`.

We can construct a `SignatureMode.SmartWallet` signature for an *arbitrary* hash:

1.  Call `Identity.execute(txns, spoofedSignature)` where `spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)`
2.  This will call `recoverAddrImpl(txnsHash, spoofedSignature, true)`, decode the bytes **at the end** of `spoofedSignature` and determine `mode = SignatureMode.SmartWallet` and `wallet = quickAccountManager`. It will cut off these arguments and call `quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))`
3.  The `QuickAccManager` will decode the signature, construct `accHash` which is the hash of all zeroes (due to failed signatures returning 0). It will then call `attacker.privileges(address(this))` and the attacker contract can return the `accHash` that matches an account hash of failed signatures, i.e., `keccak256(abi.encode(QuickAccount(0,0,0)))`. The comparison is satisfied and it returns the success value.
4.  The checks in `Identity.execute` pass and the transactions `txns` are executed.

Impact
Any `Identity` contract using `QuickAccManager` can be exploited. Funds can then be stolen from the wallet.","The `isValidSignature` function of `MultiSigWallet` does not check if the signatures used for recovery actually correspond to the provided account address (`id`). An attacker can provide a malicious signature that will be accepted by this function as valid even though it doesn't belong to the actual user who controls the private key corresponding to the `id`. As a result, an attacker could drain funds from the Multi-sig wallets or grant access to them without permission.

Proof of Concept

An attacker can create two accounts with different public keys but same private keys. Then he creates a multi-sig wallet using these two accounts. He then signs transactions on behalf of the first account which has no knowledge about the transaction being signed. Finally, he submits the transaction to the blockchain and gets rewards for his work.

This issue affects all functions that use the `isValidSignature` function such as `executeTransaction`, `cancelTransaction`, etc."
"function _computeSingleOutGivenPoolIn(
        uint256 tokenOutBalance,
        uint256 tokenOutWeight,
        uint256 _totalSupply,
        uint256 _totalWeight,
        uint256 toBurn,
        uint256 _swapFee
    ) internal pure returns (uint256 amountOut) {
        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);
        uint256 newPoolSupply = _totalSupply - toBurn;
        uint256 poolRatio = _div(newPoolSupply, _totalSupply);
        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));
        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);
        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;
        uint256 zaz = (BASE - normalizedWeight) * _swapFee;
        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));
    }","The `_computeSingleOutGivenPoolIn` function of `IndexPool` uses the raw multiplication (i.e., `*`) to calculate the `zaz` variable. However, since both `(BASE - normalizedWeight)` and `_swapFee` are in `WAD`, the `_mul` function should be used instead to calculate the correct value of `zaz`. Otherwise, `zaz` would be `10 ** 18` times larger than the expected value and causes an integer underflow when calculating `amountOut`. The incorrect usage of multiplication prevents anyone from calling the function successfully.","The `HybridPool._computeSingleOutGivenPoolIn` computes a value that will be used as an input for another call of this same function. However, it does not check if the result would lead to any overflows or underflows. If one of these happens, then the final output could end up being wrong which might break important functionality.

Proof of Concept

```solidity
function compute() public view returns (bool) {
    return HybridPool._computeSingleOutGivenPoolIn(_balances[0], weights[0], totalSupply(), totalWeights(), amounts[1], swapFees()) > _balances[1]; // @audit-info only checking first pair here
}
```"
"function mint(bytes calldata data) public override lock returns (uint256 _liquidity) {
        MintParams memory mintParams = abi.decode(data, (MintParams));

        uint256 priceLower = uint256(TickMath.getSqrtRatioAtTick(mintParams.lower));
        uint256 priceUpper = uint256(TickMath.getSqrtRatioAtTick(mintParams.upper));
        uint256 currentPrice = uint256(price);

        _liquidity = DyDxMath.getLiquidityForAmounts(
            priceLower,
            priceUpper,
            currentPrice,
            mintParams.amount1Desired,
            mintParams.amount0Desired
        );

        {
            require(_liquidity <= MAX_TICK_LIQUIDITY, ""LIQUIDITY_OVERFLOW"");

            (uint256 amount0fees, uint256 amount1fees) = _updatePosition(
                mintParams.positionOwner,
                mintParams.lower,
                mintParams.upper,
                int128(uint128(_liquidity))
            );
            if (amount0fees > 0) {
                _transfer(token0, amount0fees, mintParams.positionOwner, false);
                reserve0 -= uint128(amount0fees);
            }
            if (amount1fees > 0) {
                _transfer(token1, amount1fees, mintParams.positionOwner, false);
                reserve1 -= uint128(amount1fees);
            }
        }

        unchecked {
            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity += uint128(_liquidity);
        }

        _ensureTickSpacing(mintParams.lower, mintParams.upper);
        nearestTick = Ticks.insert(
            ticks,
            feeGrowthGlobal0,
            feeGrowthGlobal1,
            secondsPerLiquidity,
            mintParams.lowerOld,
            mintParams.lower,
            mintParams.upperOld,
            mintParams.upper,
            uint128(_liquidity),
            nearestTick,
            uint160(currentPrice)
        );

        (uint128 amount0Actual, uint128 amount1Actual) = _getAmountsForLiquidity(priceLower, priceUpper, currentPrice, _liquidity);

        ITridentRouter.TokenInput[] memory callbackData = new ITridentRouter.TokenInput[](2);
        callbackData[0] = ITridentRouter.TokenInput(token0, mintParams.token0native, amount0Actual);
        callbackData[1] = ITridentRouter.TokenInput(token1, mintParams.token1native, amount1Actual);

        ITridentCallee(msg.sender).tridentMintCallback(abi.encode(callbackData));

        unchecked {
            if (amount0Actual != 0) {
                require(amount0Actual + reserve0 <= _balance(token0), ""TOKEN0_MISSING"");
                reserve0 += amount0Actual;
            }

            if (amount1Actual != 0) {
                require(amount1Actual + reserve1 <= _balance(token1), ""TOKEN1_MISSING"");
                reserve1 += amount1Actual;
            }
        }

        (uint256 feeGrowth0, uint256 feeGrowth1) = rangeFeeGrowth(mintParams.lower, mintParams.upper);

        if (mintParams.positionRecipient != address(0)) {
            IPositionManager(mintParams.positionOwner).positionMintCallback(
                mintParams.positionRecipient,
                mintParams.lower,
                mintParams.upper,
                uint128(_liquidity),
                feeGrowth0,
                feeGrowth1
            );
        }

        emit Mint(mintParams.positionOwner, amount0Actual, amount1Actual, mintParams.positionRecipient);
    }","Similar to a previous finding in the `IndexPool` contract, the `mint` function of `ConcentratedLiquidityPool` allows integer overflows when checking the balance is larger or equal to the received amount of token plus the reserve. As a result, the attacker could get a large amount of liquidity but only provide a small number of tokens to the pool, effectively stealing other LPs' funds when burning his liquidity.

Notice that this bug is independent of another bug of incorrect casting `uint256` type to `uint128` in the `_getAmountsForLiquidity` function. Even if the previously mentioned bug does not exist, the attacker could still steal the funds in the pool by exploiting this bug.

Proof of Concept
1.  Suppose that the current price is at the tick `500000`, an attacker calls the `mint` function with the following parameters:

```solidity
mintParams.lower = 100000
mintParams.upper = 500000
mintParams.amount1Desired = (1 << 128) - 47541305835 # a carefully chosen number
mintParams.amount0Desired = 0
```
2.  Since the current price is equal to the upper price, we have

```solidity
_liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper - priceLower)
    = 4731732988155153573010127839
```
3.  The amounts of `token0` and `token1` that the attacker has to pay is

```solidity
amount0Actual = 0
amount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))
    = uint128(_liquidity * (priceUpper - priceLower) // (1 << 96)) # round up
    = uint128(340282366920938463463374607384226905622)
    = 340282366920938463463374607384226905622
    = (1 << 128) - 47541305834
```
4.  As long as `reserve1` is greater than `47541305834`, the addition `amount1Actual + reserve1` overflows to a small number, causing the attacker to pass the balance check.","The `ConcentratedLiquidityPool.mint` function allows a user to specify an arbitrary position owner for their newly created positions. However, this can lead to users being able to front-run each other's transactions by specifying themselves as the position owner of another transaction that they want to be executed before it. As a result, these two transactions will have different nonces and therefore one of them will fail due to reentrancy protection.

Proof of Concept

*   Alice wants to create a long position with a lower tick of -3974 and upper tick of -3968. She specifies herself as the position owner so she can receive her tokens immediately after creation.
*   Bob wants to create a short position with a lower tick of -3974 and upper tick of -3968. He also specifies himself as the position owner so he can receive his tokens immediately after creation.
*   Charlie wants to create a long position with a lower tick of -3974 and upper tick of -3968 but does not specify any position owner. Therefore, the pool will use him as the default position owner.

Alice creates her long position first which succeeds because there are no existing positions between -3974 and -3968. Then, Bob tries to create his short position next but fails because the pool thinks that he already has a position at those prices. Finally, Charlie tries to create his long position last and succeeds since the pool now sees that there is only one position between -3974 and -3968.

As you can see from the example above, the attacker can easily manipulate the order of transactions such that the victim's transaction always comes second. Since the pool uses the same nonce for all three transactions, the victim's transaction will always fail due to reentrancy protection."
"function grantRole(bytes4 role, address account) external virtual admin(role) {
        _grantRole(role, account);
    }","The auth mechanism of `AccessControl.sol` uses function selectors `(msg.sig)` as a `(unique)` role definition. Also the `_moduleCall` allows the code to be extended.

Suppose an attacker wants to add the innocent-looking function ""left_branch_block(uint32)"" in a new module. Suppose this module is added via `_moduleCall`, and the attacker gets authorization for the innocent function.

This function happens to have a signature of 0x00000000, which is equal to the root authorization. In this way, the attacker could get authorization for the entire project.

Note: it's pretty straightforward to generate function names for any signature value; you can just brute force it because it's only 4 bytes.

However, given that this could be exploited only through a malicious governance exploit, I would reduce the risk to ""Low.""","The `Roles` contract has a permissionless function called `grantRole`. An attacker can front-run this transaction by first calling `revokeRole`, then sending their own transaction with `grantRole`. They will be able to assume the role they want without paying any gas fees as it's already been revoked for them.

Proof of Concept

1.  Attacker calls revoke on a role that doesn't exist yet (e.g., `0xdeadbeef`)
2.  Attacker sends tx to call `grantRole()` on the same non-existent role (`0xdeadbeef`).
3.  Attackers now have access to the role even though no one else does."
"function _setGovernace(address _governance) internal {
        governance = _governance;
    }function initialize(
        address _registry,
        address _underlyingAsset,
        string memory _name,
        address _vamm,
        address _governance
    ) external initializer {
        _setGovernace(_governance);

        vamm = IVAMM(_vamm);
        underlyingAsset = _underlyingAsset;
        name = _name;
        fundingBufferPeriod = 15 minutes;

        syncDeps(_registry);
    }

function syncDeps(address _registry) public onlyGovernance {
        IRegistry registry = IRegistry(_registry);
        clearingHouse = registry.clearingHouse();
        oracle = IOracle(registry.oracle());
    }","The contract `AMM.sol` cannot be initialize unless it is called from the `_governance` address.

This prevents the use of a deployer account and requires the governance to be able to deploy proxy contracts and encode the required arguements. If this is not feasible then the contract cannot be deployed.

Proof of Concept

`initialize()` calls `_setGovernace(_governance);` which will store the governance address.

Following this it will call `syncDeps(_registry);` which has `onlyGovernance` modifier.  Thus, if the `msg.sender` of `initialize()` is not the same as the parameter `_governance` then the initialisation will revert.

```solidity
    function initialize(
        address _registry,
        address _underlyingAsset,
        string memory _name,
        address _vamm,
        address _governance
    ) external initializer {
        _setGovernace(_governance);

        vamm = IVAMM(_vamm);
        underlyingAsset = _underlyingAsset;
        name = _name;
        fundingBufferPeriod = 15 minutes;

        syncDeps(_registry);
    }
```","The `initialize` function of `YieldSource` calls `_setGovernance`, but it does not check if the governor has been set beforehand (i.e., whether `governance != address(0)`). If this happens during deployment or when upgrading a new implementation, then the previous value will be overwritten with an empty address (`_setGovernance(address(0))`). As a result, all functions that require access control via the modifier `onlyGovernance()` will fail because they cannot find any valid governor."
"function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    // return the block at which the funds will be available
    return unlockTimestamp;
  }

function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    // Sweep the old balance, if any
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    // if the funds should already be unlocked
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    // if there is nothing to do, just quit
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }","One can withdraw the entire `PrizePool` deposit by circumventing the timelock.
Assume the user has no credits for ease of computation:
- user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This ""mints"" an equivalent `amount` of `timelock` and resets `_unlockTimestamps[user] = timestamp = blockTime + lockDuration`.
- user calls `withdrawWithTimelockFrom(user, amount=0)` again but this time withdrawing `0` amount. This will return a `lockDuration` of `0` and thus `unlockTimestamp = blockTime`. The inner `_mintTimelock` now resets `_unlockTimestamps[user] = unlockTimestamp`
- As `if (timestamp <= _currentTime()) ` is true, the full users amount is now transferred out to the user in the `_sweepTimelockBalances` call.

Users don't need to wait for their deposit to contribute their fair share to the prize pool.
They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol.
It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.","The `withdrawWithTimelockFrom` function of `Controller` allows a user to specify an arbitrary token as the `controlledToken`. However, this parameter does not have any effect on the actual functionality of the function since it's ignored by all other functions that use it. As a result, the `controlledToken` can be set to any ERC-20 token without actually affecting anything. An attacker could exploit this issue to steal tokens from the protocol.

Proof of Concept

An attacker sends a transaction with `withdrawWithTimelockFrom`, setting `controlledToken=attacker_erc20_token`. Then, they wait until the timelock expires and call `_sweepTimelockBalance()`. Since no one has called `setControlledTokens()` beforehand, the default value of `controledTokens` is used, which includes USDC. Therefore, when calling `_redeem()`, the attacker receives USDC instead of their own custom token. They then receive the entire supply of USDC minted during the timelock period."
"function voteProposal(uint proposalID) public returns (uint voteWeight) {
        bytes memory _type = bytes(mapPID_type[proposalID]);
        voteWeight = countMemberVotes(proposalID);
        if(hasQuorum(proposalID) && mapPID_finalising[proposalID] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'REWARD')){
                if(hasMajority(proposalID)){
                    _finalise(proposalID);
                }
            } else {
                _finalise(proposalID);
            }
        }
        emit NewVote(msg.sender, proposalID, voteWeight, mapPID_votes[proposalID], string(_type));
    }","`voteProposal()` doesn't check that `proposalID <= proposalCount`.

It should be ""<="", because `proposalCount` is updated before using it (e.g. in this way the proposal n. 0 is not assignable, although i'm not sure if it's wanted or not.","The `voteProposal` function of `Governance.sol` does not check that a user has enough tokens to actually be able to cast their vote on a proposal. If they don't have any tokens then it will fail with an error message saying ""ERC20: transfer amount exceeds balance"". However this doesn't stop them from being counted as having voted for the proposal which can lead to incorrect results when calculating whether there is quorum or majority support for the proposal."
"function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){
        require(getPool(token) == address(0)); // Must be a valid token
        require((inputToken > 0 && inputBase >= (10000*10**18)), ""!min""); // User must add at least 10,000 SPARTA liquidity & ratio must be finite
        Pool newPool; address _token = token;
        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB
        require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18
        newPool = new Pool(BASE, _token); // Deploy new pool
        pool = address(newPool); // Get address of new pool
        mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory
        _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool
        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool
        arrayPools.push(pool); // Add pool address to the pool array
        arrayTokens.push(_token); // Add token to the listed array
        isListedPool[pool] = true; // Record pool as currently listed
        Pool(pool).addForMember(msg.sender); // Perform the liquidity-add for the user
        emit CreatePool(token, pool);
        return pool;
    }

function addCuratedPool(address token) external onlyDAO {
        require(token != BASE); // Token must not be SPARTA
        address _pool = getPool(token); // Get pool address
        require(isListedPool[_pool] == true); // Pool must be valid
        require(curatedPoolCount() < curatedPoolSize, ""maxCurated""); // Must be room in the Curated list
        isCuratedPool[_pool] = true; // Record pool as Curated
        emit AddCuratePool(_pool, isCuratedPool[_pool]);
    }

function curatedPoolCount() internal view returns (uint){
        uint cPoolCount; 
        for(uint i = 0; i< arrayPools.length; i++){
            if(isCuratedPool[arrayPools[i]] == true){
                cPoolCount += 1;
            }
        }
        return cPoolCount;
    }function remove() external returns (uint outputBase, uint outputToken) {
        return removeForMember(msg.sender);
    }

function removeForMember(address member) public returns (uint outputBase, uint outputToken) {
        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount
        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units
        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units
        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts
        _burn(address(this), _actualInputUnits); // Burn the LP tokens
        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user
        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user
        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);
        return (outputBase, outputToken);
    }","The function `curatedPoolCount()` contains a for loop over the array `arrayPools`. If `arrayPools` would be too big then the loop would run out of gas and `curatedPoolCount()` would revert. This would mean that `addCuratedPool()` cannot be executed anymore (because it calls `curatedPoolCount()`).

The array `arrayPools` can be increased in size arbitrarily by repeatedly doing the following:
- create a pool with `createPoolADD()`  (which requires 10,000 SPARTA)
- empty the pool with `remove()` of Pool.sol, which gives back the SPARTA tokens
These actions will use gas to perform.","The `createPoolADD` function allows users to specify an initial base and token deposit when creating a new pool. However, there is no check that these values actually exist on the caller account before transferring them into the newly created pool. If either of these balances do not exist or are insufficient then the entire transaction will revert preventing any further pools from being added by this user. Additionally, since the `remove()` function does not have access to the actual underlying assets held within the pool but instead relies upon the current balances stored within the pool itself, removing a pool can also fail if the balances stored within the pool are less than what would be returned to the calling user. As such, adding and removing pools should always be done with caution and care to avoid losing funds due to incorrect specifications or other unforeseen issues."
"function burnSynth() external returns (bool){
        uint _syntheticAmount = balanceOf(address(this)); // Get the received synth units
        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; // share = amount * part/total
        mapSynth_LPBalance[msg.sender] -= _amountUnits; // Reduce lp balance
        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; // Reduce debt by synths being burnt
        if(_amountUnits > 0){
            _burn(address(this), _syntheticAmount); // Burn the synths
            Pool(msg.sender).burn(_amountUnits); // Burn the LP tokens
        }
        return true;
    }function _processWithdraw(address _synth, address _member, uint256 _basisPoints) internal returns (uint256 synthReward) {
        require((block.timestamp > mapMember_depositTime[_member]), ""lockout""); // Must not withdraw before lockup period passed
        uint256 _principle = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Calc amount to withdraw
        mapMemberSynth_deposit[_member][_synth] -= _principle; // Remove from user's recorded vault holdings
        uint256 _weight = iUTILS(_DAO().UTILS()).calcPart(_basisPoints, mapMemberSynth_weight[_member][_synth]); // Calc SPARTA value of amount
        mapMemberTotal_weight[_member] -= _weight; // Remove from member's total weight (scope: member)
        mapMemberSynth_weight[_member][_synth] -= _weight; // Remove from member's synth weight (scope: member -> synth)
        totalWeight -= _weight; // Remove from total weight (scope: vault)
        emit MemberWithdraws(_synth, _member, synthReward, _weight, totalWeight);
        return (_principle + synthReward);
    }function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, ""!synth""); // Must be a valid Synth
        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount
        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA
        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA
        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract
        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units
        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount
        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user
        _addPoolMetrics(fee); // Add slip fee to the revenue metrics
        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);
      return (outputBase, fee);
    }","When users try to born synth, the fee and the value of Sparta is calculated at contract `Pool` while the logic of burning `Pool`s Lp and Synth is located at `Synth` contract.

Users can send synth to the `Synth` contract directly and trigger `burnSynth` at the `Pool` contract. The Pool would not send any token out while the `Synth` contract would burn the lp and Synth.
While users can not drain the liquidity by doing this, breaking the AMM rate unexpectedly is may lead to troubles.  The calculation of debt and the fee would end up with a wrong answer.

Pool's `burnSynth` and Synth's `burnSynth` are tightly coupled functions. In fact, according to the current logic, `Synth:burnSynth` should only be triggered from a valid `Pool` contract.

IMHO, applying the`Money in - Money Out` model in the `Synth` contract does more harm than good to the readability and security of the protocol.","The `Synth` contract has two functions that allow users to remove their deposited assets (`withdraw()` and `burnSynth()`):
-   `withdraw()` allows users to retrieve their deposited assets as long as they have waited for the required lock up time since their last deposit or withdrawal. It also updates the pool balances accordingly.
-   `burnSynth()` allows users to retrieve their deposited assets but it does not update the pool balances. As a result, this function should only be used when there are no other active pools. Otherwise, the pool balances will become outdated which can lead to incorrect calculations and potentially loss of funds.

As a result, these functions should never be called on any other than the first pool created because all subsequent pools would use stale data. If another pool was already created then calling either of these functions could cause issues with the rest of the system."
"function addDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = true;
    }

function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        updatePool(_pid);
       
        if(user.amount > 0) {  
            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
            if (pending > 0) {
                safeConcurTransfer(_recipient, pending);
            }
        }

        if (_amount > 0) {
            if (pool.depositFeeBP > 0) {
                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);
                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);
            } else {
                user.amount = SafeCast.toUint128(user.amount + _amount);
            }
        }     

        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Deposit(_recipient, _pid, _amount);
    }","The owner of `MasterChef.sol` can add a `depositor` with `addDepositor()`. A `depositor` can deposit with an arbitrary amount, without any cost. This allows a malicious/compromised depositor to take the majority share (nearly 100%) of all pools simply by calling `deposit()` with extremely large amounts, and take all the rewards.","The `addDepositor` function of ConcurChef allows an owner to set a new depositor address as eligible for calling the `deposit()` function on behalf of other users. However, this function does not check whether the `_depositor` parameter already exists in the mapping `isDepositor`. If it did exist beforehand, then the previous value would be overwritten with the current one. As a result, there could be multiple addresses that have been added by different owners but end up having the same value. In turn, these duplicate values will allow any of them to call the `deposit()` function on behalf of their designated users.

This issue can lead to funds being stolen from the protocol since all the rewards received by the duplicated depositors will go directly into their pools instead of the original ones. It also makes the system less secure because now anyone who has access to the private key of either of those depositors can steal funds from the entire system."
"function getLockedAmount(
        LockedInfo[] memory array,
        address account,
        uint256 amount,
        bool isIncrease
    ) public pure override returns (uint256) {
        if (array.length == 0) return 0;

        uint256 newLockedAmount;
        if (isIncrease) {
            for (uint256 i = 0; i < array.length; i++) {
                uint256 remainingVouchingAmount;
                if (array[i].vouchingAmount > array[i].lockedAmount) {
                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;
                } else {
                    remainingVouchingAmount = 0;
                }

                if (remainingVouchingAmount > array[i].availableStakingAmount) {
                    if (array[i].availableStakingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;
                    }
                } else {
                    if (remainingVouchingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;
                    }
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        } else {
            for (uint256 i = 0; i < array.length; i++) {
                if (array[i].lockedAmount > amount) {
                    newLockedAmount = array[i].lockedAmount - 1;
                } else {
                    newLockedAmount = 0;
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        }

        return 0;
    }","getLockedAmount() is used by UserManager.sol#updateLockedData() to update locked amounts.

Based on the context, at L66, newLockedAmount = array[i].lockedAmount - 1; should be newLockedAmount = array[i].lockedAmount - amount;.

The current implementation is wrong and makes it impossible to unlock lockedAmount in CreditLimitByMedian model.","The `getLockedAmount` function of `LockedUtils` does not check that the stakers' locked amounts do not exceed their available vouching amounts. If a user has more than his available vouching amount locked, then he will be unable to unlock any tokens as long as this lock exists.

Proof of Concept

Suppose Alice wants to increase her locked amount by one token but she doesn't have enough tokens left over from previous locks so she can only add half a token. She tries to call `increaseLock()` with an amount equal to the number of tokens she wants to add which is one token. However, since there isn't enough tokens left over from previous locks, the transaction reverts because it would try to set the locked amount to two tokens when it should only be able to go up to one token."
"function _transferYield(address _asset) internal {
    require(_asset != address(0), Errors.VT_PROCESS_YIELD_INVALID);
    uint256 yieldAmount = IERC20(_asset).balanceOf(address(this));

    // transfer to treasury
    if (_vaultFee > 0) {
      uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);
      yieldAmount = yieldAmount.sub(treasuryAmount);
    }

    // transfer to yieldManager
    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');
    TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount);

    emit ProcessYield(_asset, yieldAmount);
  }

function processYield() external override onlyAdmin {
    // Claim Rewards(CRV, CVX, Extra incentive tokens)
    address baseRewardPool = getBaseRewardPool();
    IConvexBaseRewardPool(baseRewardPool).getReward();

    // Transfer CRV to YieldManager
    address _token = _addressesProvider.getAddress('CRV');
    address _tokenFromConvex = IConvexBaseRewardPool(baseRewardPool).rewardToken();
    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);
    _transferYield(_token);

    // Transfer CVX to YieldManager
    _token = _addressesProvider.getAddress('CVX');
    _tokenFromConvex = IConvexBooster(convexBooster).minter();
    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);
    _transferYield(_token);

    // Transfer extra incentive token to YieldManager
    uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength();
    for (uint256 i = 0; i < extraRewardsLength; i++) {
      address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i);
      address _rewardToken = IRewards(_extraReward).rewardToken();
      _transferYield(_rewardToken);
    }
  }

function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {
    uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);
    IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);
    return treasuryAmount;
  }","Now there are no checks for the amounts to be transferred via _transferYield and _processTreasury. As reward token list is external and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the reward retrieval can become unavailable.

I.e. processYield() can be fully blocked for even an extended period, with some low probability, which cannot be controlled otherwise as pool reward token list is external.

Setting the severity to medium as reward gathering is a base functionality for the system and its availability is affected.

Proof of Concept

_transferYield proceeds with sending the amounts to treasury and yieldManager without checking:

The incentive token can be arbitrary. Some ERC20 do not allow zero amounts to be sent:

In a situation of such a token added to reward list and zero incentive amount earned the whole processYield call will revert, making reward gathering unavailable until either such token be removed from pool's reward token list or some non-zero reward amount be earned. Both are external processes and aren’t controllable.","The `ValueThrower._transferYield` function transfers all of the `_asset`'s balance to the `yieldManager`. However, it first calls the `_processTreasury` function which can be called by anyone with a small amount of gas cost. If an attacker were able to front-run this transaction they could set up a reentrancy exploit that would allow them to steal funds from both the vault's reserve and the `yieldManager`.

Proof of Concept

1.  An attacker sends a low-cost transaction calling ValueThrower.`_processTreasury`, setting their own address as the `_treasuryAddress`;
2.  An attacker then sends another low-cost transaction calling ValueThrower.`processYield()`, triggering the call to ValueThrower.`_transferYield()`;
3.  As part of the execution of ValueThrower.`_transferYield()`, the current implementation will call ValueThrower.`_processTreasury()`. Since the attacker has already set themselves as the `_treasuryAddress`, this call will send some portion of the asset being transferred to the attackers account.
4.  Finally, the original transaction sent at step #1 will complete, sending the remainder of the assets to the attacker's specified address.

This allows an attacker to drain funds from the Vault and the `yieldManager` without having to spend any significant amounts of gas or time on the attack. It also does not rely on flashloan exploits like Compound's recent high risk issue did."
"function init(address _vether, address _USDV, address _utils) external {
        require(inited == false);
        inited = true;
        VETHER = _vether;
        USDV = _USDV;
        UTILS = _utils;
        rewardAddress = _USDV;
    }function init(address _vader, address _usdv, address _vault) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        VAULT = _vault;
        coolOffPeriod = 1;
    }function init(address _vader, address _usdv, address _pool) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        POOLS = _pool;
        rewardReductionFactor = 1;
        timeForFullProtection = 1;//8640000; //100 days
        curatedPoolLimit = 1;
        anchorLimit = 5;
        insidePriceLimit = 200;
        outsidePriceLimit = 500;
    }function init(address _vader, address _usdv, address _router, address _factory) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
    }function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        POOLS = _pools;
        FACTORY = _factory;
    }function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {
        require(inited == false);
        inited = true;
        POOLS = _pool;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
        POOLS = _pool;
        erasToEarn = 100;
        minimumDepositTime = 1;
        minGrantTime = 2592000;     // 30 days
    }function init(address _vader, address _vault, address _router) external {
        require(inited == false);
        inited = true;
        VADER = _vader;
        VAULT = _vault;
        ROUTER = _router;
        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();
    }function init(address _pool) public {
        require(inited == false);
        inited = true;
        POOLS = _pool;
    }","Most of the solidity contracts have an init function that everyone can call.
This could lead to a race condition when the contract is deployed. At that moment a hacker could call the `init` function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.","The `init` functions of several critical contracts do not have any access control or input validation. These functions can be called by anyone at any point after deployment (e.g., if a deployer accidentally deploys an old version), which would overwrite all previously set values with new ones. As these variables are used for crucial functionality like token addresses, timelocks, etc., this could lead to serious issues that might take weeks or even months to resolve."
"function set(
    Lockups storage lockups,
    uint256 index,
    uint256 expiration,
    uint256 totalAmount
  ) internal {
    unchecked {
      uint256 lockedBalanceBits = totalAmount | (expiration << 96);
      if (index % 2 == 0) {
        // set first 128 bits.
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask) | (lockedBalanceBits << 128);
      } else {
        // set last 128 bits.
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask) | lockedBalanceBits;
      }
    }
  }

function setTotalAmount(
    Lockups storage lockups,
    uint256 index,
    uint256 totalAmount
  ) internal {
    unchecked {
      if (index % 2 == 0) {
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & firstAmountBitsMask) | (totalAmount << 128);
      } else {
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & secondAmountBitsMask) | totalAmount;
      }
    }
  }","The `LockedBalance` contract takes 256-bit amount values but performs bit math on them as if they were 96 bit values. Bits could spill over to a different locked balance in the `else` part (`lockedBalance` stores two 128-bit locked balances in one 256-bit storage field):

It could then increase the other, unrelated locked balance's amount leading to stealing funds from the protocol. All callers of this function currently seem to ensure that `totalAmount` is indeed less than 96 bits but the `LockedBalance` library should be self-contained and not depend on the calling side to perform all checks.

If the code is ever extended and more calls to these functions are performed, it'll likely cause issues.

The same issue happens in `setTotalAmount`.","The `set` and `setTotalAmount` functions of `LibLockups` assume that the input parameters have a certain range. However, there's no check on these ranges which can lead to unexpected results or revert due to out-of-range values. These checks should be added for safety reasons."
"function advance() external {
    require(block.timestamp >= getEpochStartTime(epoch + 1), ""Cannot advance epoch until start of new epoch"");

    incrementEpoch();

    malt.mint(msg.sender, advanceIncentive * 1e18);

    emit Advance(epoch, block.number, block.timestamp);
  }","DAO.sol incentives outside parties to advance the epoch by minting 100 MALT tokens for calling the advance function. This is limited by checking that the start timestamp of the next epoch has passed.

This start timestamp is calculated by multiplying the new epoch number by the length of an epoch and adding it to the genesis timestamp.

This method makes no accommodation for the fact that previous epochs may have been set to be a different length to what they are currently.

In the case where the epoch length is reduced, DAO will think that the epoch number can be incremented potentially many times. Provided the advanceIncentive is worth more than the gas necessary to advance the epoch will be rapidly advanced potentially many times paying out unnecessary incentives.","The `advance` function allows anyone to call it at any time (no access control) as long as they have a small amount of gas left on their transaction. If this happens during an active epoch then the current epoch will be advanced by one without waiting for the end of that epoch. As a result, the rewards from the previous epochs will not be distributed correctly.

Proof of Concept

*   Alice calls `advance()` when epoch = 20;
*   Bob calls `stake()` with 5 tokens after Alice's call but before the next epoch starts;
*   Charlie calls `withdrawStakingRewards()` just after epoch 21 has started;

As a result, Alice receives her reward for epoch 21 while Bob only gets his reward for epoch 23 because he staked between epochs 21 and 22. Similarly, Charlie does not receive his reward for epoch 21."
"function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {
        return keccak(self, offset, len) == keccak(other, otherOffset, len);
    }

function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {
        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);
    }

function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {
        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);
    }

function equals(bytes memory self, bytes memory other) internal pure returns(bool) {
        return self.length == other.length && equals(self, 0, other, 0, self.length);
    }","equals with offset might return true when equals without offset returns false.

The problem is that self.length could be greater than other.length + offset, it should be ==, or it should contain a length argument.

Here you have an example of the failure:

*   equals(0x0102030000, 0, 0x010203) => return true

decoded input	{
	""bytes self"": ""0x0102030000"",
	""uint256 offset"": ""0"",
	""bytes other"": ""0x010203""
}
decoded output	{
	""0"": ""bool: true""
}","The `BytesLib` library provides functions for comparing byte arrays (`equals`). However, these functions do not check if they have been called with valid parameters. For example, it's possible to pass an invalid `offset`, which will lead to a revert of the entire transaction. Also, there may be off-by-one errors that can cause unexpected results or reverts."
"function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration,
    IERC20Upgradeable _stakeToken
  )
    public
    initializer
  {
    PrizePool.initialize(
      _reserveRegistry,
      _controlledTokens,
      _maxExitFeeMantissa,
      _maxTimelockDuration
    );
    stakeToken = _stakeToken;

    emit StakePrizePoolInitialized(address(stakeToken));
  }","The `initializeYieldSourcePrizePool` function of `YieldSourcePrizePool.sol` has a check to make sure `_yieldSource` !=0. However, the `initialize` function  of the comparable `StakePrizePool.sol` doesn't do this check.

Although unlikely this will introduce problems, it is more consistent to check for 0.","The `StakePrizePool` does not have a way for users to withdraw their tokens from it if they want to exit the pool or if there's an issue with the prize strategy. If this happens then all of these funds will be locked up forever as the owner of the token can never retrieve them again.

This could happen due to either a mistake by the owner of the token when setting up the prize strategy or because the prize strategy itself has issues that prevent any winnings being distributed out to the users who deposited into the pool. In both cases, the funds would effectively become stuck in the contract which means no one can ever get access to those funds again."
"function _calcRewardIntegral(
        uint256 _pid,
        uint256 _index,
        address _account,
        uint256 _balance,
        uint256 _supply
    ) internal {
        RewardType memory reward = rewards[_pid][_index];

        //get difference in balance and remaining rewards
        //getReward is unguarded so we use remaining to keep track of how much was actually claimed
        uint256 bal = IERC20(reward.token).balanceOf(address(this));
        uint256 d_reward = bal - reward.remaining;
        // send 20 % of cvx / crv reward to treasury
        if (reward.token == cvx || reward.token == crv) {
            IERC20(reward.token).transfer(treasury, d_reward / 5);
            d_reward = (d_reward * 4) / 5;
        }
        IERC20(reward.token).transfer(address(claimContract), d_reward);

        if (_supply > 0 && d_reward > 0) {
            reward.integral =
                reward.integral +
                uint128((d_reward * 1e20) / _supply);
        }

        //update user integrals
        uint256 userI = userReward[_pid][_index][_account].integral;
        if (userI < reward.integral) {
            userReward[_pid][_index][_account].integral = reward.integral;
            claimContract.pushReward(
                _account,
                reward.token,
                (_balance * (reward.integral - userI)) / 1e20
            );
        }

        //update remaining reward here since balance could have changed if claiming
        if (bal != reward.remaining) {
            reward.remaining = uint128(bal);
        }

        rewards[_pid][_index] = reward;
    }","The problems in the current implementation:

*   `reward.remaining` is not a global state; the `reward.remaining` of other `reward`s with the same rewardToken are not updated;
*   `bal` should be refreshed before `reward.remaining = uint128(bal);`;
*   L175 should not use `balanceOf` but take the diff before and after `getReward()`.

### Proof of Concept

*   convexPool[1] is incentivized with CRV as the reward token, `1000 lpToken` can get `10 CRV` per day;
*   convexPool[2] is incentivized with CRV as the reward token, `1000 lpToken` can get `20 CRV` per day.

1.  Alice deposits `1,000` lpToken to `_pid` = `1`
2.  1 day later, Alice deposits `500` lpToken to `_pid` = `1`

*   convexPool `getReward()` sends `10 CRV` as reward to contract
*   `d_reward` = 10, `2 CRV` sends to `treasury`, `8 CRV` send to `claimContract`
*   `rewards[1][0].remaining` = 10

3.  0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, and the tx will fail:

*   convexPool `getReward()` sends `7.5 CRV` as reward to contract
*   `reward.remaining` = 10
*   `bal` = 7.5
*   `bal - reward.remaining` will fail due to underflow

4.  0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, most of the reward tokens will be left in the contract:

*   convexPool `getReward()` sends `15 CRV` as reward to the contract;
*   `d_reward = bal - reward.remaining` = 5
*   `1 CRV` got sent to `treasury`, `4 CRV` sent to `claimContract`, `10 CRV` left in the contract;
*   `rewards[1][0].remaining` = 15

Expected Results:

All the `15 CRV` get distributed: `3 CRV` to the `treasury`, and `12 CRV` to `claimContract`.

Actual Results:

Only `5 CRV` got distributed. The other `10 CRV` got left in the contract which can be frozen in the contract, see below for the details:

5.  Bob deposits `1,000` lpToken to `_pid` = `2`

*   convexPool `getReward()` sends `0 CRV` as reward to the contract
*   `d_reward = bal - reward.remaining` = 10
*   `2 CRV` sent to `treasury`, `8 CRV` sent to `claimContract` without calling `pushReward()`, so the `8 CRV` are now frozen in `claimContract`;
*   `rewards[2][0].remaining` = 10

### Impact

*   The two most important methods: `deposit()` and `withdraw()` will frequently fail as the tx will revert at `_calcRewardIntegral()`;
*   Rewards distributed to users can often be fewer than expected;
*   If there are different pools that use the same token as rewards, part of the rewards can be frozen at `claimContract` and no one can claim them.

Because `_calRewardIntegral` is a core functionality of the contract (giving out reward) and the warden has shown how it can be broken, I agree with High Severity.","The `ConvexStakingWrapper._calcRewardIntegral` function updates a user's integral for each pool they stake in by calling the `claimContract`'s `pushReward`. However, it does not update the user's integral when their current balance is less than or equal to zero. As a result, users who withdraw all tokens from the protocol will lose out on any pending rewards that were supposed to be distributed to them."
"function enableCollateral (address _collateral) external onlyGovernor {

        require(collateralExists[_collateral], ""OVLV1:!exists"");

        require(!collateralActive[_collateral], ""OVLV1:!disabled"");

        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);

        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);

    }

function disableCollateral (address _collateral) external onlyGovernor {

        require(collateralActive[_collateral], ""OVLV1:!enabled"");

        OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);

        OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);

    }",The function `disableCollateral` of OverlayV1Mothership.sol doesn't set `collateralActive[_collateral] = false;` but it does revoke the roles. Now `enableCollateral` can never be used because `collateralActive[_collateral] == true` and it will never pass the second require. So you can never grant the roles again. Note: `enableCollateral` also doesn't set `collateralActive[_collateral] = true`.,"The `enableCollateral` and `disableCollateral` functions of `OVLV1` allow governors to add or remove collaterals from the whitelist, respectively. However, these functions do not check if a role has already been granted before granting it again. Similarly, they don't check for roles that have already been revoked when trying to revoke them. As a result, an address can be repeatedly added as both a minter and burner by calling `enableCollateral`, which would break functionality. Additionally, repeated calls to `disableCollateral` will fail because the role cannot be removed twice."
"function setUnstakeWindow(uint40 _unstakeWindow) external override onlyGovMain {
    require(_unstakeWindow < 25000000, 'MAX'); // ~ approximate 10 years of blocks
    GovStorage.gs().unstakeWindow = _unstakeWindow;
  }

function setCooldown(uint40 _period) external override onlyGovMain {
    require(_period < 25000000, 'MAX'); // ~ approximate 10 years of blocks
    GovStorage.gs().unstakeCooldown = _period;
  }",The function `setUnstakeWindow` and `setCooldown` don't check that the input parameter isn't 0. So the values could accidentally be set to 0 (although unlikely). However you wouldn't want the to be 0 because that would allow attacks with flashloans (stake and unstake in the same transaction),"The `setUnstakeWindow` and `setCooldown` functions allow setting a new value for these parameters but they don't emit any events or update the storage cache so it will be necessary to call them again if you want to change their values after that. Also, there’s no upper limit on how many times this can happen which could lead to an unrecoverable situation where governance cannot be changed anymore (see issue #3)."
"function transferNft(
        address _currentOwner,
        address _newOwner,
        uint256 _tokenId
    ) external override {
        require(marketTracker[_tokenId] == msgSender(), ""Not market"");
        _transfer(_currentOwner, _newOwner, _tokenId);
    }","The `transferNft` function of `RCNftHubL2` is called when transferring the card to the final winner. However, this function does not check whether the recipient is aware of the ERC721 protocol and calls `_transfer` directly. If the recipient is a contract not aware of incoming NFTs, then the transferred NFT would be locked in the recipient forever.","The `transferNft` function of `Market` does not check if `_currentOwner != _newOwner`. If this happens, it will call `_transfer`, which calls `safeTransferFrom`, with the same owner as both parameters. As a result, no NFTs get transferred at all."
"function unbondAndBreak(uint256 amount)
    external
  {
    require(amount > 0, ""Cannot unbond 0"");

    uint256 bondedBalance = balanceOfBonded(msg.sender);

    require(bondedBalance > 0, ""< bonded balance"");
    require(amount <= bondedBalance, ""< bonded balance"");

    // Avoid leaving dust behind
    if (amount.add(1e16) > bondedBalance) {
      amount = bondedBalance;
    }

    miningService.onUnbond(msg.sender, amount);

    _unbondAndBreak(amount);
  }function splitReinvest(uint256 rewardLiquidity) external {
    _retrieveReward(rewardLiquidity);

    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    rewardToken.safeTransfer(address(dexHandler), rewardBalance.div(2));

    dexHandler.buyMalt();

    _bondAccount(msg.sender);

    emit SplitReinvest(msg.sender, rewardLiquidity);
  }function purchaseAndBurn(uint256 amount)
    external
    onlyRole(AUCTION_ROLE, ""Must have auction privs"")
    returns (uint256 purchased)
  {
    require(collateralToken.balanceOf(address(this)) >= amount, ""Insufficient balance"");
    collateralToken.safeTransfer(address(dexHandler), amount);
    purchased = dexHandler.buyMalt();
    malt.burn(address(this), purchased);

    emit BurnMalt(purchased);
  }function buyMalt(uint256 maxCapital)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must have stabilizer node privs"")
    returns (uint256 capitalUsed)
  {
    if (maxCapital == 0) {
      return 0;
    }

    uint256 balance = collateralToken.balanceOf(address(this));

    if (balance == 0) {
      return 0;
    }

    if (maxCapital < balance) {
      balance = maxCapital;
    }

    collateralToken.safeTransfer(address(dexHandler), balance);
    dexHandler.buyMalt();

    deployedCapital = deployedCapital + balance;

    return balance;
  }

function sellMalt(uint256 maxAmount)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must have stabilizer node privs"")
    returns (uint256 amountSold)
  {
    if (maxAmount == 0) {
      return 0;
    }

    uint256 totalMaltBalance = malt.balanceOf(address(this));
    uint256 balance = totalMaltBalance;

    if (balance == 0) {
      return 0;
    }

    (uint256 basis,) = costBasis();

    if (maxAmount < totalMaltBalance) {
      balance = maxAmount;
    }

    malt.safeTransfer(address(dexHandler), balance);
    uint256 rewards = dexHandler.sellMalt();

    if (rewards <= deployedCapital && maxAmount != totalMaltBalance) {
      // If all malt is spent we want to reset deployed capital
      deployedCapital = deployedCapital - rewards;
    } else {
      deployedCapital = 0;
    }

    uint256 maltDecimals = malt.decimals();
    uint256 decimals = collateralToken.decimals();    

    uint256 profit = 0;

    if (maltDecimals == decimals) {
      uint256 soldBasis = basis.mul(balance).div(10**decimals);

      if (rewards > soldBasis) {
        profit = rewards.sub(soldBasis);
      }
    } else if (maltDecimals > decimals) {
      uint256 diff = maltDecimals - decimals;
      uint256 soldBasis = basis.mul(balance.div(10**diff)).div(10**decimals);

      if (rewards > soldBasis) {
        profit = rewards.sub(soldBasis);
      }
    } else {
      uint256 diff = decimals - maltDecimals;
      uint256 soldBasis = basis.mul(balance.mul(10**diff)).div(10**decimals);

      if (rewards > soldBasis) {
        profit = rewards.sub(soldBasis);
      }
    }

    if (profit > 0) {
      uint256 lpCut = profit.mul(lpProfitCut).div(1000);

      collateralToken.safeTransfer(address(rewardThrottle), lpCut);
      rewardThrottle.handleReward();
    }

    return balance;
  }function stabilize() external notSameBlock {
    auction.checkAuctionFinalization();

    require(
      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),
      ""Can't call stabilize""
    );
    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;

    rewardThrottle.checkRewardUnderflow();

    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);

    if (!_shouldAdjustSupply(exchangeRate)) {
      maltDataLab.trackReserveRatio();

      lastStabilize = block.timestamp;
      return;
    }

    emit Stabilize(block.timestamp, exchangeRate);

    if (exchangeRate > maltDataLab.priceTarget()) {
      _distributeSupply();
    } else {
      _startAuction();
    }

    lastStabilize = block.timestamp;
  }function buyMalt()
    external
    onlyRole(BUYER_ROLE, ""Must have buyer privs"")
    returns (uint256 purchased)
  {
    uint256 rewardBalance = rewardToken.balanceOf(address(this));

    if (rewardBalance == 0) {
      return 0;
    }

    rewardToken.approve(address(router), rewardBalance);

    address[] memory path = new address[](2);
    path[0] = address(rewardToken);
    path[1] = address(malt);

    router.swapExactTokensForTokens(
      rewardBalance,
      0, // amountOutMin
      path,
      address(this),
      now
    );

    purchased = malt.balanceOf(address(this));
    malt.safeTransfer(msg.sender, purchased);
  }

function sellMalt() external returns (uint256 rewards) {
    uint256 maltBalance = malt.balanceOf(address(this));

    if (maltBalance == 0) {
      return 0;
    }

    malt.approve(address(router), maltBalance);

    address[] memory path = new address[](2);
    path[0] = address(malt);
    path[1] = address(rewardToken);

    router.swapExactTokensForTokens(
      maltBalance,
      0,
      path,
      address(this),
      now
    );

    rewards = rewardToken.balanceOf(address(this));
    rewardToken.safeTransfer(msg.sender, rewards);
  }

function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {
    uint256 liquidityBalance = lpToken.balanceOf(address(this));

    if (liquidityBalance == 0) {
      return (0, 0);
    }

    lpToken.approve(address(router), liquidityBalance);

    (amountMalt, amountReward) = router.removeLiquidity(
      address(malt),
      address(rewardToken),
      liquidityBalance,
      0,
      0,
      msg.sender, // transfer broken LP tokens to sender
      now
    );

    if (amountMalt == 0 || amountReward == 0) {
      liquidityBalance = lpToken.balanceOf(address(this));
      lpToken.safeTransfer(msg.sender, liquidityBalance);
      return (amountMalt, amountReward);
    }
  }","UniswapHandler utilizes UniswapV2Router to swap, add liquidity, and remove liquidity with the UniswapV2Pair contract. In order to utilize these functionalities, UniswapHandler must call various UniswapV2Router methods.

*   addLiquidity
*   removeLiquidity
*   swapExactTokensForTokens (swaps for both DAI and Malt)

In all three methods, UniswapV2Router requires the callee to provide input arguments that define how much the amount out minimum UniswapHandler will allow for a trade. This argument is designed to prevent slippage and more importantly, sandwich attacks.

UniswapHandler correctly handles price slippage when calling addLiquidity. However, that is not the case for removeLiquidity and swapExactTokensForTokens. For both methods, 0 is passed in as the amount out minimum allowed for a trade. This allows for anyone watching the mempool to sandwich attack UniswapHandler (or any contract that calls UniswapHandler) in such a way that allows the hacker to profit off of a guaranteed trade.

How does this work? Let's assume UniswapHandler makes a call to UniswapV2Router#swapExactTokensForTokens to trade DAI for Malt. Any hacker who watches the mempool and sees this transaction can immediately buy as much Malt as they want. This raises the price of Malt. Since UniswapHandler is willing to accept any amount out minimum (the number is set to zero), then the UniswapHandler will always trade DAI for Malt. This second transaction raises the price of Malt even further. Finally, the hacker trades their Malt for DAI, receiving a profit due to the artificially inflated price of Malt from the sandwich attack.

It's important to note that anyone has access to the UniswapV2Router contract. There are no known ACL controls on UniswapV2Router. This sandwich attack can impact even the `buyMalt` function.

The following functions when called are vulnerable to frontrunning attacks:

*   UniswapHandler#buyMalt
*   UniswapHandler#sellMalt
*   UniswapHandler#removeLiquidity

And by extension the following contract functions since they also call the UniswapHandler function calls:

*   Bonding#unbondAndBreak
*   LiquidityExtension#purchaseAndBurn
*   RewardReinvestor#splitReinvest
*   StabilizerNode#stabilize
*   SwingTrader#buyMalt

Proof of Concept

Refer to the impact section for affected code and links to the appropriate LoC.","The `Router` used by Mochi has a known issue where it can be exploited for flashloan attacks. See here for more information on this type of attack.

Proof of Concept

*   In the current implementation, users can add liquidity using the `deposit()` function which will trigger a callback that calls `splitReinvest()`. As part of this process, the user receives a share of the pool based on their contribution. However, since the `deposit()` function does not specify any minimum amounts or slippage tolerances, an attacker could front-run the transaction and set up a sandwich trade between themselves and the victim. By doing so, they would receive a larger number of shares than expected while the victim would lose out as a result of the sandwich trade.
*   An example scenario is shown below:

Assume Alice wants to deposit $10 worth of USDC into the pool with Bob being the receiver of her funds. She first approves the Router contract to spend her USDC token. Then she initiates the deposit transaction via the `deposit()` function. At this point, Bob sees the transaction and immediately sets up a sandwich trade between himself and Alice. He then transfers his own funds from the pool to himself before finally sending them back to Alice. Since he received a higher number of shares than Alice did, he ends up receiving a larger portion of the pool’s assets compared to what Alice should have been credited with.

As a result, Alice loses out on a disproportionate amount of value relative to how much she contributed to the pool."
"function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }","The `FETH.withdrawFrom` function does not validate its `to` parameter. Funds can be lost if `to` is the zero address.

Similar issues have been judged as medium recently, see Sandclock M-15 and a related Github issue.","The `withdrawFrom` function of `FreeFromEscrow` allows an attacker to steal funds by frontrunning them with a flash loan. An attacker can first deposit some tokens into FreeFromEscrow using the `depositFor`. Then they will create a new token approving it for FreeFromEscrow's address. After that, they will use this newly created token as collateral to borrow more tokens from Compound or another lending protocol. Once the borrowing transaction has been mined, the attacker calls the `withdrawFrom` function on FreeFromEscrow passing their own address as the `to` parameter. As a result, all the user's funds will be transferred out of FreeFromEscrow and sent back to the attacker.

Proof of Concept

1.  Alice wants to get her funds from FreeFromEscrow but she doesn’t have any funds there so she creates a new ERC20 token called “AliceToken” which is approved for FreeFromEscrow;
2.  Alice uses Flashloan to take out a lot of money from Compound and then repays the loan;
3.  Alice now tries to withdraw her funds from FreeFromEscrow but instead of receiving her funds, she receives the entire balance of the contract because the attacker used her token as collateral when taking out the loan."
"function setMinRental(uint256 _newDivisor) public override onlyOwner {
        minRentalDayDivisor = _newDivisor;
    }

function withdrawDeposit(uint256 _amount, bool _localWithdrawal)
        external
        override
        balancedBooks
    {
        require(!globalPause, ""Withdrawals are disabled"");
        address _msgSender = msgSender();
        require(user[_msgSender].deposit > 0, ""Nothing to withdraw"");
        // only allow withdraw if they have no bids,
        // OR they've had their cards for at least the minimum rental period
        require(
            user[_msgSender].bidRate == 0 ||
                block.timestamp - (user[_msgSender].lastRentalTime) >
                uint256(1 days) / minRentalDayDivisor,
            ""Too soon""
        );

        // stpe 1: collect rent on owned cards
        collectRentUser(_msgSender, block.timestamp);

        // step 2: process withdrawal
        if (_amount > user[_msgSender].deposit) {
            _amount = user[_msgSender].deposit;
        }
        emit LogAdjustDeposit(_msgSender, _amount, false);
        user[_msgSender].deposit -= SafeCast.toUint128(_amount);
        totalDeposits -= _amount;
        if (_localWithdrawal) {
            erc20.transfer(_msgSender, _amount);
        } else {
            IRCBridge bridge = IRCBridge(bridgeAddress);
            bridge.withdrawToMainnet(_msgSender, _amount);
        }

        // step 3: remove bids if insufficient deposit
        if (
            user[_msgSender].bidRate != 0 &&
            user[_msgSender].bidRate / (minRentalDayDivisor) >
            user[_msgSender].deposit
        ) {
            isForeclosed[_msgSender] = true;
            isForeclosed[_msgSender] = orderbook.removeUserFromOrderbook(
                _msgSender
            );
            emit LogUserForeclosed(_msgSender, isForeclosed[_msgSender]);
        }
    }","The `minRentalDayDivisor` is defined in `RCTreasury.sol` and copied to each market. The `minRentalDayDivisor` can be updated via `setMinRental`, but then it isn't updated in the already created market. To calculate the minimum rent time, in function `withdrawDeposit` of `RCTreasury.sol`, the latest version of `minRentalDayDivisor` is used, which could be different than the values in the market. So the markets will calculate the minimum rent time different. This could lead to unexpected results.","The `setMinRental` function allows an owner of the contract to update the value of `minRentalDayDivisor`. However, this variable does not get updated anywhere else so it will remain as whatever was initially set when the contract was deployed. As a result, any users who try to withdraw funds after updating the divisor will be prevented from doing so because the check that ensures they haven’t been foreclosed yet will fail. Users can also lose out on rewards or fees since these amounts are calculated based off of the previous value of `minRentalDayDivisor`, which may lead to them being unable to claim their fair share of these tokens."
"function _executeInflationRateUpdate() internal returns (bool) {
        totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));
        lastEvent = block.timestamp;
        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {
            currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);
            if (initialPeriodEnded) {
                currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(
                    annualInflationDecayKeeper
                );
                currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(
                    annualInflationDecayAmm
                );
            } else {
                currentInflationAmountKeeper =
                    initialAnnualInflationRateKeeper /
                    _INFLATION_DECAY_PERIOD;

                currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;
                initialPeriodEnded = true;
            }
            currentTotalInflation =
                currentInflationAmountLp +
                currentInflationAmountKeeper +
                currentInflationAmountAmm;
            controller.inflationManager().checkpointAllGauges();
            lastInflationDecay = block.timestamp;
        }
        return true;
    }","The actual total supply of the token is random and depends on when `_executeInflationRateUpdate` is executed.

The `README` and tokenomic documentation clearly states that “The token supply is limited to a total of 268435456 tokens.” However when executing `_executeInflationRateUpdate`, it first uses the current inflation rate to update the total available before checking if it needs to be reduced.

Therefore if no one mints or calls `executeInflationRateUpdate` for some time around the decay point, the inflation will be updated using the previous rate so the  `totalAvailableToNow` will grow too much.","The `Inflation._executeInflationRateUpdate` function updates the inflation rate of each type (`lptoken`, `keeper`, `amm`) by multiplying it with a decay factor, which is calculated as follows:
```solidity
// @audit this calculation assumes that there's no time skips between calls to `_updateInflationRates`. If there were any time skips, then the actual decay would be less than what was intended. See issue #104 for more details.
uint256 annualInflationDecayLp = (_INFLATION_STARTING_PERCENTAGE - _INFLATION_FINAL_PERCENTAGE) / _INFLATION_RAMP_TIME; // e.g., 3% -> 1%, over 7 years
if (!initialPeriodEnded) {
    uint256 annualInflationDecayKeeper = initialAnnualInflationRateKeeper / _INFLATION_DECAY_PERIOD;
    uint256 annualInflationDecayAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;
}
```
However, these values are not updated when the ramp period ends or when the inflation manager is redeployed. As a result, the decay factors will remain at their original value even after the ramp period has ended.

This means that once the ramp period has ended, the inflation rates will never decrease again. In other words, the final inflation rate will always equal the starting inflation rate.

#### Impact
As a result, the inflation rate will stay constant forever, effectively disabling the functionality of updating the inflation rate.

### Proof of Concept
We can see from the test case below that the inflation rate does indeed stay constant despite calling `_executeInflationRateUpdate()` multiple times.

Note that the first call to `_executeInflationRateUpdate()` sets up the state variables correctly but subsequent calls do nothing because the decay factors have already been set.

```solidity
function testInflationRateStaysConstantAfterInitialization() public {
    vm.startPrank(_owner());
    assertEq(controller.getCurrentInflationRate(), 0);
    controller.setTargetPrice(1e18);
    controller.initializeInflationRates();
    assertEq(controller.getCurrentInflationRate(), 3000);
    controller.inflationManager()._executeInflationRateUpdate();
    assertEq(controller.getCurrentInflationRate(), 3000);
    controller.inflationManager()._executeInflationRateUpdate();
    assertEq(controller.getCurrentInflationRate(), 3000);
    stopPrank();
}
```"
"function _beforeTokenTransfer(address from, address to, uint256 amount) internal override { 
        _moveDelegates(from, _delegates[to], amount);
        super._beforeTokenTransfer(from, to, amount);
    }","When minting / transferring / burning tokens, the `SushiToken._beforeTokenTransfer` function is called and supposed to correctly shift the voting power due to the increase/decrease in tokens for the `from` and `to` accounts.
However, it does not correctly do that, it tries to shift the votes from the `from` account, instead of the **`_delegates[from]`** account.
This can lead to transfers reverting.

#### Proof Of Concept

Imagine the following transactions on the `SushiToken` contract.
We'll illustrate the corresponding `_moveDelegates` calls and written checkpoints for each.

*   `mint(A, 1000) = transfer(0, A, 1000)` => ` _moveDelegates(0, delegates[A]=0)  ` => no checkpoints are written to anyone because delegatees are still zero
*   A delegates to A' => `_moveDelegates(0, A')` => `writeCheckpoint(A', 1000)`
*   B delegates to B' => no checkpoints are written as B has a zero balance
*   `transfer(A, B, 1000)` => `_moveDelegates(A, delegates[B] = B')` => underflows when subtracting `amount=1000` from A's non-existent checkpoint (defaults to 0 votes)

It should subtract from A's delegatee `A'`'s checkpoint instead.

#### Impact

Users that delegated votes will be unable to transfer any of their tokens.","The `ERC777` standard does not have a `_mint()` or `_burn()` function like ERC20 has. Instead it uses an external hook called `_beforeTokenTransfer()`. When minting tokens this function will be used with `amount = 0`. However, when burning tokens this function will also be used with `amount = 0`, which makes no sense as you can't burn zero tokens. As a result, there is no way for users of your token to revoke their delegated votes if they want to do so (as long as they don't transfer any tokens)."
"function removeVotes(
        address _from,
        address _to,
        uint256 _amount
    ) external override {
        address _pool = msg.sender;
        if (extensions[_pool].hasExtensionPassed) {
            return;
        }

        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;

        if (_extensionVoteEndTime != 0 && _extensionVoteEndTime <= block.timestamp) {
            if (extensions[_pool].lastVotedExtension[_from] == _extensionVoteEndTime) {
                extensions[_pool].totalExtensionSupport = extensions[_pool].totalExtensionSupport.sub(_amount);
            }

            if (extensions[_pool].lastVotedExtension[_to] == _extensionVoteEndTime) {
                extensions[_pool].totalExtensionSupport = extensions[_pool].totalExtensionSupport.add(_amount);
            }
        }
    }

function voteOnExtension(address _pool) external {
        uint256 _extensionVoteEndTime = extensions[_pool].extensionVoteEndTime;
        require(block.timestamp < _extensionVoteEndTime, 'Pool::voteOnExtension - Voting is over');

        (uint256 _balance, uint256 _totalSupply) = IPool(_pool).getBalanceDetails(msg.sender);
        require(_balance != 0, 'Pool::voteOnExtension - Not a valid lender for pool');

        uint256 _votingPassRatio = votingPassRatio;

        uint256 _lastVotedExtension = extensions[_pool].lastVotedExtension[msg.sender]; //Lender last vote time need to store it as it checks that a lender only votes once
        require(_lastVotedExtension != _extensionVoteEndTime, 'Pool::voteOnExtension - you have already voted');

        uint256 _extensionSupport = extensions[_pool].totalExtensionSupport;
        _lastVotedExtension = _extensionVoteEndTime;
        _extensionSupport = _extensionSupport.add(_balance);

        extensions[_pool].lastVotedExtension[msg.sender] = _lastVotedExtension;
        emit LenderVoted(msg.sender, _extensionSupport, _lastVotedExtension);
        extensions[_pool].totalExtensionSupport = _extensionSupport;

        if (((_extensionSupport)) >= (_totalSupply.mul(_votingPassRatio)).div(10**30)) {
            grantExtension(_pool);
        }
    }","The `Extension` contract correctly reduces votes from the `from` address of a transfer and adds it to the `to` address of the transfer (in case both of them voted on it before), but it does not rerun the voting logic in `voteOnExtension` that actually grants the extension. This leads to issues where an extension should be granted but is not:

POC

*   `to` address has 100 tokens and votes for the extension
*   `from` address has 100 tokens but does not vote for the extension and transfers the 100 tokens to `to`
*   `to` now has 200 tokens, `removeVotes` is run, the `totalExtensionSupport` is increased by 100 to 200. In theory, the threshold is reached and the vote should pass if `to` could call `voteOnExtension` again.
*   But their call to `voteOnExtension` with the new balance will fail as they already voted on it (`lastVotedExtension == _extensionVoteEndTime`). The extension is not granted.

Impact

Extensions that should be granted after a token transfer are not granted.","The `removeVotes` function of `ExtensionsManager` allows users to remove their previous extension support by calling this function with `_from`, `_to` set to themselves and an arbitrary amount (`_amount`). If they do so before the end of the voting period, then the total number of extension supporters will be reduced accordingly. However, since there's no check on whether the user has actually supported the extension or not, any user can call this function to reduce the total number of extension supporters. As a result, even though the user doesn't really want to support the extension anymore, the threshold would still be met afterward, causing the extension to pass.

Proof of Concept

Assume Alice wants to cancel her previous extension support but Bob supports the extension. We first assume that the current voting period hasn't ended yet. Then Alice calls `removeVotes` with herself as both `_from` and `_to`. Afterwards, she tries to vote again using `voteOnExtension`. Since the total number of extension supporters has been decreased, the threshold would now be met, allowing the extension to pass."
"function processYield() external override onlyAdmin {
    // Claim Rewards(CRV, CVX, Extra incentive tokens)
    address baseRewardPool = getBaseRewardPool();
    IConvexBaseRewardPool(baseRewardPool).getReward();

    // Transfer CRV to YieldManager
    address _token = _addressesProvider.getAddress('CRV');
    address _tokenFromConvex = IConvexBaseRewardPool(baseRewardPool).rewardToken();
    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);
    _transferYield(_token);

    // Transfer CVX to YieldManager
    _token = _addressesProvider.getAddress('CVX');
    _tokenFromConvex = IConvexBooster(convexBooster).minter();
    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);
    _transferYield(_token);

    // Transfer extra incentive token to YieldManager
    uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength();
    for (uint256 i = 0; i < extraRewardsLength; i++) {
      address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i);
      address _rewardToken = IRewards(_extraReward).rewardToken();
      _transferYield(_rewardToken);
    }
  }function _getAssetYields(uint256 _totalYieldAmount) internal view returns (AssetYield[] memory) {
    // Get total borrowing asset volume and volumes and assets
    (
      uint256 totalVolume,
      uint256[] memory volumes,
      address[] memory assets,
      uint256 length
    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();

    if (totalVolume == 0) return new AssetYield[](0);

    AssetYield[] memory assetYields = new AssetYield[](length);
    uint256 extraYieldAmount = _totalYieldAmount;

    for (uint256 i = 0; i < length; i++) {
      assetYields[i].asset = assets[i];
      if (i != length - 1) {
        // Distribute yieldAmount based on percent of asset volume
        assetYields[i].amount = _totalYieldAmount.percentMul(
          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)
        );
        extraYieldAmount = extraYieldAmount.sub(assetYields[i].amount);
      } else {
        // without calculation, set remained extra amount
        assetYields[i].amount = extraYieldAmount;
      }
    }

    return assetYields;
  }","Yields will not be able to be distributed to lenders because attempts to do so will revert.

The `processYield()` function loops overall of the extra rewards and transfers them

There is no guarantee that the tokens involved will be efficient in their use of gas, and there are no upper bounds on the number of extra rewards:

Even if not every extra reward token has a balance, an attacker can sprinkle each one with dust, forcing a transfer by this function

`_getAssetYields()` has a similar issue:","The `processYield` function of ConvexYieldHandler calls `_transferYield`, which transfers all the rewards from Convex's reward pool to this handler. However, it doesn't check whether there was any actual transfer or not. If the transfer failed due to insufficient allowance, then the entire yield will be lost as a result.

This issue can happen when the admin wants to claim the yield but accidentally revoked the approval before calling `processYield`. In that case, the entire yield would be lost forever."
"function activateIssuer(address issuer) external {
        activateIssuer(issuer, issuer);
    }

function activateIssuer(address issuer, address token) public {
        require(
            isTokenActivator(msg.sender),
            ""Address not authorized to activate issuers""
        );
        activeIssuers[issuer] = true;
        issuerTokens[issuer] = token;
    }

function deactivateIssuer(address issuer) external {
        require(
            isTokenActivator(msg.sender),
            ""Address not authorized to activate issuers""
        );
        activeIssuers[issuer] = false;
    }

function setLendingCap(address issuer, uint256 cap) external {
        require(
            isTokenActivator(msg.sender),
            ""not authorized to set lending cap""
        );
        lendingMeta[issuer].lendingCap = cap;
    }

function setLendingBuffer(address issuer, uint256 buffer) external {
        require(
            isTokenActivator(msg.sender),
            ""not autorized to set lending buffer""
        );
        lendingMeta[issuer].lendingBuffer = buffer;
    }

function setHourlyYieldAPR(address issuer, uint256 aprPercent) external {
        require(
            isTokenActivator(msg.sender),
            ""not authorized to set hourly yield""
        );

        HourlyBondMetadata storage bondMeta = hourlyBondMetadata[issuer];

        if (bondMeta.yieldAccumulator.accumulatorFP == 0) {
            bondMeta.yieldAccumulator = YieldAccumulator({
                accumulatorFP: FP32,
                lastUpdated: block.timestamp,
                hourlyYieldFP: (FP32 * (100 + aprPercent)) / 100 / (24 * 365)
            });
            bondMeta.buyingSpeed = 1;
            bondMeta.withdrawingSpeed = 1;
            bondMeta.lastBought = block.timestamp;
            bondMeta.lastWithdrawn = block.timestamp;
        } else {
            YieldAccumulator storage yA =
                getUpdatedHourlyYield(issuer, bondMeta);
            yA.hourlyYieldFP = (FP32 * (100 + aprPercent)) / 100 / (24 * 365);
        }
    }

function setRuntimeWeights(address issuer, uint256[] memory weights)
        external
    {
        require(
            isTokenActivator(msg.sender),
            ""not autorized to set runtime weights""
        );

        BondBucketMetadata[] storage bondMetas = bondBucketMetadata[issuer];

        if (bondMetas.length == 0) {
            // we are initializing

            uint256 hourlyYieldFP = (110 * FP32) / 100 / (24 * 365);
            uint256 bucketSize = diffMaxMinRuntime / weights.length;

            for (uint256 i; weights.length > i; i++) {
                uint256 runtime = minRuntime + bucketSize * i;
                bondMetas.push(
                    BondBucketMetadata({
                        runtimeYieldFP: (hourlyYieldFP * runtime) / (1 hours),
                        lastBought: block.timestamp,
                        lastWithdrawn: block.timestamp,
                        yieldLastUpdated: block.timestamp,
                        buyingSpeed: 1,
                        withdrawingSpeed: 1,
                        runtimeWeight: weights[i],
                        totalLending: 0
                    })
                );
            }
        } else {
            require(
                weights.length == bondMetas.length,
                ""Weights don't match buckets""
            );
            for (uint256 i; weights.length > i; i++) {
                bondMetas[i].runtimeWeight = weights[i];
            }
        }
    }function setCoolingOffPeriod(uint256 blocks) external onlyOwner {
        coolingOffPeriod = blocks;
    }

function setLeveragePercent(uint256 _leveragePercent) external onlyOwner {
        leveragePercent = _leveragePercent;
    }

function setLiquidationThresholdPercent(uint256 threshold)
        external
        onlyOwner
    {
        liquidationThresholdPercent = threshold;
    }function setTrancheShare(uint256 tranche, uint256 share)
        external
        onlyOwner
    {
        require(
            trancheMetadata[tranche].rewardShare > 0,
            ""Tranche is not initialized, please initialize first""
        );
        _setTrancheShare(tranche, share);
    }

function initTranche(uint256 tranche, uint256 share) external onlyOwner {
        TrancheMeta storage tm = trancheMetadata[tranche];
        require(tm.rewardShare == 0, ""Tranche already initialized"");
        _setTrancheShare(tranche, share);

        // simply initialize to 1.0
        tm.aggregateDailyRewardRateFP = FP32;
        allTranches.push(tranche);
    }function setPriceUpdateWindow(uint16 window) external onlyOwner {
        priceUpdateWindow = window;
    }

function setUpdateRate(uint256 rate) external onlyOwner {
        UPDATE_RATE_PERMIL = rate;
    }

function setUpdateMaxPegAmount(uint256 amount) external onlyOwner {
        UPDATE_MAX_PEG_AMOUNT = amount;
    }

function setUpdateMinPegAmount(uint256 amount) external onlyOwner {
        UPDATE_MIN_PEG_AMOUNT = amount;
    }function setCoolingOffPeriod(uint256 blocks) external onlyOwner {
        coolingOffPeriod = blocks;
    }

function setLiquidationThresholdPercent(uint256 threshold)
        external
        onlyOwner
    {
        liquidationThresholdPercent = threshold;
    }","When changing state variables events are not emitted.

The events emitted by MarginRouter don't have indexed parameter.","The `Controller` has a number of functions that allow an owner or designated user to update certain parameters on the protocol. However, these updates can be done by anyone who knows the correct parameter name and value pair. As such, it would be possible for someone with malicious intentions to repeatedly call these functions until they have achieved their desired outcome. For example, this could be used to drain funds from the treasury or steal tokens held within the system. Additionally, some of these functions do not check input values which means that incorrect inputs will cause them to revert but also allows any caller to front-run the transaction and make themselves richer at the expense of the protocol."
"function deposit(
        address _token,
        uint256 _amount
     )
        public
        override
        checkToken(_token)
        notHalted
        returns (uint256 _shares)
    {
        require(_amount > 0, ""!_amount"");

        uint256 _balance = balance();

        uint256 _before = IERC20(_token).balanceOf(address(this));
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);

        if (_amount > 0) {
            _amount = _normalizeDecimals(_token, _amount);

            if (totalSupply() > 0) {
                _amount = (_amount.mul(totalSupply())).div(_balance);
            }

            _shares = _amount;
        }

        if (_shares > 0) {
            _mint(msg.sender, _shares);
            require(totalSupply() <= totalDepositCap, "">totalDepositCap"");
            emit Deposit(msg.sender, _shares);
        }
    }

function withdrawAll(
        address _output
    )
        external
        override
    {
        withdraw(balanceOf(msg.sender), _output);
    }","The v3 vault treats all valid tokens exactly the same. Depositing 1M DAI would get the same share as depositing 1M USDT. User can withdraw their share in another token. Though there's withdrawalProtectionFee (0.1 percent), the vault is still a no slippage stable coin exchange.

Also, I notice that 3crv_token is added to the vault in the test. Treating 3crv_token and all other stable coins the same would make the vault vulnerable to flashloan attack. 3crv_token is an lp token and at the point of writing, the price of it is 1.01. The arbitrage space is about 0.8 percent and makes the vault vulnerable to flashloan attacks.

Though the team may not add crv_token and dai to the same vault, its design makes the vault vulnerable. Strategies need to be designed with super caution or the vault would be vulnerable to attackers.

Given the possibility of a flashloan attack, I consider this a high-risk issue.","The `deposit` function of `ConcentratedLiquidityPool` allows users to supply any token as long as it's whitelisted by calling the `checkToken` modifier. However, there's no way for a user to retrieve their funds from this pool because the only way to redeem shares is through the `withdraw` function which requires that `_input == ConcentratedLiquidityPool`. If an attacker supplies tokens with the intention of stealing them later on, they can do so without being detected since the protocol doesn't have any mechanism to prevent such actions."
"function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }","The `sYETIToken.lastBuyBackPrice` is set in `buyBack` and hardcoded as:

It divides the first and second return `amounts` of the swap, however, these amounts depend on the swap `path` parameter that is used by the caller.
If a swap path of length 3 is used, then this is obviously wrong.
It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).

#### Impact

The `lastBuyBackPrice` will be wrong when using a different path.
This will lead `rebase`s using a different yeti amount and the `effectiveYetiTokenBalance` being updated wrong.","The `RouterUtils._buyBack` function allows a user to specify an arbitrary `_YETIOutMin`. If this value is set too high (i.e., higher than the current market price), then it will fail with error message ""Insufficient output amount received"". However, there's no check on whether the specified `_YETIOutMin` is actually less than the current market price of ETH. As a result, users can accidentally lock up their funds by specifying a large number for `_YETIOutMin`, which would lead to them losing all their funds as they cannot withdraw any more from the contract due to insufficent balance."
"function recordKeyPurchase(
    uint _value,
    address _referrer
  )
    public
    onlyFromDeployedLock()
  {
    if(_value > 0) {
      uint valueInETH;
      address tokenAddress = IPublicLock(msg.sender).tokenAddress();
      if(tokenAddress != address(0) && tokenAddress != weth) {
        // If priced in an ERC-20 token, find the supported uniswap oracle
        IUniswapOracle oracle = uniswapOracles[tokenAddress];
        if(address(oracle) != address(0)) {
          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);
        }
      }
      else {
        // If priced in ETH (or value is 0), no conversion is required
        valueInETH = _value;
      }

      grossNetworkProduct = grossNetworkProduct + valueInETH;
      // If GNP does not overflow, the lock totalSales should be safe
      locks[msg.sender].totalSales += valueInETH;

      // Mint UDT
      if(_referrer != address(0))
      {
        IUniswapOracle udtOracle = uniswapOracles[udt];
        if(address(udtOracle) != address(0))
        {
          // Get the value of 1 UDT (w/ 18 decimals) in ETH
          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);

          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut
          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;

          // or tokensToDistribute is capped by network GDP growth
          uint maxTokens = 0;
          if (chainId > 1)
          {
            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5
            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));
            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;
          } else {
            // Mainnet: we mint new token using log curve
            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;
          }

          // cap to GDP growth!
          if(tokensToDistribute > maxTokens)
          {
            tokensToDistribute = maxTokens;
          }

          if(tokensToDistribute > 0)
          {
            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer
            uint devReward = tokensToDistribute * 20 / 100;
            if (chainId > 1)
            {
              uint balance = IMintableERC20(udt).balanceOf(address(this));
              if (balance > tokensToDistribute) {
                // Only distribute if there are enough tokens
                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);
                IMintableERC20(udt).transfer(owner(), devReward);
              }
            } else {
              // No distribnution
              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);
              IMintableERC20(udt).mint(owner(), devReward);
            }
          }
        }
      }
    }
  }","The `Unlock.recordKeyPurchase` function is called on each key purchase (`MixinPurchase.purchase`) and mints UDT tokens to the referrer. The amount to mint is based on the transaction's gas price which is controlled by the caller (purchaser):

uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;

#### Impact

Tokens can be minted by purchasing a key with themself as the referrer at a high transaction gas price. Depending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.","The `recordKeyPurchase` function of `UnlockProtocol` records a key purchase for each lock that has been purchased from. It then calculates how many UDTs will be distributed based on the current price of WETH relative to USD. However, it uses this calculation as a basis for calculating the number of UDTs to distribute without any upper bound. As such, it's possible to manipulate the protocol into giving out more than what exists within the contract.

This can happen when the following conditions hold:
*   There isn't much liquidity available for WETH/USDC pair on UniSwap
*   The price of WETH increases significantly compared to USD
*   Many users buy keys at once with their own funds

As a result, the attacker would have to pay less in terms of fees while buying keys but they could still get away with getting way more UDTs than exist in the system. They could also do so repeatedly until all the existing UDT supply gets drained."
"function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public virtual override returns (bool) {
        onlyOwnerIfPaused(4);
        super.flashLoan(receiver, token, amount, data);
    }","The LPStaking contract does not require that a stake be locked for any period of time. The LPStaking contract also does not track how long your stake has been locked. So an attacker Alice can stake, claim rewards, and unstake, all in one transaction. If Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.

The fact that the `NFTXVaultUpgradeable` contract contains a native `flashLoan` function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.

Since a flash loan will easily dwarf all of the legitimate stakers' size of stake, the contract will erroneously award nearly all of the rewards to Alice.

1.  Wait until an NFTX vault has accrued any significant amount of fees/rewards
2.  `FlashLoanBorrow` a lot of ETH using any generic flash loan provider
3.  `FlashLoanBorrow` a lot of nftx-vault-token using `NFTXVaultUpgradeable.flashLoan()`
4.  Deposit the ETH and nftx-vault-token's into Uniswap for Uniswap LP tokens by calling `Uniswap.addLiquidity()`
5.  Stake the Uniswap LP tokens in `NFTXLPStaking` by calling `NFTXLPStaking.deposit()`
6.  Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling `NFTXLPStaking.claimRewards()`
7.  Remove LP tokens from `NFTXLPStaking` by calling `NFTXLPStaking.exit()`;
8.  Withdraw ETH and nftx-vault-token's by calling `Uniswap.removeLiquidity()`;
9.  Pay back nftx-vault-token flash loan
10. Pay back ETH flash loan","The `NFTXSimpleFeeDistributor` has a `flashLoan()` function that calls the parent's implementation of it without any additional checks or restrictions. As a result, an attacker can reenter this call by using a malicious `token`. See issue page for more details."
"function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }","The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the `msg.sender` (who is the owner of the contract). The usage of `transferFrom` can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the `withdraw` function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot be withdrawn and will be locked forever in the contract.","The `withdraw` function of `PaymentSplitter` allows an attacker to steal all funds by frontrunning a deposit with a transfer from the owner's account.

Proof of Concept

1.  Alice wants to make a payment for Bob but she doesn't have enough tokens so she calls `deposit`. She waits until the transaction has been mined before making her actual payment.
2.  Eve sees that there isn't enough balance on the contract yet so she decides to call `withdraw()` which will send all the funds back to the owner (Eve).
3.  Now that Eve owns all the funds, she can front-run Alice's payment by calling `deposit()`. Since the contract now contains more than it should, Alice will be able to claim her share of the funds when she makes her payment. However, since Eve called `withdraw()`, Alice won't receive any funds as they were sent directly to Eve instead.
4.  As a result, Alice loses out on her payment because Eve was able to steal them."
"function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }","Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.

Setting the severity to medium as this is conditional to transfer flow control assumption, but the impact is the full loss of contract reward token holdings.

### Proof of Concept

Both withdraw() and deposit() have the issue, performing late accounting update and not controlling for reentrancy:

function deposit(uint256 _pid, uint256 _amount) public {
    PoolInfo storage pool = poolInfo[_pid];
    UserInfo storage user = userInfo[_pid][msg.sender];
    updatePool(_pid);
    if (user.amount > 0) {
        uint256 pending = user
            .amount
            .mul(pool.accCvxPerShare)
            .div(1e12)
            .sub(user.rewardDebt);
        safeRewardTransfer(msg.sender, pending);
    }
    pool.lpToken.safeTransferFrom(

function withdraw(uint256 _pid, uint256 _amount) public {
    PoolInfo storage pool = poolInfo[_pid];
    UserInfo storage user = userInfo[_pid][msg.sender];
    require(user.amount >= _amount, ""withdraw: not good"");
    updatePool(_pid);
    uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
        user.rewardDebt
    );
    safeRewardTransfer(msg.sender, pending);
    user.amount = user.amount.sub(_amount);
    user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
    pool.lpToken.safeTransfer(address(msg.sender), _amount);","The `deposit` and `withdraw` functions of `ConvexStakingWrapper` do not account for tokens that have a transfer fee or other restrictions on transfers. As a result, users may be unable to call these functions as they will fail due to insufficient allowances / balance checks. Additionally, this issue can lead to funds being locked up in the staking wrapper contracts which cannot be withdrawn by any means.

Proof of Concept

*   In the current implementation, there's no way to set an extra rewarder for each LP token. However, it's possible to add one through the `setExtraRewards`.
*   If you want to use the `setExtraRewards`, you must first approve the `ConvexStakingWrapper` contract to spend your LP tokens. Otherwise, when calling `deposit()`, the transaction would revert because of insufficent allowance.
*   After setting the extra rewarder, you could successfully call `deposit()` but then you couldn't call `withdraw()`. Because the `_rewarder.onReward()` function was called twice during the `deposit()` process. One time is before updating the user info, another time is after updating the user info. So the second time would always return zero value since the amount has already been updated. Therefore, the user wouldn't receive any rewards from the extra rewarder. And also, the user couldn't get his LP tokens back either."
"function withdrawGovernanceAsset(address targetContract, address asset) public virtual {
    require(
      pendingFlashDecision[targetContract][msg.sender].asset == asset &&
        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&
        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,
      ""Limbo: Flashgovernance decision pending.""
    );
    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(
      msg.sender,
      pendingFlashDecision[targetContract][msg.sender].amount
    );
    delete pendingFlashDecision[targetContract][msg.sender];
  }","The function withdrawGovernanceAsset() is vulnerable to reentrancy, which would allow the attacker to drain the balance of the flashGoverananceConfig.asset.

Note: this attack assumes the attacker may gain control of the execution flow in asset.tranfer() which is the case for many ERC20 tokens such as those that implement ERC777 but will depend on which asset is chosen in the configuration.

Proof of Concept

withdrawGovernanceAsset() does not follow the check-effects-interactions pattern as seen from the following code snippet, where an external call is made before state modifications.

```solidity
function withdrawGovernanceAsset(address targetContract, address asset) public virtual {
  require(
    pendingFlashDecision[targetContract][msg.sender].asset == asset &&
      pendingFlashDecision[targetContract][msg.sender].amount > 0 &&
      pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,
    ""Limbo: Flashgovernance decision pending.""
  );
  IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(
    msg.sender,
    pendingFlashDecision[targetContract][msg.sender].amount
  );
  delete pendingFlashDecision[targetContract][msg.sender];
}
```

The attacker can exploit this vulnerability through the following steps:

1.  assertGovernanceApproved(userA, target, false)
2.  wait for unlockTime seconds to pass
3.  withdrawGovernanceAsset(target, asset)  and gain control of the execution during asset.transfer()
4.  repeat step 3) until there balance of FlashGovernanceArbiter is less than pendingFlashDecision[target][msg.sender].amount","The `withdrawGovernanceAsset` function of `LimboDAO` allows a user who has already voted on a flash governance proposal (and lost), to retrieve their deposited tokens if they have waited long enough for the unlock time. However, this function does not check that there actually was an active flash governance proposal at all before trying to transfer out the funds. If no such proposal exists or it has been cancelled, then users will be able to call this function with any arbitrary token as the second argument, which would allow them to steal funds from other proposals by frontrunning them.

Proof of Concept

1. Alice wants to vote on a new flash governance proposal but she doesn't want to wait until the next epoch so she decides to use the current one instead. She votes yes on the proposal and locks her tokens.
2. Bob sees that he can front-run Alice's vote by creating his own proposal and voting against it while locking his tokens. He creates a new proposal and waits for the end of the current epoch.
3. When the current epoch ends, both Alice and Bob try to claim their locked tokens back. But since Bob created a proposal during the same epoch, his proposal gets executed first and his tokens get transferred away from him. Now when Alice tries to execute her proposal, she fails because there isn't any proposal anymore. And now she loses her tokens forever."
"function handleFees() private {
        if (lastFee == 0) {
            lastFee = block.timestamp;
        } else {
            uint256 startSupply = totalSupply();

            uint256 timeDiff = (block.timestamp - lastFee);
            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;
            uint256 fee = startSupply * feePct / (BASE - feePct);

            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);
            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);
            lastFee = block.timestamp;

            uint256 newIbRatio = ibRatio * startSupply / totalSupply();
            ibRatio = newIbRatio;

            emit NewIBRatio(ibRatio);
        }
    }","timeDiff * licenseFee can be greater than ONE_YEAR when timeDiff and/or licenseFee is large enough, which makes feePct to be greater than BASE so that BASE - feePct will revert on underflow.

#### Impact

Minting and burning of the basket token are being disrupted until the publisher update the licenseFee.

#### Proof of Concept

1.  Create a basket with a licenseFee of 1e19 or 1000% per year and mint 1 basket token;
2.  The basket remain inactive (not being minted or burned) for 2 months;
3.  Calling mint and burn reverts at handleFees().","The `handleFees` function of `LicenseERC721Upgradeable` does not account for any tokens that have been minted since the previous call to this function. As a result, these newly minted tokens will be subject to fees even though they were only created after the most recent call to `handleFees`.

This issue can occur when there has been no activity on the protocol for an extended period of time or when many users create their licenses at once. In either case, it's likely that the number of tokens that would otherwise accrue fees could exceed the maximum value representable by type `uint256`, causing the transaction to revert."
"function increaseApproval(address _spender, uint256 _amount) external override returns (bool) {
    require(_spender != address(0), 'SPENDER');
    require(_amount != 0, 'AMOUNT');
    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();
    sx20.allowances[msg.sender][_spender] = sx20.allowances[msg.sender][_spender].add(_amount);
    emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]);
    return true;
  }

function decreaseApproval(address _spender, uint256 _amount) external override returns (bool) {
    require(_spender != address(0), 'SPENDER');
    require(_amount != 0, 'AMOUNT');
    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();
    uint256 oldValue = sx20.allowances[msg.sender][_spender];
    if (_amount > oldValue) {
      sx20.allowances[msg.sender][_spender] = 0;
    } else {
      sx20.allowances[msg.sender][_spender] = oldValue.sub(_amount);
    }
    emit Approval(msg.sender, _spender, sx20.allowances[msg.sender][_spender]);
    return true;
  }","Usually, the functions to increase the allowance are called `increaseAllowance` and `decreaseAllowance` but in `SherXERC20` they are called `increaseApproval` and `decreaseApproval`.","The `increaseApproval` and `decreaseApproval` functions of `SherXERC20` allow a user to set an approval amount that exceeds the maximum value for type `uint256`. As a result, these functions will revert when called with such parameters. However, they do not check this condition beforehand and therefore fail silently without reverting.

This issue can be exploited by users who want to make sure their transactions succeed but don't care about any gas costs associated with it. It also allows griefing attacks on other protocols or contracts which rely on the ERC-20 standard compliant behavior of `transferFrom`, `safeTransferFrom` etc., as those calls would always revert due to the malformed approval state."
"function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }","It was observed that add function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with reward distribution

In case of duplicate lpToken, lpSupply will become incorrect (ConvexMasterChef.sol#L160), hence rewards will be calculated incorrectly

Proof of Concept

1.  Owner call add function and uses lpToken as A
2.  Owner again call add function and mistakenly provides lpToken as A
3.  Now 2 pools will be created with lpToken as A
4.  This becomes a problem while reward calculation or updatePool function which uses pool.lpToken.balanceOf(address(this)). Since both pool have same lpToken so lpSupply will be calculated as same which is wrong. Since lpSupply defines the rewardRate so this directly impact reward calculation","The `ConvexStakingWrapper.add` function allows an owner of the staking wrapper to specify a new `_rewarder`. However, it does not check that this address has been whitelisted by the current `rewardsDistributor`, which could lead to rewards being distributed to unintended addresses."
"function deposit(DepositParams calldata _params) external {
        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);
        _transferAndCheckUnderlying(_msgSender(), _params.amount);
    }

function withdraw(address _to, uint256[] memory _ids)
        external
        override(IVault)
    {
        _withdraw(_to, _ids, false);
    }

function _createDeposit(
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams[] calldata claims
    ) internal {
        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;
        else
            require(
                _lockedUntil >= block.timestamp + minLockPeriod,
                ""Vault: lock time is too small""
            );

        uint256 localTotalShares = totalShares();
        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();
        uint256 pct = 0;

        for (uint256 i = 0; i < claims.length; ++i) {
            ClaimParams memory data = claims[i];
            _createClaim(
                _depositGroupIds.current(),
                _amount,
                _lockedUntil,
                data,
                localTotalShares,
                localTotalUnderlying
            );
            pct += data.pct;
        }

        _depositGroupIds.increment();

        require(pct.is100Perc(), ""Vault: claims don't add up to 100%"");
    }

function _createClaim(
        uint256 _depositGroupId,
        uint256 _amount,
        uint256 _lockedUntil,
        ClaimParams memory _claim,
        uint256 _localTotalShares,
        uint256 _localTotalPrincipal
    ) internal {
        uint256 amount = _amount.percOf(_claim.pct);

        uint256 newShares = _computeShares(
            amount,
            _localTotalShares,
            _localTotalPrincipal
        );

        uint256 claimerId = claimers.mint(
            _claim.beneficiary,
            amount,
            newShares
        );

        uint256 tokenId = depositors.mint(
            _msgSender(),
            amount,
            claimerId,
            _lockedUntil
        );

        if (_isIntegration(_claim.beneficiary)) {
            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(
                tokenId,
                newShares,
                _claim.data
            );

            require(
                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector
            );
        }

        emit DepositMinted(
            tokenId,
            _depositGroupId,
            amount,
            newShares,
            _msgSender(),
            _claim.beneficiary,
            claimerId,
            _lockedUntil
        );
    }",In `Vault.sol` the `deposit()` function is left wide open to reentrancy attacks.  The function eventually calls `_createDeposit() => _createClaim()` which calls `depositors.mint()` which will then mint an NFT.  When the NFT is minted the sender will receive a callback which can then be used to call the `deposit()` function again before execution is finished.  An attacker can do this minting multiple NFT's for themselves.  `claimers.mint()` is also called in the same function which can also be used to call back into the deposit function before execution is complete.  Since there are several state updates before and after NFT's are minted this can be used to further manipulate the protocol like with `newShares` which is called before minting.  This is not counting what an attacker can do with cross function reentrancy entering into several other protocol functions (like withdraw) before code execution is complete further manipulating the system.,"The `deposits` of a user can be locked until some future timestamp by calling the `deposit()` function with `_lockUntil != 0`. However, this does not prevent users from making additional calls to `deposit()`, which will reset their `_lockUntil` value back to the minimum lock period (`minLockPeriod`). As a result, any existing locks that were set beforehand will expire after only one week instead of the intended duration.

Proof of Concept

*   Alice wants her funds to be locked for two weeks but accidentally sets it to one week due to an error or misunderstanding of how the protocol works. She makes a call to `deposit()`.
*   Bob sees that Alice has made a mistake and decides to take advantage of it by exploiting the issue. He sends another transaction to make a deposit on behalf of Alice using his own address as the beneficiary. Since he uses his own address as the beneficiary, he gets all the shares of the newly minted NFT.
*   After waiting out the entirety of the original locking period, Alice tries to unstake her tokens. However, since she no longer holds any shares, she cannot do so because there aren’t enough shares available to cover the number of tokens being transferred.

Impact

This allows a malicious actor to steal funds from other users who have mistakenly set their lock periods shorter than they meant to. It also prevents these users from ever recovering their stolen assets."
"function getVC() external view override returns (uint256 totalVC) {
        uint256 tokensLen = poolColl.tokens.length;
        for (uint256 i; i < tokensLen; ++i) {
            address collateral = poolColl.tokens[i];
            uint256 amount = poolColl.amounts[i];

            uint256 collateralVC = whitelist.getValueVC(collateral, amount);
            totalVC = totalVC.add(collateralVC);
        }
    }function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }","There is no upper limit on `poolColl.tokens[]`, it increments each time when a new collateral is added. Eventually, as the count of collateral increases, gas cost of smart contract calls will raise and that there is no implemented function to reduce the array size.

#### Impact

For every call  `getVC()` function which computed  contain the VC value of a given collateralAddress is listed in `poolColl.tokens[]` array, the gas consumption can be more expensive each time that a new collateral address is appended to the  array, until reaching an ""Out of Gas"" error or a ""Block Gas Limit"" in the worst scenario.","The `getVC` functions of `PoolCollateral`, `PoolDebt` and `PoolBalance` do not check if there're enough elements in their arrays. If an attacker calls these functions with a large number as the first argument, they can cause out-of-bound array accesses which lead to reentrancy exploits or DoS attacks. See issue page for more details."
"function countMemberVotes(uint _proposalID) internal returns (uint voteWeight){
        mapPID_votes[_proposalID] -= mapPIDMember_votes[_proposalID][msg.sender];
        voteWeight = iVAULT(VAULT).getMemberWeight(msg.sender);
        mapPID_votes[_proposalID] += voteWeight;
        mapPIDMember_votes[_proposalID][msg.sender] = voteWeight;
    }","Flash loans can significantly increase a single voter's weight and be used to impact the voting outcome. A voter can borrow a significant quantity of tokens to increase their voting weight in a transaction within which, they also deterministically influence the voting outcome to their choice.

This has already happened in the case of MakerDAO governance where a flash loan was used to affect voting outcome and noted by the Maker team as: “a practical example for the community that flash loans can and may impact system governance”

Given that flash loans are a noted concern, the impact of it to DAO governance which can control all critical protocol parameters should be mitigated as in other places.","The `countMemberVotes` function of `GovernorAlpha` does not check if a member has already voted on a proposal, which allows members to repeatedly cast their votes for each new proposal they create or update. As a result, this can lead to proposals being passed with an inflated number of votes."
"function issue(
        ISetToken _setToken,
        uint256 _quantity,
        address _to
    )
        external
        virtual
        nonReentrant
        onlyValidAndInitializedSet(_setToken)
    {
        require(_quantity > 0, ""Issue quantity must be > 0"");

        address hookContract = _callManagerPreIssueHooks(_setToken, _quantity, msg.sender, _to);

        _callModulePreIssueHooks(_setToken, _quantity);

        (
            uint256 quantityWithFees,
            uint256 managerFee,
            uint256 protocolFee
        ) = calculateTotalFees(_setToken, _quantity, true);

        (
            address[] memory components,
            uint256[] memory equityUnits,
            uint256[] memory debtUnits
        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityWithFees, true);

        _resolveEquityPositions(_setToken, quantityWithFees, _to, true, components, equityUnits);
        _resolveDebtPositions(_setToken, quantityWithFees, true, components, debtUnits);
        _resolveFees(_setToken, managerFee, protocolFee);

        _setToken.mint(_to, _quantity);

        emit SetTokenIssued(
            _setToken,
            msg.sender,
            _to,
            hookContract,
            _quantity,
            managerFee,
            protocolFee
        );
    }

function removeModule() external override {
        require(issuanceSettings[ISetToken(msg.sender)].moduleIssuanceHooks.length == 0, ""Registered modules must be removed."");
        delete issuanceSettings[ISetToken(msg.sender)];
    }","The `wfCash` is an `erc777` token. Users can get the control flow before sending token and after receiving tokens. This creates attack vectors that require extra caution in designing modules. Any combination of modules may lead to a possible exploit. To elaborate on the dangerousness of the re-entrancy attack, a possible scenario is presented.

Before the exploit, we first elaborate on three attack vectors:

1. The issuance module would pull tokens from the sender before minting setToken.

Assume there are three components in this set. 1. CDai. 2. wfCash  In the `_callTokensToSend`, the setToken has received `cdai` and the `totalSupply` is still the same.

2. `nonReentrant` does not protect cross-contract re-entrancy. This means, that during the `issue` of issuance module, users can trigger other modules' functions.

3. Restricted functions with `onlyManagerAndValidSet` modifier may be triggered by the exploiter as well. Manager of a setToken is usually a manager contract. Assume it's a multisig-wallet, the exploiter can front-run the execute transaction and replay the payload during his exploit. Note, a private transaction from flash-bot can still be front-run. Please refer to the uncle bandit risk.

Given the above attack vectors, the exploiter have enough weapons to exploit the `setToken` at a propriate time. Note that different combination of modules may have different exploit paths. As long as the above attack vectors remain, the setToken is vulnerable.

Assume a setToken with `CompoundLeverageModule`, `NotionalTradeModule` and `BasicIssuanceModule` with the following positions: 1. CDAI: 100  2. wfCash-DAI 100  and totalSupply = 100. The community decides to remove the `compoundLeverageModule` from the set token. Since `notionalTradeModule` can handle cDAI, the community vote to just call `removeModule` to remove `compoundLeverageModule`. The exploiter has the time to build an exploit and wait the right timing to come.

0.  The exploiter listen the manager multisig wallet.
1.  Exploiter issue 10 setToken.
2.  During the `_callTokensToSend` of `wfcash`, the totalSupply = 100, CDAI = 110, wfCash-DAI = 110.
3.  Call `sync` of `CompoundLeverageModule`. `_getCollateralPosition` get  `_cToken.balanceOf(address(_setToken)) = 110` and `totalSupply = 100` and update the `DefaultUnit` of `CETH` 1,1X.
4.  Replay multisig wallet's payload and remove `compoundLeverageModule`.
5.  The `setToken` can no longer issue / redeem as it would raise `undercollateralized` error. Further, `setValuer` would give a pumped valuation that may cause harm to other protocols.","The `removeModule` function of `Controller` does not check if there are any registered module hooks for a set token before deleting it from the mapping. If such a hook exists, this will lead to an unrecoverable loss of funds as all future calls to `issue()` or `redeem()` on that specific set token will revert due to missing settings.

This can happen when a malicious user registers a custom module with a hook but then decides to cancel their subscription without removing the hook first. As long as they keep paying fees, no one else can use these tokens anymore because the controller's state becomes corrupted."
"function updatePool(uint _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (lpSupply == 0 || pool.allocPoint == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        if(block.number >= endBlock) {
            pool.lastRewardBlock = block.number;
            return;
        }        

        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        pool.lastRewardBlock = block.number;
    }","The `updatePool` function intends to calculate the accumulated Concur rewards by tracking the number of blocks passed since the last update to correctly determine how many Concur tokens to distribute to each share. The reward distribution has a start and end block which dictates the timeframe by which rewards will be distributed to the underlying pool.

If a pool has not recently updated itself and has reached the  `block.number >= endBlock` statement in `updatePool`, then any rewards that it would normally be entitled to prior to reaching `endBlock` will not be attributed to the pool. Therefore, once rewards are no longer being distributed, pools who had not recently called `updatePool` before reaching `endBlock` are at a disadvantage as compared to more active pools.","The `updatePool` function of `MasterChef` does not check that `_pid < poolLength`. If it's called with a large enough number, it will break because there won't be any corresponding pool info for this id. It can lead to all kinds of weird errors or even loss of funds.

Proof of Concept

1.  Call `add()` with an arbitrary token address as deposit token. Let's say the last added pool has ID=5.
2.  Now call `updatePool(6)` which breaks due to out-of-bounds access on `poolInfo[i]` array."
"function _updateRewardsPerToken() internal returns (uint128) {
        RewardsPerToken memory rewardsPerToken_ = rewardsPerToken;
        RewardsPeriod memory rewardsPeriod_ = rewardsPeriod;

        // We skip the calculations if we can
        if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod_.start) return 0;
        if (rewardsPerToken_.lastUpdated >= rewardsPeriod_.end) return rewardsPerToken_.accumulated;

        // Find out the unaccounted period
        uint32 end = earliest(block.timestamp.u32(), rewardsPeriod_.end);
        uint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated; // Cast to uint256 to avoid overflows later on

        // Calculate and update the new value of the accumulator. timeSinceLastUpdated casts it into uint256, which is desired.
        rewardsPerToken_.accumulated = (rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply).u128(); // The rewards per token are scaled up for precision
        rewardsPerToken_.lastUpdated = end;
        rewardsPerToken = rewardsPerToken_;
        
        emit RewardsPerTokenUpdated(rewardsPerToken_.accumulated);

        return rewardsPerToken_.accumulated;
    }","The `ERC20Rewards._updateRewardsPerToken` function exits without updating `rewardsPerToken_.lastUpdated` if `totalSupply` is zero, i.e., if there are no tokens initially.

This leads to an error if there is an active rewards period but no tokens have been minted yet.

Example: `rewardsPeriod.start: 1 month ago`, `rewardsPeriod.end: in 1 month`, `totalSupply == 0`.

The first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case).
- `_mint` is called, calls `_updateRewardsPerToken` which short-circuits. `rewardsPerToken.lastUpdated` is still set to `rewardsPeriod.start` from the constructor. Then `_updateUserRewards` is called and does not currently yield any rewards. (because both balance and the index diff are zero). User has now minted the tokens, `totalSupply` increases and user balance is set.
- User performs a `claim`: `_updateRewardsPerToken` is called and `timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month`. Contract ""issues"" rewards for the past month. The first mintee receives all of it.

The first mintee receives all pending rewards when they should not receive any past rewards.
This can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet.
Note that `setRewards` also allows setting a date in the past which would also be fatal in this case.","In `Staking._updateRewardsPerToken`, there's a comment that says ""timeSinceLastUpdated casts it into uint256"". However, this isn't true because `timeSinceLastUpdated` is already an unsigned integer type (`uint32`). So casting it again doesn't change anything. It would be more accurate to say that `timeSinceLastUpdated` has no effect since it's already an unsigned integer type."
"function requestMint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts
    ) external virtual {
        require(!finalized(), ""Finalized"");
        address _assetAddress = vault.assetAddress();
        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            uint256 amount = amounts[i];
            require(
                mintRequests[msg.sender][tokenId] == 0,
                ""No existing request""
            );
            mintRequests[msg.sender][tokenId] = amount;
            if (is1155) {
                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    tokenId,
                    amount,
                    """"
                );
            } else {
                IERC721Upgradeable(_assetAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    tokenId
                );
            }
        }
        emit Request(msg.sender, tokenIds, amounts);
    }

function reclaimRequestedMint(uint256[] calldata tokenIds)
        external
        virtual
    {
        address _assetAddress = vault.assetAddress();
        bool _is1155 = is1155;
        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            uint256 amount = mintRequests[msg.sender][tokenId];
            require(amount > 0, ""NFTXVault: nothing to reclaim"");
            mintRequests[msg.sender][tokenId] = 0;
            approvedMints[msg.sender][tokenId] = false;
            if (_is1155) {
                IERC1155Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    msg.sender,
                    tokenId,
                    amount,
                    """"
                );
            } else {
                IERC721Upgradeable(_assetAddress).safeTransferFrom(
                    address(this),
                    msg.sender,
                    tokenId
                );
            }
        }
    }","When dealing with ERC721 (instead of 1155) the amounts array is ignored, which leads to an issue.

User can call `NFTXMintRequestEligibility.requestMint` for an ERC721 with `amounts[i] = 0`.
The `ERC721.transferFrom` is still executed but user cannot `reclaimRequestedMint` later and the NFT is stuck as it checks (`amounts[i] > 0`).

Tokens can get stuck.
Also, subscribers to `Request` event could be tricked by specifying `amounts[i] > 1` in the ERC721 case, as only one token was transferred, but the amount multiple quantities get logged.","The `requestMint` function of NFTXSimpleFunding does not check that the user has enough tokens to transfer them from themselves to the fund. If a malicious or compromised user calls this function with an invalid value for `amount`, they will be able to successfully call `reclaimRequestedMint`. As a result, their funds will be stolen by the attacker.

Proof of Concept

*   Alice wants to make a donation but accidentally sets her `amount` parameter too high. She tries to cancel it out using `reclaimRequestedMint`. However, since she did not have enough balance beforehand, the transaction reverts.
*   Bob is a malicious actor who listens to all transactions on the blockchain. He sees Alice's failed attempt at cancelling her donations. He then decides to steal Alice's assets by calling `requestMint` with an extremely large `amount` parameter. Then he waits until Alice attempts to use `reclaimRequestedMint` again. Since his transaction was successful, he now owns Alice's entire asset collection."
"function matchOrders(
        Perpetuals.Order memory order1,
        Perpetuals.Order memory order2,
        uint256 fillAmount
    ) external override onlyWhitelisted returns (bool) {
        bytes32 order1Id = Perpetuals.orderId(order1);
        bytes32 order2Id = Perpetuals.orderId(order2);
        uint256 filled1 = ITrader(msg.sender).filled(order1Id);
        uint256 filled2 = ITrader(msg.sender).filled(order2Id);

        uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);

        // settle accounts
        // note: this can revert and hence no order events will be emitted
        settle(order1.maker);
        settle(order2.maker);

        (Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(
            order1,
            order2,
            fillAmount,
            executionPrice
        );
        // validate orders can match, and outcome state is valid
        if (
            !Perpetuals.canMatch(order1, filled1, order2, filled2) ||
            !Balances.marginIsValid(
                newPos1,
                balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,
                pricingContract.fairPrice(),
                trueMaxLeverage()
            ) ||
            !Balances.marginIsValid(
                newPos2,
                balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,
                pricingContract.fairPrice(),
                trueMaxLeverage()
            )
        ) {
            // emit failed to match event and return false
            if (order1.side == Perpetuals.Side.Long) {
                emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);
            } else {
                emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);
            }
            return false;
        }

        // update account states
        balances[order1.maker].position = newPos1;
        balances[order2.maker].position = newPos2;

        // update fees
        fees =
            fees +
            // add 2 * fees since getFeeRate returns the fee rate for a single
            // side of the order. Both users were charged fees
            uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);

        // update leverage
        _updateAccountLeverage(order1.maker);
        _updateAccountLeverage(order2.maker);

        // Update internal trade state
        pricingContract.recordTrade(executionPrice);

        if (order1.side == Perpetuals.Side.Long) {
            emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);
        } else {
            emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);
        }
        return true;
    }function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)
        external
        override
    {
        require(makers.length == takers.length, ""TDR: Lengths differ"");

        // safe as we've already bounds checked the array lengths
        uint256 n = makers.length;

        require(n > 0, ""TDR: Received empty arrays"");

        for (uint256 i = 0; i < n; i++) {
            // verify each order individually and together
            if (
                !isValidSignature(makers[i].order.maker, makers[i]) ||
                !isValidSignature(takers[i].order.maker, takers[i]) ||
                !isValidPair(takers[i], makers[i])
            ) {
                // skip if either order is invalid
                continue;
            }

            // retrieve orders
            // if the order does not exist, it is created here
            Perpetuals.Order memory makeOrder = grabOrder(makers, i);
            Perpetuals.Order memory takeOrder = grabOrder(takers, i);

            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);
            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);

            uint256 makeOrderFilled = filled[makerOrderId];
            uint256 takeOrderFilled = filled[takerOrderId];

            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);

            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);
            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(
                makeOrderFilled,
                averageExecutionPrice[makerOrderId],
                fillAmount,
                executionPrice
            );
            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(
                takeOrderFilled,
                averageExecutionPrice[takerOrderId],
                fillAmount,
                executionPrice
            );

            // match orders
            // referencing makeOrder.market is safe due to above require
            // make low level call to catch revert
            // todo this could be succeptible to re-entrancy as
            // market is never verified
            (bool success, ) = makeOrder.market.call(
                abi.encodePacked(
                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,
                    abi.encode(makeOrder, takeOrder, fillAmount)
                )
            );

            // ignore orders that cannot be executed
            if (!success) continue;

            // update order state
            filled[makerOrderId] = makeOrderFilled + fillAmount;
            filled[takerOrderId] = takeOrderFilled + fillAmount;
            averageExecutionPrice[makerOrderId] = newMakeAverage;
            averageExecutionPrice[takerOrderId] = newTakeAverage;
        }
    }function canMatch(
        Order memory a,
        uint256 aFilled,
        Order memory b,
        uint256 bFilled
    ) internal view returns (bool) {
        uint256 currentTime = block.timestamp;

        /* predicates */
        bool opposingSides = a.side != b.side;
        // long order must have a price >= short order
        bool pricesMatch = a.side == Side.Long ? a.price >= b.price : a.price <= b.price;
        bool marketsMatch = a.market == b.market;
        bool makersDifferent = a.maker != b.maker;
        bool notExpired = currentTime < a.expires && currentTime < b.expires;
        bool notFilled = aFilled < a.amount && bFilled < b.amount;
        bool createdBefore = currentTime >= a.created && currentTime >= b.created;

        return
            pricesMatch && makersDifferent && marketsMatch && opposingSides && notExpired && notFilled && createdBefore;
    }","The function `matchOrders` of `TracerPerpetualSwaps.sol` doesn't check that the contract itself is indeed equal to `order1.market` and `order2.market`.

The function `executeTrade` in `Trader.sol`, which calls the `matchOrders`, can deal with multiple markets.

Suppose there would be a mistake in `executeTrade`,  or in a future version, the `matchOrders` would be done in the wrong market.

`TracerPerpetualSwaps.sol` L216

function `matchOrders`( Perpetuals.Order memory order1, Perpetuals.Order memory order2, uint256 fillAmount )

`Trader.sol` L67

function `executeTrade`(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external  override {
...
    (bool success, ) = makeOrder.market.call(
    abi.encodePacked(
        ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,
        abi.encode(makeOrder, takeOrder, fillAmount)
    )
);

`LibPerpetuals.sol` L128

function canMatch( Order memory a, uint256 aFilled,Order memory b, uint256 bFilled ) internal view returns (bool) {
    ...
        bool marketsMatch = a.market == b.market;","The `matchOrders` function of `TracerPerpetualSwaps` calls out to another contract (`a.market`) which may revert. If so, then the transaction reverts and there is no way to determine what happened or how much was traded. In particular, the `emit MatchedOrders(...)` statement at the end of the function would still run even though nothing actually occurred. As a result, the user who called `matchOrders` believes they successfully matched two orders when in fact nothing did happen."
"function getInitialUnstakeEntry(address _staker, IERC20 _token)
    external
    view
    override
    returns (uint256)
  {
    PoolStorage.Base storage ps = baseData();
    GovStorage.Base storage gs = GovStorage.gs();
    for (uint256 i = 0; i < ps.unstakeEntries[_staker].length; i++) {
      if (ps.unstakeEntries[_staker][i].blockInitiated == 0) {
        continue;
      }
      if (
        ps.unstakeEntries[_staker][i].blockInitiated + gs.unstakeCooldown + gs.unstakeWindow <=
        uint40(block.number)
      ) {
        continue;
      }
      return i;
    }
    return ps.unstakeEntries[_staker].length;
  }

function activateCooldown(uint256 _amount, IERC20 _token) external override returns (uint256) {
    require(_amount > 0, 'AMOUNT');
    PoolStorage.Base storage ps = baseData();

    ps.lockToken.safeTransferFrom(msg.sender, address(this), _amount);
    uint256 fee = _amount.mul(ps.activateCooldownFee).div(uint32(-1));
    if (fee > 0) {
      // stake of user gets burned
      // representative amount token get added to first money out pool
      uint256 tokenAmount = fee.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());
      ps.firstMoneyOut = ps.firstMoneyOut.add(tokenAmount);

      ps.lockToken.burn(address(this), fee);
    }

    ps.unstakeEntries[msg.sender].push(
      PoolStorage.UnstakeEntry(uint40(block.number), _amount.sub(fee))
    );

    return ps.unstakeEntries[msg.sender].length - 1;
  }","The functions `getInitialUnstakeEntry` contains a for loop that can be unbounded. This would mean it could run out of gas and the function would revert. The array `unstakeEntries` can be made arbitrarily large by repeatedly calling activateCooldown with a small amount of tokens.

The impact is very low because the array `unstakeEntries` is separated per user and links to `msg.sender`, so you can only shoot yourself in your foot.

Additionally the function `getInitialUnstakeEntry` isn't used in the smart contracts.","The `getInitialUnstakeEntry` function iterates over all unstakes entries of a specific `_staker`. If an entry has already been processed by calling `processUnstake`, it will be skipped as indicated by `entry.blockProcessed != 0`. However, this does not mean that the entry can simply be ignored because it was previously processed. An attacker could front-run the call to `processUnstake` and set up their own unstaking entry with a higher block number than the one being processed. As a result, they would receive tokens from the protocol before the original owner did.

Proof of Concept

*   Alice calls `activateCooldown()` on behalf of Bob. She sets up her own unstaking entry with a high block number.
*   Charlie calls `processUnstake()`. He processes Alice's entry but fails to process Bob's entry since he believes it has already been processed.
*   Charlie then distributes rewards to users who have called `activateCooldown()`, including himself.
*   Now that Charlie has received his share of the rewards, he calls `withdrawRewards()`. Since he has already claimed his rewards, there should be no more funds available to him. However, due to the exploit, he receives tokens from the protocol even though he had nothing left to claim."
"function _calcRewardIntegral(
        uint256 _pid,
        uint256 _index,
        address _account,
        uint256 _balance,
        uint256 _supply
    ) internal {
        RewardType memory reward = rewards[_pid][_index];

        //get difference in balance and remaining rewards
        //getReward is unguarded so we use remaining to keep track of how much was actually claimed
        uint256 bal = IERC20(reward.token).balanceOf(address(this));
        uint256 d_reward = bal - reward.remaining;
        // send 20 % of cvx / crv reward to treasury
        if (reward.token == cvx || reward.token == crv) {
            IERC20(reward.token).transfer(treasury, d_reward / 5);
            d_reward = (d_reward * 4) / 5;
        }
        IERC20(reward.token).transfer(address(claimContract), d_reward);

        if (_supply > 0 && d_reward > 0) {
            reward.integral =
                reward.integral +
                uint128((d_reward * 1e20) / _supply);
        }

        //update user integrals
        uint256 userI = userReward[_pid][_index][_account].integral;
        if (userI < reward.integral) {
            userReward[_pid][_index][_account].integral = reward.integral;
            claimContract.pushReward(
                _account,
                reward.token,
                (_balance * (reward.integral - userI)) / 1e20
            );
        }

        //update remaining reward here since balance could have changed if claiming
        if (bal != reward.remaining) {
            reward.remaining = uint128(bal);
        }

        rewards[_pid][_index] = reward;
    }

function _checkpoint(uint256 _pid, address _account) internal {
        //if shutdown, no longer checkpoint in case there are problems
        if (paused()) return;

        uint256 supply = _getTotalSupply(_pid);
        uint256 depositedBalance = _getDepositedBalance(_pid, _account);

        IRewardStaking(convexPool[_pid]).getReward(address(this), true);

        uint256 rewardCount = rewards[_pid].length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);
        }
    }","If deposits and withdraws are done frequently enough, the reward update operation they invoke will deal mostly with the case when there is nothing to add yet, i.e. `reward.remaining` match the reward token balance.

If reward token doesn't allow for zero value transfers, the reward update function will fail on an empty incremental reward transfer, which is now done unconditionally, reverting the caller deposit/withdrawal functionality

Proof of Concept

When ConvexStakingWrapper isn't paused, every deposit and withdraw update current rewards via `_checkpoint` function before proceeding:

ConvexStakingWrapper.sol#L233

ConvexStakingWrapper.sol#L260

`_checkpoint` calls `_calcRewardIntegral` for each of the reward tokens of the pid:

ConvexStakingWrapper.sol#L220

`_calcRewardIntegral` updates the incremental reward for the token, running the logic even if reward is zero, which is frequently the case:

ConvexStakingWrapper.sol#L182

If the reward token doesn't allow zero value transfers, this transfer will fail, reverting the corresponding deposit or withdraw.","The `ConvexStakingWrapper._checkpoint` function calls `_calcRewardIntegral`, which transfers a portion of the current reward token balance to the `claimContract`. However, it does not update the stored value of `reward.remaining` with this new amount transferred out. As a result, when calling `IRewardStaking(convexPool[_pid]).getReward(address(this), true);` again later on in the same transaction, an incorrect number of tokens will be sent back to the staking wrapper as part of the reward distribution. These extra tokens can then be pulled by anyone who has called `deposit()` or `withdraw()`."
"function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {
        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);

        // Swap
        _executeSwaps(_lifiData, _swapData);

        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;

        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }","Every function that stems from the `GenericSwapFacet` lacks checks to ensure that some tokens have been returned via the swaps. In `LibSwap.sol` in the `swap()` function, the swap call is sent to the target DEX. A return of success is required, otherwise the operation will revert.

Each ""inner"" swap via `LibSwap.sol` lacks output checks and also the ""outer"" `swapTokensGeneric()` via `GenericSwapFacet.sol` lacks a final check as well.

There is a possibility that the calldata is accidently populated with a function in the target router that is not actually performing any swapping functionality, `getAmountsOut()` for example. The function will return true, but no new returned tokens will be present in the contract. Meanwhile, the contract has already received the user's `fromTokens` directly.","The `LibLifi` functions that perform swaps (`_executeSwaps`, `swapTokensGeneric`) do not check if a user has enough tokens for the swap. If they don't have any tokens (or even less than the slippage tolerated by the pool), then the transaction will revert with an error like ""SafeMath: subtraction overflow"".

This issue affects all the functions of this type because it happens when checking the balance before performing the swap. It can be exploited by attackers who want to prevent users from using these functions."
"function addSafeAddress(address account) external onlyOwner {
        safeAddresses[account] = true;
        emit LogNewSafeAddress(account);
    }

function eoaOnly(address sender) public override {
        if (preventSmartContracts && !safeAddresses[tx.origin]) {
            require(sender == tx.origin, ""EOA only"");
        }
    }","The `addSafeAddress()` takes an address and adds it to a “safe list"". This is used in `eoaOnly()` to give exemption to safe addresses that are trusted smart contracts, when all other smart contacts are prevented from protocol interaction. The stated purpose is to allow only such partner/trusted smart contract integrations (project rep mentioned Argent wallet as the only one for now but that may change) an exemption from potential flash loan threats.

The `eoaOnly()` check used during deposits and withdrawals checks if `preventSmartContracts` is enabled and if so, makes sure the transaction is coming from an integration/partner smart contract. But instead of using `msg.sender` in the check it uses `tx.origin`. This is suspect because `tx.origin` gives the originating EOA address of the transaction and not a smart contract’s address. (This may get even more complicated with the proposed EIP-3074.)

Discussion with the project team indicated that this is indeed not the norm but is apparently the case for their only current (none others planned) integration with Argent wallet where the originating account is Argent’s relayer `tx.origin` i.e. flow:
> Argent relayer (`tx.origin`) => Argent user wallet (`msg.sender`) => gro protocol while the typically expected flow is: user EOA (`tx.origin`) => proxy (`msg.sender`) => gro protocol.

While this has reportedly been verified and tested, it does seem strange and perhaps warrants a re-evaluation because the exemption for this/other trusted integration/partner smart contracts will not work otherwise.

Scenario: Partner contract is added to the safe address for exemption but the integration fails because of the use of `tx.origin` instead of `msg.sender`. See `Controller.sol` lines 266-272, 176-178, and 171-174.","The `addSafeAddress` function of `AccessControlled` allows an owner to mark any address as a safe one. However, this can be done by anyone who has access to the `onlyOwner` modifier on that function. An attacker could then call this function with their own address which would allow them to use the system without being flagged for EOAs."
"function safetyCheck() external view override returns (bool) {
        for (uint256 i = 1; i < N_COINS; i++) {
            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));
            _ratio = abs(int256(_ratio - lastRatio[i]));
            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {
                return false;
            }
        }
        return true;
    }

function _updateRatios(uint256 tolerance) private returns (bool) {
        uint256[N_COINS] memory chainRatios = getTokenRatios(0);
        uint256[N_COINS] memory newRatios;
        for (uint256 i = 1; i < N_COINS; i++) {
            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));
            uint256 check = abs(int256(_ratio) - int256(chainRatios[i].div(CHAIN_FACTOR)));
            if (check.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > tolerance) {
                return false;
            } else {
                newRatios[i] = _ratio;
            }
        }
        for (uint256 i = 1; i < N_COINS; i++) {
            lastRatio[i] = newRatios[i];
        }
        return true;
    }","The values of `lastRatio` in the contract `Buoy3Pool.sol` are not initialized (thus they have a value of 0). If `safetyCheck()` would be called before the first time `_updateRatios` is called, then `safetyCheck()` would give unexpected results.","The `safetyCheck` function of `CurveHelper` checks that all tokens have a small enough price change compared to their previous value, but it does not update these values before checking them. As a result, this function will always fail on the first call after deployment or when the pool has been updated with a large number of swaps since the last time it was checked.

This issue can be exploited by flashloans to steal funds from the protocol as they would otherwise be considered safe. It's unclear how much damage could be done due to the lack of updates between calls, but it seems likely that a significant amount of funds could be stolen over time."
"function mint(uint256 amount) public override {
        mintTo(amount, msg.sender);
    }

function pullUnderlying(uint256 amount, address from) private {
        for (uint256 i = 0; i < weights.length; i++) {
            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;
            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);
        }
    }","If a user is minting small amount of shares (like 1 - amount depends on baskets weights), the calculated amount of tokens to pull from the user can be less than 1, and therefore no tokens will be pulled. However the shares would still be minted.
If the user does this a few times, he could then withdraw the total minted shares and end up with more tokens than he started with - although a miniscule amount.

#### Impact

User can end up with more tokens than he started with. However, I didn't find a way for the user to get an amount to make this a feasible attack. He gets dust. However he can still get more than he deserves. If for some reason the basket weights grow in a substantial amount, this could give the user more tokens that he didn't pay for.

#### Proof of Concept

Add the following test to `Basket.test.js`.
The user starts with 5e18 UNI, 1e18 COMP, 1e18 AAVE,
and ends with 5e18+4, 1e18+4, 1e18+4.

    it(""should give to user more than he deserves"", async () => {
        await UNI.connect(owner).mint(ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));
        await COMP.connect(owner).mint(ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));
        await AAVE.connect(owner).mint(ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));

        await UNI.connect(owner).approve(basket.address, ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));
        await COMP.connect(owner).approve(basket.address, ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));
        await AAVE.connect(owner).approve(basket.address, ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));

        console.log(""User balance before minting:"");
        console.log(""UNI balance: "" + (await UNI.balanceOf(owner.address)).toString());
        console.log(""COMP balance: "" + (await COMP.balanceOf(owner.address)).toString());
        console.log(""AAVE balance: "" + (await AAVE.balanceOf(owner.address)).toString());

        
        await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));
        await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));
        await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));
        await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));
        await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));

        console.log(""\nUser balance after minting 1 share 5 times:"");
        console.log(""UNI balance: "" + (await UNI.balanceOf(owner.address)).toString());
        console.log(""COMP balance: "" + (await COMP.balanceOf(owner.address)).toString());
        console.log(""AAVE balance: "" + (await AAVE.balanceOf(owner.address)).toString());

        await basket.connect(owner).burn(await basket.balanceOf(owner.address));
        console.log(""\nUser balance after burning all shares:"");
        console.log(""UNI balance: "" + (await UNI.balanceOf(owner.address)).toString());
        console.log(""COMP balance: "" + (await COMP.balanceOf(owner.address)).toString());
        console.log(""AAVE balance: "" + (await AAVE.balanceOf(owner.address)).toString());
    });

#### Tools Used

Manual analysis, hardhat.","The `mint` function of `ConvexYPoolWrapper` calls `pullUnderlying`, which transfers tokens from a user's account without first approving it on the Convex Yield Pool. If any of these tokens have fees or restrictions that prevent them being transferred by anyone other than their owner, then this will fail. Additionally, if there are any tokens with transfer-on-fee protections like USDT, they would also be unable to be pulled as well."
"function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {
        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,
        ""NFTLoanFacilitator: borrow ticket holder only"");

        Loan storage loan = loanInfo[loanId];
        require(loan.lastAccumulatedTimestamp == 0, ""NFTLoanFacilitator: has lender, use repayAndCloseLoan"");
        
        loan.closed = true;
        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);
        emit Close(loanId);
    }","The `sendCollateralTo` will receive the collateral NFT when `closeLoan()` is called. However, if `sendCollateralTo` is a contract address that does not support ERC721, the collateral NFT can be frozen in the contract.

As per the documentation of EIP-721:

> A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.","The `closeLoan` function of NFTLoanFacet allows a borrower to close their position without paying back any debt or transferring collateral tokens to another account (the default value for this parameter is the zero-address which will revert if it's used as an EOA). However, there is no way to recover these funds from the protocol since they were transferred out of the contract by mistake. Also, the borrower can now reopen the same loan with a new set of parameters."
"function realise(address pool) external {
        uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); // Get the SPARTA value of the LP tokens
        uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); // Get the SPARTA value of the synths
        if(baseValueLP > baseValueSynth){
            uint premium = baseValueLP - baseValueSynth; // Get the premium between the two values
            if(premium > 10**18){
                uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); // Get the LP value of the premium
                mapSynth_LPBalance[pool] -= premiumLP; // Reduce the LP balance
                Pool(pool).burn(premiumLP); // Burn the premium of the LP tokens
            }
        }
    }","Synth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack. `Synth`'s lp is subject to `realise` whenever the AMM ratio is different than Synth's debt ratio.

The attack does not necessarily require a flash loan. A big whale of the lp token holders could keep calling `realise` by shifting token ratio of AMM pool back and forth.

The vulnerability is located at `Synth.sol` L187-L199. Where the formula in `Utils.sol` L114-L126 is dangerous.

Here's a script for conducting flashloan attack:
```python
flashloan_amount = init_amount
user = w3.eth.accounts[0]
marked_token.functions.transfer(user, flashloan_amount).transact()
marked_token.functions.transfer(token_pool.address, flashloan_amount).transact({'from': user})
token_pool.functions.addForMember(user).transact({'from': user})
received_lp = token_pool.functions.balanceOf(user).call()
synth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()
token_synth.functions.realise(token_pool.address).transact()
token_pool.functions.transfer(token_pool.address, received_lp).transact({'from': user})
token_pool.functions.removeForMember(user).transact({'from': user})
token_synth.functions.realise(token_pool.address).transact()
synth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()
print('synth_lp_balance_after_realise', synth_balance_after_realise)
print('synth_lp_balance_before_realise', synth_balance_before_realise)
```
Output:
```
synth_balance_after_realise 1317859964829313908162
synth_balance_before_realise 2063953488372093023256
```

Calculating Lp token's value base on AMM protocol is known to be dangerous.","The `realise` function of `PoolCache` does not check that there's enough liquidity available for burning. If it tries to burn more than what exists, the transaction will fail.

This can happen when a user deposited their funds at an earlier time (and thus received fewer shares), but then the price went up so much that they want to withdraw all their share now. In this case, the cache would try to burn too many shares from the pool, which would revert the transaction."
"function _setYieldSource(IYieldSource _newYieldSource) internal {
    _requireDifferentYieldSource(_newYieldSource);
    require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""SwappableYieldSource/different-deposit-token"");

    yieldSource = _newYieldSource;
    IERC20Upgradeable(_newYieldSource.depositToken()).safeApprove(address(_newYieldSource), type(uint256).max);

    emit SwappableYieldSourceSet(_newYieldSource);
  }","The function initialize of `SwappableYieldSource` checks that the yield source is valid via `_requireYieldSource`. When you change the yield source (via `swapYieldSource` or `setYieldSource`), then the function `_setYieldSource` is called. However `_setYieldSource` doesn't explicitly check the yield source via `_requireYieldSource`.

The risk is low because there is an indirect check, by the following check, which only succeeds if `depositToken` is present in the new yield source:

```solidity
     require(_newYieldSource.depositToken() == yieldSource.depositToken(), ""`SwappableYieldSource`/different-deposit-token"");
```
For maintenance purposes it is more logical to always call `_requireYieldSource`, especially if the check would be made more extensive in the future.","The `yieldSource` of a `ConvexStakingWrapper` can be changed by calling `_setYieldSource`. However, this does not revoke any previous approvals for the old `yieldSource`, so it's possible that an attacker could drain funds from the staked deposits if they have been approved on both the new and old `yieldSource`.

Proof of Concept

1. Alice calls `_setYieldSource()` with a malicious `yieldSource` (e.g., one controlled by Eve).
2. Eve transfers some tokens to Alice through the `transferFrom()` method of the token contract.
3. Alice then calls `stakeDepositTokens()`, which will transfer all her tokens into the new `yieldSource`.
4. Since she has already approved the old `yieldSource`, these tokens will also get transferred out of the protocol.

As a result, Alice loses all her tokens as they were sent directly back to her address."
"function pay(PayParam calldata param)
        external 
        override 
        lock 
        returns (
            uint128 assetIn, 
            uint128 collateralOut
        ) 
    {
        require(block.timestamp < param.maturity, 'E202');
        require(param.owner != address(0), 'E201');
        require(param.to != address(0), 'E201');
        require(param.to != address(this), 'E204');
        require(param.ids.length == param.assetsIn.length, 'E205');
        require(param.ids.length == param.collateralsOut.length, 'E205');

        Pool storage pool = pools[param.maturity];

        Due[] storage dues = pool.dues[param.owner];
        require(dues.length >= param.ids.length, 'E205');

        for (uint256 i; i < param.ids.length;) {
            Due storage due = dues[param.ids[i]];
            require(due.startBlock != BlockNumber.get(), 'E207');
            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');
            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');
            due.debt -= param.assetsIn[i];
            due.collateral -= param.collateralsOut[i];
            assetIn += param.assetsIn[i];
            collateralOut += param.collateralsOut[i];
            unchecked { ++i; }
        }

        pool.state.reserves.asset += assetIn;
        pool.state.reserves.collateral -= collateralOut;

        if (collateralOut != 0) collateral.safeTransfer(param.to, collateralOut);

        if (assetIn != 0) Callback.pay(asset, assetIn, param.data);

        emit Pay(
            param.maturity, 
            msg.sender, 
            param.to, 
            param.owner, 
            param.ids, 
            param.assetsIn, 
            param.collateralsOut, 
            assetIn, 
            collateralOut
        );
    }","At L484, if there is only one `id`, and for the first and only time of the for loop, `assetIn` and `collateralOut` will be `0`, therefore `require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');` will pass.

A attacker can call `pay()` with `param.assetsIn[0] == 0` and `param.collateralsOut[i] == due.collateral`.

### Proof of Concept

The attacker can:

1.  `borrow()` `10,000 USDC` with `1 BTC` as `collateral`;
2.  `pay()` with `0 USDC` as `assetsIn` and `1 BTC` as `collateralsOut`.

As a result, the attacker effectively stole `10,000 USDC`.

in the pay() function users repay their debt and in line 364:
it decreases their debt.

lets say a user wants to repay all his debt, he calls the pay() function with his full debt.
an attacker can see it and frontrun to repay a single token for his debt (since it's likely the token uses 18 decimals, a single token is worth almost nothing)
and since your solidity version is above 0.8.0 the line:
due.debt -= assetsIn[i]; will revert due to underflow

The attacker can keep doing it everytime the user is going to pay and since 1 token is baisicly 0$ (18 decimals) the attacker doesn't lose real money

The pay() function however is still DOSable. Having the Convenience contract contain a workaround means the Convenience contract is no longer a convenience but a requirement.

A DoS on every user that repay his full debt (or enough that the difference between his total debt to what he pays his negligible)","The `Router.pay` function allows a user to withdraw their assets from an expired position by providing the corresponding NFTs as proof of ownership. However, there's no check that ensures the provided NFTs actually belong to the owner who initiated the trade. An attacker can provide any arbitrary NFTs owned by themselves or another account, effectively allowing them to steal funds from other users.

Proof of Concept

*   Alice creates a long position with 100 USDC worth of collateral at maturity T+100 days. She receives two NFTs representing her debt and collateral balances.
*   Bob tries to repay his short position using the Router.pay function but accidentally provides Alice's NFTs instead. He pays out 100 USDC worth of collateral to Alice while she only owed him 10 USDC worth of collateral.

Impact

An attacker can repeatedly perform this attack on different markets until they have stolen enough value from all users."
"function setLockTime(uint256 newLockTime) external onlyOwner {
    require(newLockTime <= 7 days, ""Lock too long"");
    lockTime = newLockTime;
  }

function addLiquidity721(
    uint256 vaultId, 
    uint256[] memory ids, 
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity721To(vaultId, ids, minWethIn, wethIn, msg.sender);
  }

function addLiquidity1155(
    uint256 vaultId, 
    uint256[] memory ids,
    uint256[] memory amounts,
    uint256 minWethIn,
    uint256 wethIn
  ) public returns (uint256) {
    return addLiquidity1155To(vaultId, ids, amounts, minWethIn, wethIn, msg.sender);
  }

receive() external payable {

  }function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {
    __Pausable_init();
    setTreasuryAddress(_treasury);
    setLPStakingAddress(_lpStaking);

    _addReceiver(0.8 ether, lpStaking, true);
  }

function addReceiver(uint256 _allocPoint, address _receiver, bool _isContract) external override virtual onlyOwner  {
    _addReceiver(_allocPoint, _receiver, _isContract);
  }

function initializeVaultReceivers(uint256 _vaultId) external override {
    require(msg.sender == nftxVaultFactory, ""FeeReceiver: not factory"");
    INFTXLPStaking(lpStaking).addPoolForVault(_vaultId);
    if (inventoryStaking != address(0))
      INFTXInventoryStaking(inventoryStaking).deployXTokenForVault(_vaultId);
  }

function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    allocTotal -= feeReceiver.allocPoint;
    feeReceiver.allocPoint = _allocPoint;
    allocTotal += _allocPoint;
    emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);
  }

function changeReceiverAddress(uint256 _receiverIdx, address _address, bool _isContract) public override virtual onlyOwner {
    FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];
    address oldReceiver = feeReceiver.receiver;
    feeReceiver.receiver = _address;
    feeReceiver.isContract = _isContract;
    emit UpdateFeeReceiverAddress(oldReceiver, _address);
  }

function removeReceiver(uint256 _receiverIdx) external override virtual onlyOwner {
    uint256 arrLength = feeReceivers.length;
    require(_receiverIdx < arrLength, ""FeeDistributor: Out of bounds"");
    emit RemoveFeeReceiver(feeReceivers[_receiverIdx].receiver);
    allocTotal -= feeReceivers[_receiverIdx].allocPoint;
    // Copy the last element to what is being removed and remove the last element.
    feeReceivers[_receiverIdx] = feeReceivers[arrLength-1];
    feeReceivers.pop();
  }

function setTreasuryAddress(address _treasury) public override onlyOwner {
    require(_treasury != address(0), ""Treasury != address(0)"");
    treasury = _treasury;
    emit UpdateTreasuryAddress(_treasury);
  }

function setLPStakingAddress(address _lpStaking) public override onlyOwner {
    require(_lpStaking != address(0), ""LPStaking != address(0)"");
    lpStaking = _lpStaking;
    emit UpdateLPStakingAddress(_lpStaking);
  }

function setInventoryStakingAddress(address _inventoryStaking) public override onlyOwner {
    inventoryStaking = _inventoryStaking;
    emit UpdateInventoryStakingAddress(_inventoryStaking);
  }

function setNFTXVaultFactory(address _factory) external override onlyOwner {
    nftxVaultFactory = _factory;
    emit UpdateNFTXVaultFactory(_factory);
  }

function pauseFeeDistribution(bool pause) external onlyOwner {
    distributionPaused = pause;
    emit PauseDistribution(pause);
  }

function rescueTokens(address _address) external override onlyOwner {
    uint256 balance = IERC20Upgradeable(_address).balanceOf(address(this));
    IERC20Upgradeable(_address).safeTransfer(msg.sender, balance);
  }function __NFTXVault_init(
        string memory _name,
        string memory _symbol,
        address _assetAddress,
        bool _is1155,
        bool _allowAllItems
    ) public override virtual initializer {
        __Ownable_init();
        __ERC20_init(_name, _symbol);
        require(_assetAddress != address(0), ""Asset != address(0)"");
        assetAddress = _assetAddress;
        vaultFactory = INFTXVaultFactory(msg.sender);
        vaultId = vaultFactory.numVaults();
        is1155 = _is1155;
        allowAllItems = _allowAllItems;
        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
    }

function finalizeVault() external override virtual {
        setManager(address(0));
    }

function setVaultMetadata(
        string memory name_, 
        string memory symbol_
    ) public override virtual {
        onlyPrivileged();
        _setMetadata(name_, symbol_);
    }

function setVaultFeatures(
        bool _enableMint,
        bool _enableRandomRedeem,
        bool _enableTargetRedeem,
        bool _enableRandomSwap,
        bool _enableTargetSwap
    ) public override virtual {
        onlyPrivileged();
        enableMint = _enableMint;
        enableRandomRedeem = _enableRandomRedeem;
        enableTargetRedeem = _enableTargetRedeem;
        enableRandomSwap = _enableRandomSwap;
        enableTargetSwap = _enableTargetSwap;

        emit EnableMintUpdated(_enableMint);
        emit EnableRandomRedeemUpdated(_enableRandomRedeem);
        emit EnableTargetRedeemUpdated(_enableTargetRedeem);
        emit EnableRandomSwapUpdated(_enableRandomSwap);
        emit EnableTargetSwapUpdated(_enableTargetSwap);
    }

function assignDefaultFeatures() external {
        require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, ""Not dev"");
        enableRandomSwap = enableRandomRedeem;
        enableTargetSwap = enableTargetRedeem;
        emit EnableRandomSwapUpdated(enableRandomSwap);
        emit EnableTargetSwapUpdated(enableTargetSwap);
    }

function setFees(
        uint256 _mintFee,
        uint256 _randomRedeemFee,
        uint256 _targetRedeemFee,
        uint256 _randomSwapFee,
        uint256 _targetSwapFee
    ) public override virtual {
        onlyPrivileged();
        vaultFactory.setVaultFees(vaultId, _mintFee, _randomRedeemFee, _targetRedeemFee, _randomSwapFee, _targetSwapFee);
    }

function disableVaultFees() public override virtual {
        onlyPrivileged();
        vaultFactory.disableVaultFees(vaultId);
    }

function deployEligibilityStorage(
        uint256 moduleIndex,
        bytes calldata initData
    ) external override virtual returns (address) {
        onlyPrivileged();
        require(
            address(eligibilityStorage) == address(0),
            ""NFTXVault: eligibility already set""
        );
        INFTXEligibilityManager eligManager = INFTXEligibilityManager(
            vaultFactory.eligibilityManager()
        );
        address _eligibility = eligManager.deployEligibility(
            moduleIndex,
            initData
        );
        eligibilityStorage = INFTXEligibility(_eligibility);
        // Toggle this to let the contract know to check eligibility now.
        allowAllItems = false;
        emit EligibilityDeployed(moduleIndex, _eligibility);
        return _eligibility;
    }

function setManager(address _manager) public override virtual {
        onlyPrivileged();
        manager = _manager;
        emit ManagerSet(_manager);
    }

function mint(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts /* ignored for ERC721 vaults */
    ) external override virtual returns (uint256) {
        return mintTo(tokenIds, amounts, msg.sender);
    }

function redeem(uint256 amount, uint256[] calldata specificIds)
        external
        override
        virtual
        returns (uint256[] memory)
    {
        return redeemTo(amount, specificIds, msg.sender);
    }

function swap(
        uint256[] calldata tokenIds,
        uint256[] calldata amounts, /* ignored for ERC721 vaults */
        uint256[] calldata specificIds
    ) external override virtual returns (uint256[] memory) {
        return swapTo(tokenIds, amounts, specificIds, msg.sender);
    }

function flashLoan(
        IERC3156FlashBorrowerUpgradeable receiver,
        address token,
        uint256 amount,
        bytes memory data
    ) public override virtual returns (bool) {
        onlyOwnerIfPaused(4);
        return super.flashLoan(receiver, token, amount, data);
    }","The following functions are missing reentrancy modifier although some other public/external functions do use a reentrancy modifier. Even though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well.","The `nftx` protocol has a number of core components that interact with each other. One such component is the `NFTXVault`. It's important to note that there can be multiple instances of these vaults, each representing a different NFT collection. Each instance will have it's own unique identifier (`vaultId`).

One of the key functions on an NFTXVault is the ability to update certain parameters via the `setVaultFeatures()` function. These features include things like whether or not mints should be allowed, random redemptions, target redemptions, etc... However, one parameter which does **not** get updated here is the `allowAllItems` variable. If you look at the implementation of `setVaultFeatures()`, you'll see that it doesn't actually do anything with this value. As a result, anytime someone calls this function, they effectively reset all items as non-allowed again.

This isn't necessarily a huge issue because users could just call `setAllowItem()` directly instead. But since this functionality is exposed through the `setVaultFeatures()` function, it seems reasonable to assume that this would work correctly. Unfortunately, due to how the current implementation works, calling `setVaultFeatures()` will always revert when trying to set `allowAllItems=false`, even though it shouldn't.

As a result, anyone who wants to use the `assignDefaultFeatures()` function must first manually set `allowAllItems=true` before doing so. Otherwise, their transaction will fail. While this may seem trivial, it's worth considering that many people might accidentally try to run this function without realizing that it requires them to make this manual step first. In addition, it also means that the `assignDefaultFeatures()` function won't work properly unless called by the owner of the vault."
"function _handlePayment(uint256 _amount) internal {
    address recipient = royaltyVaultInitialized()
      ? royaltyVault
      : address(this);
    payableToken.transferFrom(msg.sender, recipient, _amount);
    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());
  }function withdraw() external onlyOwner {
        uint256 amount = payableToken.balanceOf(address(this));
        payableToken.transferFrom(address(this), msg.sender, amount);
        emit NewWithdrawal(msg.sender, amount);
    }","The below transferFrom command is called at two places in the core contracts, followed by an emit event

    payableToken.transferFrom(msg.sender,recipient,_amount)
    emit ...(...);

The return value is not checked during the payableToken.transferFrom

In the event of failure of payableToken.transferFrom(...), the emit event is still generated causing the downstream applications to capture wrong transaction / state of the protocol.","The `withdraw` function of `RoyaltyAware` transfers all funds from itself (`payableToken`) to the owner's account using a transfer-from call with no allowances set up for this purpose (i.e., there will be an error if any funds have been transferred before). However, it does not check that the balance is nonzero first; so, if zero tokens were ever sent to the contract, then the `withdraw` function would fail due to insufficient allowance."
"function provide(uint256 _minimumLP) external onlyGuardian {
        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, ""<liquidity"");
        // truncate amounts under step
        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;
        // match usdm : pool3 = 1 : 1
        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];
        usdm.approve(address(usdm3crv), addingLiquidity);
        pool3.approve(address(usdm3crv), addingLiquidity);
        usdm3crv.add_liquidity(amounts, _minimumLP);
    }","The `provide` function does not take a `_steps` argument and will instead calculate `addingLiquidity` by truncating amounts under `step`. As a result, if there is an excess of `usdm` such that the truncated amount exceeds the contract's `pool3` truncated balance, then the function will revert due to insufficient `pool3` collateral.

This will prevent guardians from effectively providing liquidity whenever tokens are available. Consider the following example:

*   The contract has `500000e18` `usdm` tokens and `250000e18` `pool3` tokens.
*   `addingLiquidity` will be calculated as `500000e18 / 250000e18 * 250000e18`.
*   The function will attempt to add `500000e18` `usdm` and `pool3` tokens in which there are insufficient `pool3` tokens in the contract. As a result, it will revert even though there is an abundance of tokens that satisfy the `step` amount.","The `provide` function of `USDMAllowList` calls `usdm3crv.add_liquidity`. However, it does not check if there's enough allowances for both tokens before calling this function. If one token has a smaller allowance than needed, then the transaction will fail with an error message like ""ERC20: transfer amount exceeds balance""."
"function mintSynth(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        address from,
        address to
    )
        external
        override
        nonReentrant
        supportedToken(foreignAsset)
        returns (uint256 amountSynth)
    {
        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);

        ISynth synth = synthFactory.synths(foreignAsset);

        if (synth == ISynth(_ZERO_ADDRESS))
            synth = synthFactory.createSynth(
                IERC20Extended(address(foreignAsset))
            );

        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        amountSynth = VaderMath.calculateSwap(
            nativeDeposit,
            reserveNative,
            reserveForeign
        );

        // TODO: Clarify
        _update(
            foreignAsset,
            reserveNative + nativeDeposit,
            reserveForeign,
            reserveNative,
            reserveForeign
        );

        synth.mint(to, amountSynth);
    }","The `mintSynth()` function is callable by any user and creates a synthetic asset against `foreignAsset` if it does not already exist. The protocol expects a user to first approve the contract as a spender before calling `mintSynth()`. However, any arbitrary user could monitor the blockchain for contract approvals that match `VaderPoolV2.sol` and effectively frontrun their call to `mintSynth()` by setting the `to` argument to their own address. As a result, the `nativeDeposit` amount is transferred from the victim, and a synthetic asset is minted and finally transferred to the malicious user who is represented by the `to` address.","The `Pool` contract has a function called `mintSynth`. It allows users to deposit their underlying assets into the pool and receive an equivalent number of synth tokens as reward for staking them with the protocol. However, it doesn't update the reserves correctly when calling `_update()` which leads to incorrect price calculation on future swaps. As a result, the user will not be able to withdraw his funds back from the pool anymore since he would have received fewer synth tokens than what was actually added to the pool.

Proof of Concept

*   User calls `mintSynth()`. He supplies 100 units of USDC.
*   The current reserves are 1000 units of USDC and 1000 units of vADR.
*   After updating the reserves, they become 1100 units of USDC and 900 units of vADR.
*   Now, the user receives 874 units of vADR instead of 1000 like he should.
*   If the user wants to remove all his liquidity again, he needs to supply at least 1374 units of vADR but only gets 874 back.

Impact

This issue affects any position that uses the Pool contract. Users who want to exit their positions won’t be able to do so because they don’t own enough shares. They can still burn their share token but this will lead to a loss of value due to slippage or frontrunning attacks."
"function redeemAllRewards( uint128 validatorId, address beneficiary) external {
        _redeemRewards(validatorId, beneficiary, 0);
    }","Validator can fail to receive commission reward by calling `redeemAllRewards`.
There's a check in `redeemAllRewards`

```solidity
uint128 rewards = sharesToTokens(s.shares, v.exchangeRate) - s.staked;
require(rewards > 0, ""Nothing to redeem"");
```

The validator's tx might be reverted here even if he got some commission reward to receive.

We can trigger the bug by setting `commisionRate` to `1e18 - 1` (DelegatedStaking.sol L275-L276)","The `Staking._redeemRewards` function allows a user to claim all of their outstanding rewards by setting the `_amountToClaim` parameter equal to zero (i.e., it's set as `type(uint128).max`). However, this will fail if there isn't enough balance available for the transaction because the transaction would revert due to insufficient funds. As a result, users cannot call the `redeemAllRewards()` function on behalf of another account unless they have sufficient balance or allowance."
"function getRandomTokenIdFromFund() internal virtual returns (uint256) {
        uint256 randomIndex = getPseudoRand(holdings.length());
        return holdings.at(randomIndex);
    }","`NFTXVaultUpgradeable.getRandomTokenIdFromFund` does not work with ERC1155 as it does not take the deposited `quantity1155` into account.

Assume `tokenId0` has a count of 100, and `tokenId1` has a count of 1.
Then `getRandomId` would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.

This might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.","The `getRandomTokenIdFromFund` function of `NFTXVaultUpgradeable` does not check if there's any token available for funding, which means it will revert when trying to draw a random number from an empty array. It should be checked before calling this function."
"function allocateArbRewards(uint256 rewarded)
    external
    onlyRole(STABILIZER_NODE_ROLE, ""Must be stabilizer node"")
    returns (uint256)
  {
    AuctionData storage auction = idToAuction[replenishingAuctionId];

    if (auction.finalPrice == 0 || auction.startingTime == 0) {
      return rewarded;
    }

    if (auction.commitments == 0) {
      replenishingAuctionId = replenishingAuctionId + 1;
      return rewarded;
    }

    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);

    if (auction.claimableTokens < totalTokens) {
      uint256 requirement = totalTokens.sub(auction.claimableTokens);
      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);

      if (requirement >= maxArbAllocation) {
        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);
        rewarded = rewarded.sub(maxArbAllocation);
        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);

        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);

        emit ArbTokenAllocation(
          replenishingAuctionId,
          maxArbAllocation
        );
      } else {
        auction.claimableTokens = auction.claimableTokens.add(requirement);
        rewarded = rewarded.sub(requirement);
        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);

        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);

        emit ArbTokenAllocation(
          replenishingAuctionId,
          requirement
        );
      }

      if (auction.claimableTokens == totalTokens) {
        uint256 count = 1;

        while (true) {
          auction = idToAuction[replenishingAuctionId + count];

          if (auction.commitments > 0 || !auction.finalized) {
            replenishingAuctionId = replenishingAuctionId + count;
            break;
          }
          count += 1;
        }
      }
    }

    return rewarded;
  }function _distributeRewards(uint256 rewarded) internal {
    if (rewarded == 0) {
      return;
    }
    rewardToken.approve(address(auction), rewarded);
    rewarded = auction.allocateArbRewards(rewarded);

    if (rewarded == 0) {
      return;
    }

    uint256 callerCut = rewarded.mul(callerRewardCut).div(1000);
    uint256 lpCut = rewarded.mul(lpRewardCut).div(1000);
    uint256 daoCut = rewarded.mul(daoRewardCut).div(1000);
    uint256 auctionPoolCut = rewarded.mul(auctionPoolRewardCut).div(1000);
    uint256 swingTraderCut = rewarded.mul(swingTraderRewardCut).div(1000);

    // Treasury gets paid after everyone else
    uint256 treasuryCut = rewarded - daoCut - lpCut - callerCut - auctionPoolCut - swingTraderCut;

    assert(treasuryCut <= rewarded);

    if (callerCut > 0) {
      rewardToken.safeTransfer(msg.sender, callerCut);
    }

    if (auctionPoolCut > 0) {
      rewardToken.safeTransfer(auctionPool, auctionPoolCut);
    }

    if (swingTraderCut > 0) {
      rewardToken.safeTransfer(address(swingTrader), swingTraderCut);
    }

    if (treasuryCut > 0) {
      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);
    }

    if (daoCut > 0) {
      rewardToken.safeTransfer(address(dao), daoCut);
    }

    if (lpCut > 0) {
      rewardToken.safeTransfer(address(rewardThrottle), lpCut);
      rewardThrottle.handleReward();
    }

    emit RewardDistribution(rewarded);
  }","_distributeRewards attempts to reward LP token holders when the price of Malt exceeds its price target. Malt Finance is able to being Malt back to its peg by selling Malt and distributing rewards tokens to LP token holders. An external call to Auction is made via the allocateArbRewards function. Prior to this call, the StabilizerNode approves the contract for a fixed amount of tokens, however, the allocateArbRewards function does not necessarily utilise this entire amount. Hence, dust token approval amounts may accrue from within the StabilizerNode contract.","The `StdReference` contract has a method called `_getRate()` which allows an attacker to steal all of the funds that have been sent into it by calling this function with any arbitrary token as the argument. An attacker can then call the `withdrawAllFunds()` function on the `StdReference` contract to withdraw all of these stolen tokens.

Proof of Concept

An attacker calls the `_getRate()` function on the StdReference contract with the token they want to steal from the protocol as the parameter. They will receive back a rate value equal to zero because there isn't a reference price set for this particular token yet. However, since the rate returned was not zero, the attacker knows that the user-defined reference price must now exist. Therefore, the attacker can repeat this process until they successfully get a nonzero rate value out of the `_getRate()` function. Once they do so, they know that their desired token exists within the StdReference contract. Now, the attacker simply needs to wait long enough for the attacker’s chosen token to become eligible for being used as a payout asset. After waiting some amount of time, the attacker can use the `withdrawAllFunds()` function to extract all of the funds stored inside the StdReference contract. These funds were originally deposited through the `depositCollateral()`, `depositLong`, or `depositShort` functions. As you may recall, these functions allow users to send ETH directly to the Vault contract without having to first approve the transfer. Thus, when the attacker uses the `withdrawAllFunds()` function, they will receive back all of the funds that had previously been transferred to the StdReference contract via one of those three functions."
"function mintToken(
        address to,
        bool isClaim,
        uint256 claimableAmount,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external onlyInitialized {
        require(amount > 0, ""CoreCollection: Amount should be greater than 0"");
        require(
            totalSupply() + amount <= maxSupply,
            ""CoreCollection: Over Max Supply""
        );

        if (isClaim) {
            require(claimableSet(), ""CoreCollection: No claimable"");
            require(
                canClaim(msg.sender, claimableAmount, amount, merkleProof),
                ""CoreCollection: Can't claim""
            );
            _claim(msg.sender, amount);
        } else {
            require(isForSale, ""CoreCollection: Not for sale"");
            if (mintFee > 0) {
                _handlePayment(mintFee * amount);
            }
        }

        batchMint(to, amount, isClaim);
    }","The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the `payableToken` is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because `totalSupply()` has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply` check. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.

For the sake of this example, let's say `startingIndex = 0` and `maxSupply = 100`. `tokenId` is minted according to `((startingIndex + totalSupply()) % maxSupply) + 1`. If we see that a user mints a token where `totalSupply() = maxSupply - 1 = 99` and they reenter the function, then the next token to mint will actually be of index `1` as `totalSupply() % maxSupply = 0`. Calculating the first `tokenId`, we get `((0 + 0) % maxSupply) + 1 = 1` which is a duplicate of our example.",The `batchMint` function of CoreCollection does not check that the sum of all amounts being minted by a single transaction do not exceed the maximum supply. If this happens then it will fail with an error but the tokens already minted before the failure will still have been minted.
"function rangeFeeGrowth(int24 lowerTick, int24 upperTick) public view returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {
        int24 currentTick = nearestTick;

        Ticks.Tick storage lower = ticks[lowerTick];
        Ticks.Tick storage upper = ticks[upperTick];

        /// @dev Calculate fee growth below & above.
        uint256 _feeGrowthGlobal0 = feeGrowthGlobal0;
        uint256 _feeGrowthGlobal1 = feeGrowthGlobal1;
        uint256 feeGrowthBelow0;
        uint256 feeGrowthBelow1;
        uint256 feeGrowthAbove0;
        uint256 feeGrowthAbove1;

        if (lowerTick <= currentTick) {
            feeGrowthBelow0 = lower.feeGrowthOutside0;
            feeGrowthBelow1 = lower.feeGrowthOutside1;
        } else {
            feeGrowthBelow0 = _feeGrowthGlobal0 - lower.feeGrowthOutside0;
            feeGrowthBelow1 = _feeGrowthGlobal1 - lower.feeGrowthOutside1;
        }

        if (currentTick < upperTick) {
            feeGrowthAbove0 = upper.feeGrowthOutside0;
            feeGrowthAbove1 = upper.feeGrowthOutside1;
        } else {
            feeGrowthAbove0 = _feeGrowthGlobal0 - upper.feeGrowthOutside0;
            feeGrowthAbove1 = _feeGrowthGlobal1 - upper.feeGrowthOutside1;
        }

        feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;
        feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;
    }","The function `RangeFeeGrowth` would revert the transaction in some cases.

When a pool crosses a tick, it only updates either `feeGrowthOutside0` or `feeGrowthOutside1`.

`RangeFeeGrowth` calculates the fee as follows:

```solidity
    feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;
    feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;
```

`feeGrowthBelow + feeGrowthAbove` is not necessarily smaller than `_feeGrowthGlobal`. Users cannot provide liquidity or burn liquidity. Funds will get stuck in the contract. This is considered a high-risk issue.

Proof of Concept:

```python
    # This is the wrapper.
    # def add_liquidity(pool, amount, lower, upper)
    # def swap(pool, buy, amount)

    add_liquidity(pool, deposit_amount, -800, 500)
    add_liquidity(pool, deposit_amount, 400, 700)
    # We cross the tick here to trigger the bug.

    swap(pool, False, deposit_amount)
    # Only tick 700's feeGrowthOutside1 is updated

    swap(pool, True, deposit_amount)
    # Only tick 500's feeGrowthOutside0 is updated

    # current tick at -800

    # this would revert
    # feeGrowthBelow1 = feeGrowthGlobal1
    # feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1 would revert
    # user would not be able to mint/withdraw/cross this tick. The pool is broken
    add_liquidity(pool, deposit_amount, 400, 700)
```

Tools Used: Hardhat","The `rangeFeeGrowth` function of `SwapsImpl` calculates the fee growth between two tick boundaries. It does this by subtracting the fee growth outside these bounds from the global fee growth. However, it doesn't check that the sum of all the fees within a certain range equals the total fee amount. If there was an error during updating the fee amounts or if users have been able to steal funds from the pool, then the calculated fee might be incorrect. As a result, the swap functionality will not work correctly anymore."
"function distributeMochi() external {
        // buy Mochi with mochiShare
        _buyMochi();
        _shareMochi();
    }

function _shareMochi() internal {
        IMochi mochi = engine.mochi();
        uint256 mochiBalance = mochi.balanceOf(address(this));
        // send Mochi to vMochi Vault
        mochi.transfer(
            address(engine.vMochi()),
            (mochiBalance * vMochiRatio) / 1e18
        );
        // send Mochi to veCRV Holders
        mochi.transfer(
            crvVoterRewardPool,
            (mochiBalance * (1e18 - vMochiRatio)) / 1e18
        );
        // flush mochiShare
        mochiShare = 0;
        treasuryShare = 0;
    }","distributeMochi() will call _buyMochi() to convert mochiShare to Mochi token and call _shareMochi() to send Mochi to vMochi Vault and veCRV Holders. It wont touch the treasuryShare.

However, in the current implementation, treasuryShare will be reset to 0. This is unexpected and will cause the protocol fee can not be properly accounted for and collected.

Impact
Anyone can call distributeMochi() and reset treasuryShare to 0, and then call updateReserve() to allocate part of the wrongfully resetted treasuryShare to mochiShare and call distributeMochi().

Repeat the steps above and the treasuryShare will be consumed to near zero, profits the vMochi Vault holders and veCRV Holders. The protocol suffers the loss of funds.","The `distributeMochi` function of `IndexPool` calls `_shareMochi`. In this function, it transfers a portion of the current balance of Mochi tokens held by Index Pool to the CRV voter reward pool (`crvVoterRewardPool`). However, if there isn't enough Mochi token available for transfer, then the transaction will revert. As a result, the `distributeMochi` function would fail when trying to share out the Mochi tokens to the CRV voter reward pool."
"function createVault(
        uint256 tokenIdOrAmount,
        address token,
        uint8 premiumIndex,
        uint8 durationDays,
        uint8 dutchAuctionStartingStrikeIndex,
        uint256 dutchAuctionReserveStrike,
        TokenType tokenType
    ) external returns (uint256 vaultId) {
        require(premiumIndex < premiumOptions.length, ""Invalid premium index"");
        require(dutchAuctionStartingStrikeIndex < strikeOptions.length, ""Invalid strike index"");
        require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], ""Reserve strike too small"");
        require(durationDays > 0, ""durationDays too small"");
        require(tokenType == TokenType.ERC721 || tokenType == TokenType.ERC20, ""Invalid token type"");

        Vault memory vault = Vault({
            tokenIdOrAmount: tokenIdOrAmount,
            token: token,
            premiumIndex: premiumIndex,
            durationDays: durationDays,
            dutchAuctionStartingStrikeIndex: dutchAuctionStartingStrikeIndex,
            currentExpiration: uint32(block.timestamp),
            isExercised: false,
            isWithdrawing: false,
            tokenType: tokenType,
            currentStrike: 0,
            dutchAuctionReserveStrike: dutchAuctionReserveStrike
        });

        // vault index should always be odd
        vaultIndex += 2;
        vaultId = vaultIndex;
        _vaults[vaultId] = vault;

        // give msg.sender vault token
        _mint(msg.sender, vaultId);

        emit NewVault(vaultId, msg.sender, token);

        // transfer the NFTs or ERC20s to the contract
        vault.tokenType == TokenType.ERC721
            ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)
            : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);
    }

function exercise(uint256 optionId) external payable {
        // optionId should always be even
        require(optionId % 2 == 0, ""Not option type"");

        // check owner
        require(msg.sender == ownerOf(optionId), ""You are not the owner"");

        uint256 vaultId = optionId - 1;
        Vault memory vault = _vaults[vaultId];

        // check option hasn't expired
        require(block.timestamp < vault.currentExpiration, ""Option has expired"");

        // check correct ETH amount was sent to pay the strike
        require(msg.value == vault.currentStrike, ""Incorrect ETH sent for strike"");

        // burn the option token
        _burn(optionId);

        // mark the vault as exercised
        vault.isExercised = true;
        _vaults[vaultId] = vault;

        // collect protocol fee
        uint256 fee = 0;
        if (feeRate > 0) {
            fee = (msg.value * feeRate) / 1e18;
            protocolUnclaimedFees += fee;
        }

        // increment vault beneficiary's ETH balance
        ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;

        emit ExercisedOption(optionId, msg.sender);

        // transfer the NFTs or ERC20s to the exerciser
        vault.tokenType == TokenType.ERC721
            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)
            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);
    }

function withdraw(uint256 vaultId) external nonReentrant {
        // vaultId should always be odd
        require(vaultId % 2 != 0, ""Not vault type"");

        // check owner
        require(msg.sender == ownerOf(vaultId), ""You are not the owner"");

        Vault memory vault = _vaults[vaultId];

        // check vault can be withdrawn
        require(vault.isExercised == false, ""Vault already exercised"");
        require(vault.isWithdrawing, ""Vault not in withdrawable state"");
        require(block.timestamp > vault.currentExpiration, ""Option still active"");

        // burn option and vault
        uint256 optionId = vaultId + 1;
        _burn(optionId);
        _burn(vaultId);

        emit Withdrawal(vaultId, msg.sender);

        // claim any ETH still in the account
        harvest();

        // transfer the NFTs or ERC20s back to the owner
        vault.tokenType == TokenType.ERC721
            ? ERC721(vault.token).transferFrom(address(this), msg.sender, vault.tokenIdOrAmount)
            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);
    }","Some ERC20 tokens charge a transaction fee for every transfer (used to encourage staking, add to liquidity pool, pay a fee to contract owner, etc.). If any such token is used in the `createVault()` function, either the token cannot be withdrawn from the contract (due to insufficient token balance), or it could be exploited by other such token holders and the `Cally` contract would lose economic value and some users would be unable to withdraw the underlying asset.

Plenty of ERC20 tokens charge a fee for every transfer (e.g. Safemoon and its forks), in which the amount of token received is less than the amount being sent. When a fee token is used as the `token` in the `createVault()` function, the amount received by the contract would be less than the amount being sent. To be more precise, the increase in the `cally` contract token balance would be less than `vault.tokenIdOrAmount` for such ERC20 token because of the fee.

            vault.tokenType == TokenType.ERC721
                ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)
                : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount);

The implication is that both the `exercise()` function and the `withdraw()` function are guaranteed to revert if there's no other vault in the contract that contains the same fee tokens, due to insufficient token balance in the `Cally` contract.

When an attacker observes that a vault is being created that contains such fee tokens, the attacker could create a new vault himself that contains the same token, and then withdraw the same amount. Essentially the `Cally` contract would be paying the transfer fee for the attacker because of how the token amount is recorded. This causes loss of user fund and loss of value from the `Cally` contract. It would make economic sense for the attacker when the fee charged by the token accrue to the attacker. The attacker would essentially use the `Cally` contract as a conduit to generate fee income.","The `createVault` function of `OddEth` mints a new option token that corresponds to the newly created vault. However, it does so by minting an odd numbered token which means that this token will have no corresponding vault. As such, there is no way to redeem these tokens without burning them first.

This issue arises because the `exercise` function checks whether the inputted `optionId` is even but then tries to find the associated vault using `vaultId = optionId - 1`. Since `optionId` is odd, `vaultId` will also be odd and thus there won’t exist a vault with that ID. Consequently, users who try to exercise their options will lose all funds.

Similarly, the `withdraw` function assumes that each vault has a corresponding option token but since they don’t, this function will fail when trying to burn both the option and vault tokens."
"function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }","In `HolyPaladinToken.sol` the `ONE_YEAR` variable claims that there are `31557600` seconds in a year when this is incorrect. The `ONE_YEAR` variable is used in the `getCurrentVotes()` function as well as the `getPastVotes()` function so it is vital that the correct time in seconds be used as it can effect users negatively.

Proof of Concept

86,400 seconds in a day x 365 = 31_536_000","The `ConvexStakingWrapper` allows users to delegate their vote weight to another address using the `_setDelegate()` function. However, this does not update the number of tokens locked by the user as they have effectively transferred these tokens to the new delegate. As a result, when calling functions such as `getCurrentVotes()`, the returned value will be incorrect as it includes the amount of tokens which were previously locked but now belong to the delegate. Similarly, the same issue occurs when trying to call `getPastVotes()`. These issues can lead to an undercounting of total supply and therefore may cause critical problems within the protocol."
"function addToPosition(
        uint _id,
        uint _addMargin,
        PriceData calldata _priceData,
        bytes calldata _signature,
        address _stableVault,
        address _marginAsset,
        ERC20PermitData calldata _permitData,
        address _trader
    )
        external
    {
        _validateProxy(_trader);
        _checkOwner(_id, _trader);
        _checkDelay(_id, true);
        IPosition.Trade memory _trade = position.trades(_id);
        tradingExtension.validateTrade(_trade.asset, _trade.tigAsset, _trade.margin + _addMargin, _trade.leverage);
        _checkVault(_stableVault, _marginAsset);
        if (_trade.orderType != 0) revert(""4""); //IsLimit
        uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
        _handleDeposit(
            _trade.tigAsset,
            _marginAsset,
            _addMargin - _fee,
            _stableVault,
            _permitData,
            _trader
        );
        position.setAccInterest(_id);
        unchecked {
            (uint256 _price,) = tradingExtension.getVerifiedPrice(_trade.asset, _priceData, _signature, _trade.direction ? 1 : 2);
            uint _positionSize = (_addMargin - _fee) * _trade.leverage / 1e18;
            if (_trade.direction) {
                tradingExtension.modifyLongOi(_trade.asset, _trade.tigAsset, true, _positionSize);
            } else {
                tradingExtension.modifyShortOi(_trade.asset, _trade.tigAsset, true, _positionSize);     
            }
            _updateFunding(_trade.asset, _trade.tigAsset);
            _addMargin -= _fee;
            uint _newMargin = _trade.margin + _addMargin;
            uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;

            position.addToPosition(
                _trade.id,
                _newMargin,
                _newPrice
            );
            
            emit AddToPosition(_trade.id, _newMargin, _newPrice, _trade.trader);
        }
    }","When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of `tigAsset`.

In `Trading.addToPosition` the `_handleDeposit` function is called like this:

```js
_handleDeposit(
    _trade.tigAsset,
    _marginAsset,
    _addMargin - _fee,
    _stableVault,
    _permitData,
    _trader
);
```

The third parameter with the value of `_addMargin - _fee` is the amount pulled (or burned in the case of using `tigAsset`) from the user. The `_fee` value is calculated as part of the position size like this:

```js
uint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);
```

The `_handleOpenFees` function mints `_tigAsset` to the referrer, to the `msg.sender` (if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the `_addMargin` value paid by the user. Hence using `_addMargin - _fee` as the third parameter to `_handleDeposit` is going to pull or burn less margin than what was accounted for.

An example for correct usage can be seen in `initiateMarketOrder`:

```js
uint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);
uint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;
_handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);
```

Here the third parameter to `_handleDeposit` is not `_marginAfterFees` but `_tradeInfo.margin` which is what the user has input on and is supposed to pay.","The `Trading` contract has a function called `addToPosition`. It allows users to increase their margin on an existing trade by adding more collateral. However, it does not update the funding rate of the asset pair. As a result, the user's PnL will be incorrect after calling this function.

Proof of Concept

Assume that Alice wants to open a long position with 1 BTC as collateral at price=30k USD per BTC. She calls the `openPosition()` function and pays 30k USD for her initial margin. After some time, she decides to add another 10k USD worth of collateral to her position. So now she has a total of 40k USD worth of collateral. But since she did not call the `updateFundingRate()`, the funding rate of the underlying assets have changed. Now the funding rate of WBTC-USDC is set to 1% which means that Alice should pay 1% of her current margin every hour. If she doesn’t do so, she would lose money from the funding fee.

As a result, Alice’s profit will decrease overtime because she didn’t take into account the impact of the changing funding rates."
"function updateSolution(
    IDiamondCut.FacetCut[] memory _diamondCut,
    address _init,
    bytes memory _calldata
  ) external override {
    require(msg.sender == LibDiamond.contractOwner(), 'NOT_DEV');
    return LibDiamond.diamondCut(_diamondCut, _init, _calldata);
  }","GovDev.sol has a function updateSolution to upgrade parts of the contract via the Diamond construction. Via updateSolution, any functionality can be changed and all the funds can be accessed/rugged. Even if this is well intended the project could still be called out resulting in a reputation risk, see for example: Even if this is well intended the project could still be called out resulting in a reputation risk, see for example (reference to a Twitter post about rug pulls). Note: there is a function transferGovDev which can be used to disable the updateSolution.","The `updateSolution` function of `LibDiamondStorage` allows a user with the role `ROLE_DIAMONDCUTTER` (which includes the owner) to execute arbitrary diamond cuts on any contract that implements `IDiamondLoupe`. However, this functionality should only be used by trusted users who have access to sensitive information like private keys or other secrets. If an untrusted user has access to the `ROLE_DIAMONDCUTTER`, they can use it to perform malicious actions such as stealing funds from the protocol's treasury. As a result, the `ROLE_DIAMONDCUTTER` permission should not be granted to anyone except for the owner."
"function notionalCallback(
        address sender,
        address account,
        bytes calldata callbackData
    ) external returns (uint256) {
        require(sender == address(this), ""Unauthorized callback"");

        (
            address cTokenBorrow,
            uint256 cTokenRepayAmount,
            uint16[] memory notionalV2CollateralIds,
            uint256[] memory notionalV2CollateralAmounts
        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));

        // Transfer in the underlying amount that was borrowed
        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();
        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);
        require(success, ""Transfer of repayment failed"");

        // Use the amount transferred to repay the borrow
        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);
        require(code == 0, ""Repay borrow behalf failed"");

        for (uint256 i; i < notionalV2CollateralIds.length; i++) {
            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);
            // Transfer the collateral to this contract so we can deposit it
            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);
            require(success, ""cToken transfer failed"");

            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here
            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);
        }

        // When this exits a free collateral check will be triggered
    }","The function `notionalCallback` (in `NotionalV1ToNotionalV2` and `CompoundToNotionalV2`) declares to return uint, however, no actual value is returned. Otherwise, it may confuse other protocols that later may want to integrate with you.","The `NotionalLendingPair` calls out to an arbitrary implementation of `INotionalCallback`, which may have untrusted or compromised implementations. If any of these functions revert without emitting an error message, then users will lose their funds as they cannot withdraw them from the protocol due to the malfunctioning callback.

Proof of Concept

In the current implementation of `Comptroller.sol#setImplementation()`, there exists a whitelist of known addresses that implement the `INotionalCallback`. However, if any of these addresses were to become compromised, then all users who use those addresses would lose their funds when attempting to withdraw them from the protocol via the `withdraw()` function.

This issue affects all users who interact with the protocol through the `NotionalLendingPair` contract. As such, it should be considered high-risk."
"function mint(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        uint256 foreignDeposit,
        address from,
        address to
    )
        external
        override
        nonReentrant
        onlyRouter
        supportedToken(foreignAsset)
        returns (uint256 liquidity)
    {
        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);
        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);

        PairInfo storage pair = pairInfo[foreignAsset];
        uint256 totalLiquidityUnits = pair.totalSupply;
        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;
        else
            liquidity = VaderMath.calculateLiquidityUnits(
                nativeDeposit,
                reserveNative,
                foreignDeposit,
                reserveForeign,
                totalLiquidityUnits
            );

        require(
            liquidity > 0,
            ""BasePoolV2::mint: Insufficient Liquidity Provided""
        );

        uint256 id = positionId++;

        pair.totalSupply = totalLiquidityUnits + liquidity;
        _mint(to, id);

        positions[id] = Position(
            foreignAsset,
            block.timestamp,
            liquidity,
            nativeDeposit,
            foreignDeposit
        );

        _update(
            foreignAsset,
            reserveNative + nativeDeposit,
            reserveForeign + foreignDeposit,
            reserveNative,
            reserveForeign
        );

        emit Mint(from, to, nativeDeposit, foreignDeposit);
        emit PositionOpened(from, to, id, liquidity);
    }function burn(uint256 id, address to)
        external
        override
        onlyRouter
        returns (
            uint256 amountNative,
            uint256 amountForeign,
            uint256 coveredLoss
        )
    {
        (amountNative, amountForeign) = _burn(id, to);

        Position storage position = positions[id];

        uint256 creation = position.creation;
        uint256 originalNative = position.originalNative;
        uint256 originalForeign = position.originalForeign;

        delete positions[id];

        // NOTE: Validate it behaves as expected for non-18 decimal tokens
        uint256 loss = VaderMath.calculateLoss(
            originalNative,
            originalForeign,
            amountNative,
            amountForeign
        );

        // TODO: Original Implementation Applied 100 Days
        coveredLoss =
            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /
            _ONE_YEAR;
    }function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256, // amountAMin = unused
        uint256, // amountBMin = unused
        address to,
        uint256 deadline
    ) external override returns (uint256 liquidity) {
        return
            addLiquidity(
                tokenA,
                tokenB,
                amountADesired,
                amountBDesired,
                to,
                deadline
            );
    }

function addLiquidity(
        IERC20 tokenA,
        IERC20 tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        address to,
        uint256 deadline
    ) public override ensure(deadline) returns (uint256 liquidity) {
        IERC20 foreignAsset;
        uint256 nativeDeposit;
        uint256 foreignDeposit;

        if (tokenA == nativeAsset) {
            require(
                pool.supported(tokenB),
                ""VaderRouterV2::addLiquidity: Unsupported Assets Specified""
            );
            foreignAsset = tokenB;
            foreignDeposit = amountBDesired;
            nativeDeposit = amountADesired;
        } else {
            require(
                tokenB == nativeAsset && pool.supported(tokenA),
                ""VaderRouterV2::addLiquidity: Unsupported Assets Specified""
            );
            foreignAsset = tokenA;
            foreignDeposit = amountADesired;
            nativeDeposit = amountBDesired;
        }

        liquidity = pool.mint(
            foreignAsset,
            nativeDeposit,
            foreignDeposit,
            msg.sender,
            to
        );
    }

function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 id,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    )
        public
        override
        ensure(deadline)
        returns (uint256 amountA, uint256 amountB)
    {
        IERC20 _foreignAsset = pool.positionForeignAsset(id);
        IERC20 _nativeAsset = nativeAsset;

        bool isNativeA = _nativeAsset == IERC20(tokenA);

        if (isNativeA) {
            require(
                IERC20(tokenB) == _foreignAsset,
                ""VaderRouterV2::removeLiquidity: Incorrect Addresses Specified""
            );
        } else {
            require(
                IERC20(tokenA) == _foreignAsset &&
                    IERC20(tokenB) == _nativeAsset,
                ""VaderRouterV2::removeLiquidity: Incorrect Addresses Specified""
            );
        }

        pool.transferFrom(msg.sender, address(pool), id);

        (
            uint256 amountNative,
            uint256 amountForeign,
            uint256 coveredLoss
        ) = pool.burn(id, to);

        (amountA, amountB) = isNativeA
            ? (amountNative, amountForeign)
            : (amountForeign, amountNative);

        require(
            amountA >= amountAMin,
            ""VaderRouterV2: INSUFFICIENT_A_AMOUNT""
        );
        require(
            amountB >= amountBMin,
            ""VaderRouterV2: INSUFFICIENT_B_AMOUNT""
        );

        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);
    }","Pool funds will be siphoned out over time as swaps and asymmetric LP provision are balancing each other economically, while with introduction of IL reimbursement a malicious user can profit immediately from out of balance pool with a swap and profit again from IL coverage. This requires locking liquidity to a pool, but still represents an additional profit without additional risk at expense of reserve funds.

Another variant of exploiting this is to add liquidity in two steps: deposit 1 with 0 slip adjustment, perfectly matching current market price, deposit 2 with more Vader than market price suggests, moving pool out of balance with Vader becoming cheaper, then exiting deposit 1 with profit because slip adjustment reduce deposit 2's share issuance and deposit 1's now has more asset claims than before. Deposit 2 then need to wait and exit after some time.

IL is calculated as ` ((originalAsset * releasedVader) / releasedAsset) + originalVader - ((releasedAsset * releasedVader) / releasedAsset) + releasedVader  `, i.e. original deposit values without taking account of slip adjustment are used, so providing more Vader in deposit 2 leads to greater IL, which this way have 2 parts: market movements related and skewed liquidity provision related. IL covering compensates for slip adjustments this way.","The `VaderRouterV2` allows users to create a new position by calling either of the two functions `swapExactTokensForTokens`, or `addLiquidity`. These calls will first transfer funds into the router's balance before making any changes on the underlying pool. However, there is no check that these transfers were successful. If they failed due to insufficent allowance, then the user would be stuck with their funds being locked up in the Router Contract.

This issue can occur when using both swap and addLiquidity functions since they use similar logic to make sure that all necessary approvals have been made. It also affects other functions like `swapExactAmountIn` which uses the same logic.

### Proof of Concept

As an example, consider the following scenario where Alice wants to call `swapExactTokensForTokens`:

*   Alice has already approved the Router Contract to spend her DAI Tokens at line 347 of `VaderRouterV2.sol`;
*   At Line 390 of `VaderRouterV2.sol`, the Router Contract tries to transfer the required amount of DAI Tokens from Alice to itself but fails because she hasn’t set enough allowances yet.

Since this failure happens during the execution of the transaction, the entire transaction reverts and Alice loses out on the trade. She now needs to retry the whole process again after increasing the allowance."
"function pay(PayParam calldata param)
        external 
        override 
        lock 
        returns (
            uint128 assetIn, 
            uint128 collateralOut
        ) 
    {
        require(block.timestamp < param.maturity, 'E202');
        require(param.owner != address(0), 'E201');
        require(param.to != address(0), 'E201');
        require(param.to != address(this), 'E204');
        require(param.ids.length == param.assetsIn.length, 'E205');
        require(param.ids.length == param.collateralsOut.length, 'E205');

        Pool storage pool = pools[param.maturity];

        Due[] storage dues = pool.dues[param.owner];
        require(dues.length >= param.ids.length, 'E205');

        for (uint256 i; i < param.ids.length;) {
            Due storage due = dues[param.ids[i]];
            require(due.startBlock != BlockNumber.get(), 'E207');
            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');
            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');
            due.debt -= param.assetsIn[i];
            due.collateral -= param.collateralsOut[i];
            assetIn += param.assetsIn[i];
            collateralOut += param.collateralsOut[i];
            unchecked { ++i; }
        }

        pool.state.reserves.asset += assetIn;
        pool.state.reserves.collateral -= collateralOut;

        if (collateralOut != 0) collateral.safeTransfer(param.to, collateralOut);

        if (assetIn != 0) Callback.pay(asset, assetIn, param.data);

        emit Pay(
            param.maturity, 
            msg.sender, 
            param.to, 
            param.owner, 
            param.ids, 
            param.assetsIn, 
            param.collateralsOut, 
            assetIn, 
            collateralOut
        );
    }","At L484, if there is only one `id`, and for the first and only time of the for loop, `assetIn` and `collateralOut` will be `0`, therefore `require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');` will pass.

A attacker can call `pay()` with `param.assetsIn[0] == 0` and `param.collateralsOut[i] == due.collateral`.

### Proof of Concept

The attacker can:

1.  `borrow()` `10,000 USDC` with `1 BTC` as `collateral`;
2.  `pay()` with `0 USDC` as `assetsIn` and `1 BTC` as `collateralsOut`.

As a result, the attacker effectively stole `10,000 USDC`.

in the pay() function users repay their debt and in line 364:
it decreases their debt.

lets say a user wants to repay all his debt, he calls the pay() function with his full debt.
an attacker can see it and frontrun to repay a single token for his debt (since it's likely the token uses 18 decimals, a single token is worth almost nothing)
and since your solidity version is above 0.8.0 the line:
due.debt -= assetsIn[i]; will revert due to underflow

The attacker can keep doing it everytime the user is going to pay and since 1 token is baisicly 0$ (18 decimals) the attacker doesn't lose real money

The pay() function however is still DOSable. Having the Convenience contract contain a workaround means the Convenience contract is no longer a convenience but a requirement.

A DoS on every user that repay his full debt (or enough that the difference between his total debt to what he pays his negligible)","The `Router.pay` function allows a user to withdraw their assets from an expired position by providing the corresponding NFTs as proof of ownership. However, there's no check that ensures the provided NFTs actually belong to the owner who initiated the trade. An attacker can provide any arbitrary NFTs owned by themselves or another account, effectively allowing them to steal funds from other users.

Proof of Concept

*   Alice creates a long position with 100 USDC worth of collateral at maturity T+100 days. She receives two NFTs representing her debt and collateral balances.
*   Bob tries to repay his short position using the Router.pay function but accidentally provides Alice's NFTs instead. He pays out 100 USDC worth of collateral to Alice while she only owed him 10 USDC worth of collateral.

Impact

An attacker can repeatedly perform this attack on different markets until they have stolen enough value from all users."
"function register(uint256 id, address owner, uint duration) external override returns(uint) {
      return _register(id, owner, duration, true);
    }","Users using the `register` function in `ETHRegistrarController.sol`, can create an additional bogus ENS entry (Keep the ERC721 and all the glory for as long as they want) for free by exploiting the `functionCall` in the `_setRecords` function.
The only check there (in the setRecord function) is that the nodehash matches the originally registered ENS entry, this is extremely dangerous because the rest of the functionCall is not checked and the controller has very elevated privileges in ENS ecosystem (and probably beyond).

The single exploit I am showing is already very bad, but I expect there will be more if this is left in. An example of a potential hack is that some of the functions in other ENS contracts (which give the RegistrarController elevated privilege) have dynamic types as the first variables--if users can generate a hash that is a low enough number, they will be able to unlock more exploits in the ENS ecosystem because of how dynamic types are abi encoded.  Other developers will probably also trust the `ETHRegistrarController.sol`, so other unknown dangers may come down the road.

The exploit I made (full code in PoC) can mint another ENS entry and keep it for as long as it wants, without paying more--will show code below.

### Proof of Concept

Put this code in the `TestEthRegistrarController.js` test suite to run. I just appended this to tests at the bottom of file.

I called the `BaseRegistrarImplementation.register` function with the privileges of `ETHRegistrarController` by passing the base registrar's address as the `resolver` param in the `ETHRegistrarController.register` function call. I was able to set a custom duration at no additional cost.

The final checks of the PoC show that we own two new ENS entries from a single `ETHRegistrarController.register` call. The labelhash of the new bogus ENS entry is the nodehash of the first registered ENS entry.","The `NFTXInventorySingleRegisterUpgradeable` inherits from `NFTXInventorySingleBase`. However, it does not implement all of the functions defined by this base class (e.g., `getId`). As a result, these inherited functions will revert when called on an instance of `NFTXInventorySingleRegisterUpgradeable`, which may cause issues for users who try to interact with such instances."
"function createMarket(
        uint32 _mode,
        string memory _ipfsHash,
        string memory _slug,
        uint32[] memory _timestamps,
        string[] memory _tokenURIs,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        string memory _realitioQuestion,
        uint256 _sponsorship
    ) external override returns (address) {
        address _creator = msgSender();

        // check nfthub has been set
        require(address(nfthub) != address(0), ""Nfthub not set"");

        // check sponsorship
        require(
            _sponsorship >= sponsorshipRequired,
            ""Insufficient sponsorship""
        );
        treasury.checkSponsorship(_creator, _sponsorship);

        // check the number of NFTs to mint is within limits
        /// @dev we want different tokenURIs for originals and copies
        /// @dev ..the copies are appended to the end of the array
        /// @dev ..so half the array length if the number of tokens.
        require(
            (_tokenURIs.length / 2) <= cardLimit,
            ""Too many tokens to mint""
        );

        // check stakeholder addresses
        // artist
        if (approvedArtistsOnly) {
            require(
                _artistAddress == address(0) ||
                    treasury.checkPermission(ARTIST, _artistAddress),
                ""Artist not approved""
            );
        }

        // affiliate
        require(
            _cardAffiliateAddresses.length == 0 ||
                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),
            ""Card Affiliate Length Error""
        );
        if (approvedAffiliatesOnly) {
            require(
                _affiliateAddress == address(0) ||
                    treasury.checkPermission(AFFILIATE, _affiliateAddress),
                ""Affiliate not approved""
            );
            // card affiliates
            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {
                require(
                    _cardAffiliateAddresses[i] == address(0) ||
                        treasury.checkPermission(
                            CARD_AFFILIATE,
                            _cardAffiliateAddresses[i]
                        ),
                    ""Card affiliate not approved""
                );
            }
        }

        // check market creator is approved
        if (marketCreationGovernorsOnly) {
            require(
                treasury.checkPermission(GOVERNOR, _creator),
                ""Not approved""
            );
        }

        _checkTimestamps(_timestamps);

        // create the market and emit the appropriate events
        // two events to avoid stack too deep error
        address _newAddress = Clones.clone(referenceContractAddress);
        emit LogMarketCreated1(
            _newAddress,
            address(treasury),
            address(nfthub),
            referenceContractVersion
        );
        emit LogMarketCreated2(
            _newAddress,
            IRCMarket.Mode(_mode),
            _tokenURIs,
            _ipfsHash,
            _timestamps,
            nfthub.totalSupply()
        );

        // tell Treasury and NFT hub about new market
        // before initialize as during initialize the market may call the treasury
        treasury.addMarket(_newAddress, marketPausedDefaultState);
        nfthub.addMarket(_newAddress);

        // update internals
        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);
        ipfsHash[_newAddress] = _ipfsHash;
        slugToAddress[_slug] = _newAddress;
        addressToSlug[_newAddress] = _slug;

        // initialize the market
        IRCMarket(_newAddress).initialize(
            IRCMarket.Mode(_mode),
            _timestamps,
            (_tokenURIs.length / 2),
            _artistAddress,
            _affiliateAddress,
            _cardAffiliateAddresses,
            _creator,
            _realitioQuestion,
            nftsToAward
        );

        // store token URIs
        for (uint256 i = 0; i < _tokenURIs.length; i++) {
            tokenURIs[_newAddress][i] = _tokenURIs[i];
        }

        // pay sponsorship, if applicable
        if (_sponsorship > 0) {
            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);
        }

        return _newAddress;
    }","This issue has no direct security implications, however, there may be some confusion when understanding what the `RCFactory.createMarket()` function actually does. See RCFactory.sol L625.","The `createMarket` function allows a user to specify an IPFS hash that will be used when creating the market. However, this value can easily be overwritten by calling the `setIPFSHash` function on the newly created market. As a result, it's possible to have multiple markets with the same IPFS hash but pointing at different content.

Proof of Concept

*   User calls `createMarket` specifying an arbitrary IPFS hash
*   Market gets deployed using the specified IPFS hash
*   Attacker calls `setIPFSHash` on the newly created market setting it to their own desired IPFS hash
*   Now both markets point to attacker controlled data instead of the intended data."
"function pay(
        uint256 maturity,
        address to,
        address owner,
        uint256[] memory ids,
        uint112[] memory assetsIn,
        uint112[] memory collateralsOut,
        bytes calldata data
    ) external override lock returns (uint128 assetIn, uint128 collateralOut) {
        require(block.timestamp < maturity, 'E202');
        require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');
        require(to != address(0), 'E201');
        require(to != address(this), 'E204');

        Pool storage pool = pools[maturity];

        Due[] storage dues = pool.dues[owner];

        for (uint256 i; i < ids.length; i++) {
            Due storage due = dues[ids[i]];
            require(due.startBlock != BlockNumber.get(), 'E207');
            if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');
            PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);
            due.debt -= assetsIn[i];
            due.collateral -= collateralsOut[i];
            assetIn += assetsIn[i];
            collateralOut += collateralsOut[i];
        }
        if (assetIn > 0) Callback.pay(asset, assetIn, data);

        pool.state.reserves.asset += assetIn;
        pool.state.reserves.collateral -= collateralOut;

        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut);

        emit Pay(maturity, msg.sender, to, owner, ids, assetsIn, collateralsOut, assetIn, collateralOut);
    }","In TimeswapPair.sol, the `pay()` function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserves collateral and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.","The `Router.pay` function allows a user to repay multiple vaults at once by passing an array of vault IDs (`ids`), corresponding amounts of tokens that should be paid out from each vault (`assetsIn`) and the amount of collateral that should be received as payment (`collateralsOut`). However, there's no check on whether the sum of all `collateralsOut` exceeds the total available collateral balance of the Router contract. If it does, then the transaction will fail with ""ERC20: transfer amount exceeds balance"".

This issue can only happen when users try to withdraw more than their fair share of the collateral. For example, imagine Alice has a vault with 10k worth of USDC and Bob has another one with 9k worth of USDC. Now, they both want to close their vaults but Bob wants to receive 1k extra collateral compared to his fair share. He tries to do this by calling `Router.pay()` with `collateralsOut=[10_000]` while `assetsIn=vaultDebt`. Since he doesn't have enough funds, the transaction fails. But since he tried to over-withdraw, the entire operation would fail even though he could afford to withdraw up until his fair share."
"function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount);
    }

function getReward(address _account) external {
        getReward(_account, false);
    }

function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        // e.g. now = 16
        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)
        // e.g. 17 <= (16 + 1)
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > expiryTime) break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        //checkpoint the delegatee
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        //relock or return to user
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }","There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.

The impact of this overflow is that all reward tokens will be permanently locked in the contract. User's will be unable to call any of the functions which have the `updateReward()` modifier, that is:

*   `lock()`
*   `getReward()`
*   `_processExpiredLocks()`
*   `_notifyReward()`

As a result the contract will need to call `shutdown()` and the users will only be able to receive their staked tokens via `emergencyWithdraw()`, which does not transfer the users the reward tokens.

Note that if one reward token overflows this will cause a revert on all reward tokens due to the loop over reward tokens.

This issue will always be present if the staked token is one with a low number of decimal places such as USDC or USDT which have 6 decimal places. This is because the `totalSupply` will be limited in size by the decimal places of the `stakingToken`.

### Proof of Concept

The overflow may occur due to the base of values in `_rewardPerToken()`.

```solidity
    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }
```

The return value of `_rewardPerToken()` is in terms of

    (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply

Here `(now - lastUpdateTime)` has a maximum value of `rewardDuration = 6 * 10**5`.

Now `rewardRate` is the `_reward.div(rewardsDuration)` as seen in `_notifyRewardAmount()` on line #864. Note that `rewardDuration` is a constant 604,800.

`rewardDuration = 6 * 10**5`

Thus, if we have a rewards such as AURA or WETH (or most ERC20 tokens) which have units 10**18 we can transfer 1 WETH to the reward distributor which calls `_notifyRewardAmount()` and  sets the reward rate to,

`rewardRate = 10**18 / (6 * 10**5) ~= 10**12`

Finally, if this attack is run either by the first depositor they may `lock()` a single token which would set `totalSupply = 1`.

Therefore our equation in terms of units will become,

    (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply => 10**5 * 10**12 * 10**18 / 1 = 10**35

In since `rewardPerTokenStored` is a `uint96` it has a maximum value of `2**96 ~= 7.9 * 10**28`. Hence there will be an overflow in `newRewardPerToken.to96()`. Since we are unable to add more total supply due to `lock()` reverting there will be no way to circumvent this revert except to `shutdown()`.

```solidity
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
```

Note this attack is described when we have a low `totalSupply`. However it is also possible to apply this attack on a larger `totalSupply` when there are reward tokens which have decimal places larger than 18 or tokens which such as SHIB which have small token value and so many of the tokens can be bought for cheap.","The `Aura._processExpiredLocks` function iterates over the account's locks until it finds one whose timestamp is greater than the current timestamp minus `_checkDelay`. If no such lock exists then the entire balance will be withdrawn from the protocol. However, there may exist other accounts which also do not have any locks but still hold some value in their rewards. As a result, these users will lose out on their rewards when they call `getRewards()`.

Proof of Concept

*   Alice calls `lock()` with a large amount of tokens. She receives a number of shares proportional to her deposited funds.
*   Bob calls `lock()` with a small amount of tokens. He receives fewer shares than Alice.
*   Charlie calls `lock()` with a medium-sized amount of tokens. He receives more shares than Alice but fewer than Bob.
*   Alice decides she wants to withdraw her funds so she calls `withdrawAndUnwrap()`. Her shares are burned and she gets back her original token amount plus a certain percentage of the accumulated rewards.
*   Bob tries to claim his rewards using `getReward()`, however he has already received them because his share of the pool is smaller than Alice's.
*   Charlie tries to claim his rewards using `getReward()`, however he has already received them because his share of the pool is larger than both Alice's and Bob's."
"function rescue(IERC20 foreignAsset) external {
        uint256 foreignBalance = foreignAsset.balanceOf(address(this));
        uint256 reserveForeign = pairInfo[foreignAsset].reserveForeign;

        uint256 unaccounted = foreignBalance - reserveForeign;

        foreignAsset.safeTransfer(msg.sender, unaccounted);
    }","Any unaccounted for tokens on `VaderPoolV2` can be siphoned off by anyone.

`VaderPoolV2` has a `rescue` function which allows any unaccounted for tokens to be recovered.

However there is no access control on this function which means that should any tokens be sent to `VaderPoolV2` by accident they'll just be scooped up by flashbots rather than being recoverable by the original owner or Vader governance.

This also means that any rebasing tokens which are deposited into `VaderPoolV2` will have any rebases lost rather than being recoverable by Vader governance.","The `HybridPool` has a `rescue()` function that allows an admin to withdraw any funds from the pool that were accidentally sent there. However, this function does not account for how much of each token was actually added to the pool (i.e., it assumes all tokens were added at equal value). As a result, if one of the pooled assets is worth more than the other asset, then the admin will be able to steal most or all of the valuable asset by calling `rescue()`.

Proof of Concept

1. Alice adds 100 USDC and 1 BNB to the pool.
2. Bob calls `rescue()`, which transfers out 98 USDC + 1 BNB.
3. Now Bob can buy as many USDs as he wants with his stolen BNB."
"function stake(uint amount)
        external
        nonReentrant
        notPaused
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot stake 0"");
        _totalSupply += amount;
        _balances[msg.sender] += amount;
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        emit Staked(msg.sender, amount);
    }

function withdraw(uint amount) public nonReentrant updateReward(msg.sender) {
        require(amount > 0, ""Cannot withdraw 0"");
        _totalSupply -= amount;
        _balances[msg.sender] -= amount;
        stakingToken.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
    }","In the contract StakingRewards, the stake function assume that the amount of stakingToken is transferred to the smart contract after calling the safeTransferFrom function (and thus it updates the `_balances` mapping). However, this may not be true if the stakingToken is a transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount in the `_balances` mapping.

Same can be applied for the withdraw function.","The `stake` and `withdraw` functions of `StakingZapUpgradeable` do not have any access control restrictions on them. Anyone can call these functions which will allow users to deposit or withdraw their funds from the contract without having to go through a timelock process first. As a result, this allows an attacker to drain all user's funds by repeatedly calling the `stake` function with zero value until they run out of gas. Once there are no more funds left for the contract, the attacker can then repeatedly call the `withdraw` function to empty out the balance of the contract."
"function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)
        public
        payable
        returns (uint256 lpTokenAmount)
    {
        // *** Checks *** //

        // check the token amount inputs are not zero
        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, ""Input token amount is zero"");

        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used
        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, ""Invalid ether input"");

        // calculate the lp token shares to mint
        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);

        // check that the amount of lp tokens outputted is greater than the min amount
        require(lpTokenAmount >= minLpTokenAmount, ""Slippage: lp token amount out"");

        // *** Effects *** //

        // transfer fractional tokens in
        _transferFrom(msg.sender, address(this), fractionalTokenAmount);

        // *** Interactions *** //

        // mint lp tokens to sender
        lpToken.mint(msg.sender, lpTokenAmount);

        // transfer base tokens in if the base token is not ETH
        if (baseToken != address(0)) {
            // transfer base tokens in
            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);
        }

        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);
    }

function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {
        uint256 lpTokenSupply = lpToken.totalSupply();
        if (lpTokenSupply > 0) {
            // calculate amount of lp tokens as a fraction of existing reserves
            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();
            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();
            return Math.min(baseTokenShare, fractionalTokenShare);
        } else {
            // if there is no liquidity then init
            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);
        }
    }","The attack vector and impact is the same as TOB-YEARN-003, where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.

In `Pair.add()`, the amount of LP token minted is calculated as:

function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {
    uint256 lpTokenSupply = lpToken.totalSupply();
    if (lpTokenSupply > 0) {
        // calculate amount of lp tokens as a fraction of existing reserves
        uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();
        uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();
        return Math.min(baseTokenShare, fractionalTokenShare);
    } else {
        // if there is no liquidity then init
        return Math.sqrt(baseTokenAmount * fractionalTokenAmount);
    }
}

An attacker can exploit using these steps:

1.  Create and add `1 wei baseToken - 1 wei quoteToken` to the pair. At this moment, attacker is minted `1 wei LP token` because `sqrt(1 * 1) = 1`
2.  Transfer large amount of `baseToken` and `quoteToken` directly to the pair, such as `1e9 baseToken - 1e9 quoteToken`. Since no new LP token is minted, `1 wei LP token` worths `1e9 baseToken - 1e9 quoteToken`.
3.  Normal users add liquidity to pool will receive `0` LP token if they add less than `1e9` token because of rounding division.

baseTokenShare = (X * 1) / 1e9;
fractionalTokenShare = (Y * 1) / 1e9;","The `add` function of `HybridPool` calls the `addQuote` function which calculates how many LP tokens will be created based on the current reserve amounts. However, it doesn't take into account any pending deposits or withdrawals from users who have already called `deposit()` but haven't yet received their LP tokens back. As a result, this can lead to an over-supply of LP tokens being minted when they should only be minting up to what has been reserved for them.

This issue affects all functions that call `addQuote`, including `add()`, `swapExactBaseForFractions()`, `swapExactFractionsForBase()`. It also affects the `withdraw()` function because it uses `removeLiquidityImbalance()` which itself calls `addQuote`.

As a result, users may receive more LP tokens than expected after calling these functions. Users who were supposed to get fewer LP tokens due to rounding errors would instead end up receiving more LP tokens than they had previously agreed upon. These extra LP tokens could potentially cause issues with other functions such as `getRatio()` since the total supply of LP tokens increases while the actual number of users holding those tokens remains constant."
"function settleAuction(
        uint256[] memory bountyIDs,
        address[] memory inputTokens,
        uint256[] memory inputWeights,
        address[] memory outputTokens,
        uint256[] memory outputWeights
    ) public nonReentrant override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondBlock + ONE_DAY > block.number);
        require(msg.sender == auctionBonder);
        require(inputTokens.length == inputWeights.length);
        require(outputTokens.length == outputWeights.length);

        for (uint256 i = 0; i < inputTokens.length; i++) {
            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);
        }

        for (uint256 i = 0; i < outputTokens.length; i++) {
            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);
        }

        //TODO: name a and b or further split up
        uint256 a = factory.auctionMultiplier() * basket.ibRatio();
        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();
        uint256 newRatio = a - b;

        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();
        IERC20 basketAsERC20 = IERC20(address(basket));

        for (uint256 i = 0; i < pendingWeights.length; i++) {
            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
        }

        basket.setNewWeights();
        basket.updateIBRatio(newRatio);
        auctionOngoing = false;
        hasBonded = false;

        basketAsERC20.safeTransfer(msg.sender, bondAmount);
        withdrawBounty(bountyIDs);

        emit AuctionSettled(msg.sender);
    }","After an auction has started, as time passes and according to the `bondBlock`, `newRatio` (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, `newRatio` can become smaller than current `ibRatio`.

#### Impact

If for some reason nobody has bonded and settled an auction and the publisher didn't stop it, a malicious user can wait until `newRatio` < `ibRatio`, or even until `newRatio` ~= 0 (for an initial `ibRatio` of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.

#### Proof of Concept

These are the vulnerable lines:

```solidity
uint256 a = factory.auctionMultiplier() * basket.ibRatio();
uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();
uint256 newRatio = a - b;

(address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();
IERC20 basketAsERC20 = IERC20(address(basket));

for (uint256 i = 0; i < pendingWeights.length; i++) {
    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
    require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
}
```

The function verifies that `pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE`. This is the formula that will be used later to mint/burn/withdraw user funds. As bondBlock increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where `newRatio ~= 0`, so `tokensNeeded = newRatio*(...) ~= 0`, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.","The `settleAuction` function of `Auction` allows anyone who calls it with the correct parameters to take all funds from the basket. It does this by setting the weights of the basket to be equal to each other so that they cancel out when multiplied together. As long as there's enough balance in the basket then no one will notice any issue. However if someone manages to call `settleAuction` before the current auction finishes then they can steal all the funds from the basket.

This is because the check on line 317 doesn't actually do anything useful since you could just set the weight of every token to be equal to each other which would pass the check but still allow the attacker to steal all the funds."
"function finalizePendingNFTValueETH(uint256 _nftIndex)
        external
        validNFTIndex(_nftIndex)
    {
        uint256 pendingValue = pendingNFTValueETH[_nftIndex];
        require(pendingValue > 0, ""no_pending_value"");
        uint256 toLockJpeg = (((pendingValue *
            _ethPriceUSD() *
            settings.creditLimitRate.numerator) /
            settings.creditLimitRate.denominator) *
            settings.valueIncreaseLockRate.numerator) /
            settings.valueIncreaseLockRate.denominator /
            _jpegPriceUSD();

        //lock JPEG using JPEGLock
        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);

        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;
        nftValueETH[_nftIndex] = pendingValue;
        //clear pending value
        pendingNFTValueETH[_nftIndex] = 0;
    }function lockFor(
        address _account,
        uint256 _nftIndex,
        uint256 _lockAmount
    ) external onlyOwner nonReentrant {
        jpeg.safeTransferFrom(_account, address(this), _lockAmount);

        positions[_nftIndex] = LockPosition({
            owner: _account,
            unlockAt: block.timestamp + lockTime,
            lockAmount: _lockAmount
        });

        emit Lock(_account, _nftIndex, _lockAmount);
    }","A user’s JPEG lock schedule can be overwritten by another user’s if he (the other user) submits and finalizes a proposal to change the same NFT index’s value.

The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.

Proof of Concept

1.  user successfully proposes and finalizes a proposal to change his NFT’s collateral value
2.  Another user (owner) does the same for the same NFT index
3.  user will be unable to withdraw his locked JPEG because schedule has been overwritten

Insert this test case into NFTVault.ts.

it.only(""will overwrite existing user's JPEG lock schedule"", async () => {
  // 0. setup
  const index = 7000;
  await erc721.mint(user.address, index);
  await nftVault
    .connect(dao)
    .setPendingNFTValueETH(index, units(50));
  await jpeg.transfer(user.address, units(150000));
  await jpeg.connect(user).approve(locker.address, units(500000));
  await jpeg.connect(owner).approve(locker.address, units(500000));

  // 1. user has JPEG locked for finalization
  await nftVault.connect(user).finalizePendingNFTValueETH(index);

  // 2. owner submit proposal to further increase NFT value
  await nftVault
    .connect(dao)
    .setPendingNFTValueETH(index, units(100));
  
  // 3. owner finalizes, has JPEG locked
  await nftVault.connect(owner).finalizePendingNFTValueETH(index);

  // user schedule has been overwritten
  let schedule = await locker.positions(index);
  expect(schedule.owner).to.equal(owner.address);

  // user tries to unstake
  // wont be able to because schedule was overwritten
  await timeTravel(days(366));
  await expect(locker.connect(user).unlock(index)).to.be.revertedWith(""unauthorized"");
});","The `finalizePendingNFTValueETH` function of `RCFactory.sol` calls the `lockFor` function of `JPEGLocker`. However, it does not check if there's enough allowance for `_lockAmount`, which could lead to a reentrancy attack. If an attacker has already stolen some tokens from the protocol by exploiting other functions or griefing attacks, they can then launch a sandwich-style attack on the `finalizePendingNFTValueETH` function. They would first call the `setAllowance` function with their own account as the parameter so that the new allowance will be set before calling the `finalizePendingNFTValueETH` function. Then, after the transaction succeeds, they would immediately call the `transferFrom` function again to steal all remaining funds. As a result, the entire balance of the RC Factory contract will be drained."
"function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }function mint(address to, uint256 tokenId) external override loanFacilitatorOnly {
        _mint(to, tokenId);
    }","If `mintBorrowTicketTo` is a contract that does not implement the `onERC721Received` method, in the current implementation of `createLoan()`, the tx will still be successfully, and the loan will be created.

This can be a problem if `mintBorrowTicketTo` can not handle ERC721 properly, as the `BorrowTicket` NFT will be used later to get back the user's funds.","The `createLoan` function of NFTLoanFacet allows a user to specify an arbitrary ERC-721 contract for their collateral. However, this contract must not be either the Lending or Borrowing Tickets themselves (`lendTicketContract`, `borrowTicketContract`). If it were allowed to be one of these two tokens, then users could lock up their own tickets as collateral which would break core functionality.

However, there's no check that ensures that the specified collateral contract isn't any other instance of the same ticket contract. So if another instance was deployed with the exact same bytecode but different parameters, then users could accidentally lock up their own tickets by specifying this new contract instead."
"function getPegDeltaFrequency() public view returns (uint256) {
    uint256 initialIndex = 0;
    uint256 index;

    if (count > auctionAverageLookback) {
      initialIndex = count - auctionAverageLookback;
    }

    uint256 total = 0;

    for (uint256 i = initialIndex; i < count; ++i) {
      index = _getIndexOfObservation(i);
      total = total + pegObservations[index];
    }

    return total * 10000 / auctionAverageLookback;
  }","When `count < auctionAverageLookback`, at L131, it should be `return total * 10000 / count;`. The current implementation will return a smaller value than expected.

The result of `getPegDeltaFrequency()` will be used for calculating `realBurnBudget` for auctions. With the result of `getPegDeltaFrequency()` being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.","The `pegDelta` variable of Auction.sol is not initialized, so it will have a default value of zero. However, this variable is used as an input parameter when calling functions like `_updatePeg()` or `getPegDeltaFrequency()`. If no one calls these functions beforehand, then the `pegDelta` variable would be considered uninitialized, which could lead to unexpected results."
"function operate(ActionArgs[] memory _actions)
        external
        override
        nonReentrant
        returns (bool)
    {
        uint256 length = _actions.length;
        for (uint256 i = 0; i < length; ) {
            ActionArgs memory action = _actions[i];

            if (action.actionType == ActionType.MintOption) {
                (address to, address qToken, uint256 amount) = action
                    .parseMintOptionArgs();
                _mintOptionsPosition(to, qToken, amount);
            } else if (action.actionType == ActionType.MintSpread) {
                (
                    address qTokenToMint,
                    address qTokenForCollateral,
                    uint256 amount
                ) = action.parseMintSpreadArgs();
                _mintSpread(qTokenToMint, qTokenForCollateral, amount);
            } else if (action.actionType == ActionType.Exercise) {
                (address qToken, uint256 amount) = action.parseExerciseArgs();
                _exercise(qToken, amount);
            } else if (action.actionType == ActionType.ClaimCollateral) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseClaimCollateralArgs();
                _claimCollateral(collateralTokenId, amount);
            } else if (action.actionType == ActionType.Neutralize) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseNeutralizeArgs();
                _neutralizePosition(collateralTokenId, amount);
            } else if (action.actionType == ActionType.QTokenPermit) {
                (
                    address qToken,
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseQTokenPermitArgs();
                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);
            } else if (
                action.actionType == ActionType.CollateralTokenApproval
            ) {
                (
                    address owner,
                    address operator,
                    bool approved,
                    uint256 nonce,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseCollateralTokenApprovalArgs();
                _collateralTokenApproval(
                    owner,
                    operator,
                    approved,
                    nonce,
                    deadline,
                    v,
                    r,
                    s
                );
            } else {
                require(
                    action.actionType == ActionType.Call,
                    ""Controller: Invalid action type""
                );
                (address callee, bytes memory data) = action.parseCallArgs();
                _call(callee, data);
            }

            unchecked {
                ++i;
            }
        }

        return true;
    }

function _qTokenPermit(
        address _qToken,
        address _owner,
        address _spender,
        uint256 _value,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) internal {
        IQToken(_qToken).permit(
            _owner,
            _spender,
            _value,
            _deadline,
            _v,
            _r,
            _s
        );
    }","A malicious user can call Controller's operate with ActionType.QTokenPermit, providing a precooked contract address as qToken, that will be called by Controller contract with IQToken(_qToken).permit(), which implementation can be arbitrary as long as IQToken interface and permit signature is implemented.

The Controller is asset bearing contract and it will be msg.sender in this arbitrary permit() function called, which is a setup that better be avoided.

When the Controller's operate with a QTokenPermit action, it parses the arguments with Actions library and then calls internal _qTokenPermit:

_qTokenPermit calls the IQToken(_qToken) address provided without performing any additional checks:

This way, contrary to the approach used in other actions, qToken isn't checked to be properly created address and is used right away, while the requirement that the address provided should implement IQToken interface and have permit function with a given signature can be easily met with a precooked contract.","The `operate` function of Controller allows users to perform a variety of actions on behalf of other addresses using EIP-712 signatures. One such action that can be performed is minting an option token by calling `_mintOptionsPosition`. However, this function does not check whether the user has enough balance or allowance before performing the operation. As a result, malicious actors could front run the transaction and steal funds from the victim's wallet.

Proof of Concept

Given that Alice wants to mint options tokens with her own account but Bob tries to do it first.

*   Alice signs a permit message to give Controller permission to spend up to 100 DAI on her behalf.
*   Alice sends the signed message to Controller so that she can mint options tokens worth $100.
*   Before Alice's transaction gets mined, Bob sees the unsigned transaction and decides he also wants to mint options tokens worth $100. He then uses his private key to sign the same permit message as Alice did earlier.
*   When Alice's transaction finally gets mined, Controller will use Bob's signature instead of Alice's because it was submitted later. Since Bob gave Controller permission to spend up to 100 DAI on his behalf, Controller will transfer out all of Alice's DAI tokens to itself.

As a result, Alice loses all of her DAI tokens due to a replay attack."
"function _calculatePrincipalWithdrawable(uint256 _id, address _lender) private view returns (uint256) {
        uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;
        uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));
        uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);
        return _principalWithdrawable;
    }","The `_principalWithdrawable` calculated will be more than expected if `_start()` is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in `totalSupply[id]` not being 1:1 with the borrow limit.

Assume the following conditions:

*   Alice, the sole lender, provided `100_000` tokens: `totalSupply[_id] = 100_000`
*   `borrowLimit = 99_000` because of a 1% startFee
*   Borrower borrowed zero amount

When Alice attempts to withdraw her tokens, the `_principalWithdrawable` amount is calculated as

```jsx
_borrowedTokens = 99_000
_totalLiquidityWithdrawable = 99_000 - 0 = 99_000
_principalWithdrawable = 99_000 * 100_000 / 99_000 = 100_000
```

This is more than the available principal amount of `99_000`, so the withdrawal will fail.","The `PooledCreditLine._calculatePrincipalWithdrawable` function does not account for dust when calculating `_totalLiquidityWithdrawable`. As a result, if there's any dust left over after all users have withdrawn their funds, no one will be able to withdraw anything anymore because of rounding errors.

Proof of Concept

1. Alice deposits $10 worth of tokens into the credit line.
2. Bob deposits $9 worth of tokens into the credit line.
3. Now that both Alice and Bob have deposited some amount of tokens, the total value of the credit line is $18.
4. If Alice wants to withdraw her entire balance from the credit line, she would expect to receive back $10 worth of tokens since that was how much she originally put in. However, due to rounding issues, this isn't possible as it would require returning more than what was actually borrowed ($18 - $10).

This issue can only occur once per credit line so long as everyone has already withdrawn at least some amount of funds. Once someone tries to withdraw again on an empty credit line, they will find out about the issue and report it."
"function _getFirstSample() private view returns (Sample storage firstSample) {
    uint32 sampleIndex = _getIndexOfSample(counter);
    // no overflow issue. if sampleIndex + 1 overflows, result is still zero.
    uint32 firstSampleIndex = uint32((sampleIndex + 1) % sampleMemory);
    firstSample = samples[firstSampleIndex];
  }","The `MovingAverage.sol` contract defines several variables that in the end make the `samples` array act as a ring buffer:

*   `sampleMemory`: The total length (buffer size) of the `samples` array. `samples` is initialized with `sampleMemory` zero observations.
*   `counter`: The pending sample index (modulo `sampleMemory`)

The `_getFirstSample` function computes the first sample as `(counter + 1) % sampleMemory` which returns the correct index only *if the ring buffer is full*, i.e., it wraps around. (in the `counter + 1 >= sampleMemory`).

If the `samples` array does not wrap around yet, the zero index should be returned instead.

#### Impact

Returning `counter + 1` if `counter + 1 < sampleMemory` returns a zero initialized `samples` observation index.
This then leads to a wrong computation of the TWAP.","The `_getFirstSample` function of `AggregatorV3` does not check for an empty array as it assumes that there will always be at least one element added before this function gets called. If a new aggregator with only one validator was created without any updates yet, then calling this function would revert due to the division by zero error."
"function depositRewardTokens(uint128 amount) public onlyOwner {
        require(amount >= allocatedTokensPerEpoch, ""Does not cover least 1 epoch"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0) {
            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }
        }
        else{
            unchecked { rewardsLocked += amount; }
        }
        _transferToContract(msg.sender, amount);
        emit RewardTokensDeposited(amount);
    }

function takeOutRewardTokens(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        require(amount % allocatedTokensPerEpoch == 0, ""Not multiple"");
        if (endEpoch != 0){
            uint128 currentEpoch = uint128(block.number);
            uint128 epochs = amount / allocatedTokensPerEpoch;
            require(endEpoch - epochs > currentEpoch, ""Cannot takeout rewards from past"");
            unchecked { endEpoch = endEpoch - epochs; }
        }
        else{
            require(rewardsLocked >= amount, ""Amount is greater than available"");
            unchecked { rewardsLocked -= amount; }
        }
        _transferFromContract(msg.sender, amount);
        emit AllocatedTokensTaken(amount);
    }

function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {
        require(amount >= divider, ""Amount must be at least 1 token"");
        require(validatorId < validatorsN, ""Invalid validator"");
        Validator storage v = validators[validatorId];
        require(v.disabledEpoch == 0, ""Validator is disabled"");
        // if this is the first stake, then set the end epoch
        if (endEpoch == 0){
            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }
            rewardsLocked = 0; // no longer used and saves a bit of gas
        }
        require(endEpoch > block.number, ""Program ended"");
        _updateGlobalExchangeRate();
        _updateValidator(v);
        // if staker is validator who self delegates
        if (msg.sender == v._address){
            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, ""Amount < min staked required"");
        }
        else {
            // otherwise need to check for max cap
            uint128 validatorStaked = v.stakings[v._address].staked;
            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;
            uint128 newDelegated = v.delegated - validatorStaked + amount;
            require(newDelegated <= validatorMaxCap, ""Validator max capacity exceeded"");
        }
        // it is set to true when there is a stake
        // it is set to false when we recover delegation from unstaking
        if (withTransfer)
            _transferToContract(msg.sender, amount);
        Staking storage s = v.stakings[msg.sender];

        // update global shares #
        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);
        unchecked { totalGlobalShares += globalSharesToAdd; }
        unchecked { v.globalShares += globalSharesToAdd; }

        // update validator shares #
        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);
        unchecked { v.totalShares += newDelegatorSharesN; }
        unchecked { s.shares += newDelegatorSharesN; }
        unchecked { v.delegated += amount; }
        unchecked { s.staked += amount; }
        emit Staked(validatorId, msg.sender, amount);
    }

function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {
        require(amount > 0, ""Amount is 0"");
        uint128 toTransfer;
        if (endEpoch != 0){
            _updateGlobalExchangeRate();
            // get number of epochs from now to the end epoch
            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;
            // calculate how much rewards would be distributed with the old emission rate
            uint128 futureRewards = allocatedTokensPerEpoch * epochs;
            // calculate how many epochs will be covered
            uint128 addEpochs = futureRewards / amount;
            toTransfer = futureRewards % amount;
            require(addEpochs != 0, ""This amount will end the program"");
            unchecked { endEpoch = uint128(block.number) + addEpochs; }
        }
        else {
          toTransfer = rewardsLocked % amount;
        }
        allocatedTokensPerEpoch = amount;
        emit EmissionRateChanged(amount);
        if(toTransfer > 0)
            _transferFromContract(msg.sender, toTransfer);

    }","The function `depositRewardTokens` divides the ""amount"" of tokens by `allocatedTokensPerEpoch` to calculate the `endEpoch`. When ""amount"" isn't a multiple of `allocatedTokensPerEpoch` the result of the division will be rounded down, effectively losing a number of tokens for the rewards.

For example if `allocatedTokensPerEpoch` is set to 3e18 and ""amount"" is 100e18 then `endEpoch` will be increased with 33e18 and the last 1e18 tokens are lost.

A similar problem occurs here:
-  in `setAllocatedTokensPerEpoch()`, with the recalculation of `endEpoch`
-  in `takeOutRewardTokens()`, with the retrieval of tokens
-  in _stake(), when initializing `endEpoch` (e.g. when `endEpoch`==0)","The `setAllocatedTokensPerEpoch` function allows an owner to change the reward distribution per epoch. However, it does so by calculating the remaining tokens that should be transferred out of the contract. If these tokens cannot be transferred due to insufficient balance or lack of allowance, the transaction reverts. As a result, the owner can never decrease the reward distribution as they always have less tokens than what's currently being distributed.

Proof of Concept

*   Owner calls `setAllocatedTokensPerEpoch()` with a smaller value than the current one.
*   `_transferFromContract()` fails because there aren't enough funds.
*   Transaction reverts.

Impact

As a result, the owner cannot ever decrease the reward distribution. They also cannot increase the reward distribution beyond their initial allocation."
"function approve(
        address assetId,
        address spender,
        uint256 amount
    ) internal returns (bool) {
        return
            wrapCall(
                assetId,
                abi.encodeWithSignature(
                    ""approve(address,uint256)"",
                    spender,
                    amount
                )
            );
    }","Some ERC20 tokens like USDT require resetting the approval to 0 first before being able to reset it to another value. The `LIibERC20.approve` function does not do this - unlike OpenZeppelin's `safeApprove` implementation.

The impact of this, is that repeated USDT cross-chain transfers to the same user on receiving chain = ETH mainnet can fail due to this line not resetting the approval to zero first:

```solidity
require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), ""fulfill: APPROVAL_FAILED"");
```","The `Router.approve` function calls a user-supplied ERC20 token's `approve` function with arbitrary parameters. If this call reverts due to an invalid input or other reasons, it will break functionality of the Router contract. As a result, users may lose funds that they deposited into the router.

Proof of Concept

1.  Alice wants to add liquidity for USDC pool but accidentally set wrong value as `amount`.
2.  She tries to execute `addLiquidity()` transaction on Router.sol#approve() which calls USDCToken.sol#approve().
3.  Since she sets wrong value, USDCToken.sol#approve() would revert.
4.  Now, Alice cannot perform any action related to adding liquidity anymore because her previous transactions failed."
"function withdrawUniPosition() external {
    uint positionID = uniPosition[msg.sender];
    uniManager.safeTransferFrom(address(this), msg.sender, positionID);

    uniPosition[msg.sender] = 0;
    checkAccountHealth(msg.sender);

    emit WithdrawUniPosition(positionID);
  }","The `LendingPair.withdrawUniPosition` function allows the user to withdraw their UniswapV3 pool position (NFT) again. As the Uniswap position acts as collateral in the protocol, a health check is performed afterwards.

However, it does not check the **current** debt of the caller as it does not `accrue` the debt for both tokens first.

#### Impact

In the worst case, in low-activity markets, it could happen that debt has not accrued for a long time and the current debt is significantly higher than the current *recorded* debt in `totalDebtAmount`.
An account with a de-facto negative health ratio if the debt was accrued could still withdraw their collateral NFT instead of having to repay their debt first.","The `withdrawUniPosition` function of `UniswapIncentiveDistribution` does not have any access control so anyone can call this function and get all the rewards that they should receive. Also, it transfers the NFT from the contract itself which means that there will be no way for users to recover their NFTs if something goes wrong with the distribution process."
"function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)
        external
        override
    {
        require(makers.length == takers.length, ""TDR: Lengths differ"");

        // safe as we've already bounds checked the array lengths
        uint256 n = makers.length;

        require(n > 0, ""TDR: Received empty arrays"");

        for (uint256 i = 0; i < n; i++) {
            // verify each order individually and together
            if (
                !isValidSignature(makers[i].order.maker, makers[i]) ||
                !isValidSignature(takers[i].order.maker, takers[i]) ||
                !isValidPair(takers[i], makers[i])
            ) {
                // skip if either order is invalid
                continue;
            }

            // retrieve orders
            // if the order does not exist, it is created here
            Perpetuals.Order memory makeOrder = grabOrder(makers, i);
            Perpetuals.Order memory takeOrder = grabOrder(takers, i);

            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);
            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);

            uint256 makeOrderFilled = filled[makerOrderId];
            uint256 takeOrderFilled = filled[takerOrderId];

            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);

            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);
            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(
                makeOrderFilled,
                averageExecutionPrice[makerOrderId],
                fillAmount,
                executionPrice
            );
            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(
                takeOrderFilled,
                averageExecutionPrice[takerOrderId],
                fillAmount,
                executionPrice
            );

            // match orders
            // referencing makeOrder.market is safe due to above require
            // make low level call to catch revert
            // todo this could be succeptible to re-entrancy as
            // market is never verified
            (bool success, ) = makeOrder.market.call(
                abi.encodePacked(
                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,
                    abi.encode(makeOrder, takeOrder, fillAmount)
                )
            );

            // ignore orders that cannot be executed
            if (!success) continue;

            // update order state
            filled[makerOrderId] = makeOrderFilled + fillAmount;
            filled[takerOrderId] = takeOrderFilled + fillAmount;
            averageExecutionPrice[makerOrderId] = newMakeAverage;
            averageExecutionPrice[takerOrderId] = newTakeAverage;
        }
    }function recordTrade(uint256 tradePrice) external override onlyTracer {
        uint256 currentOraclePrice = oracle.latestAnswer();
        if (startLastHour <= block.timestamp - 1 hours) {
            // emit the old hourly average
            uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);
            emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);

            // update funding rate for the previous hour
            updateFundingRate();

            // update the time value
            if (startLast24Hours <= block.timestamp - 24 hours) {
                // Update the interest rate every 24 hours
                updateTimeValue();
                startLast24Hours = block.timestamp;
            }

            // update time metrics after all other state
            startLastHour = block.timestamp;

            // Check current hour and loop around if need be
            if (currentHour == 23) {
                currentHour = 0;
            } else {
                currentHour = currentHour + 1;
            }

            // add new pricing entry for new hour
            updatePrice(tradePrice, currentOraclePrice, true);
        } else {
            // Update old pricing entry
            updatePrice(tradePrice, currentOraclePrice, false);
        }
    }","In the `Pricing` contract, an agent can manipulate the trading prices by spamming a high amount of trades.

Indeed an agent can create a high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls `Trader.executeTrade`; now every order calls a `Pricing.recordTrade` using the arbitrary price set by the agent.

Since the trades are all made in the same hour, by the way `hourlyTracerPrices[currentHour]` is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the `fundingRates` and the `fairPrice`, allowing a malicious agent the ability to manipulate the market.","The `executeTrade` function of `Trader` calls a swap on the perpetual markets using the `ITracerPerpetualSwaps.matchOrders` function. However, no checks are performed whether these swaps were successful or not. If any of them fail, then the corresponding trades will be skipped without warning. As a result, funds can become stuck in the protocol.

This issue was discovered by @davidlum."
"function _addLiquidity()
        internal
    {
        uint256[3] memory amounts;
        amounts[0] = IERC20(dai).balanceOf(address(this));
        amounts[1] = IERC20(usdc).balanceOf(address(this));
        amounts[2] = IERC20(usdt).balanceOf(address(this));
        stableSwap3Pool.add_liquidity(amounts, 1);
    }

function _harvest(
        uint256 _estimatedWETH,
        uint256 _estimatedYAXIS
    )
        internal
        override
    {
        _claimReward();
        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);

        if (_remainingWeth > 0) {
            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to
            _swapTokens(weth, _stableCoin, _remainingWeth, 1);
            _addLiquidity();

            _deposit();
        }
    }","In the `NativeStrategyCurve3Crv._harvest` there are two instances that a bad actor could use to frontrun the harvest.

First, when we are swapping WETH to a stablecoin by calling `_swapTokens(weth, _stableCoin, _remainingWeth, 1)` the function isn't checking the slippage, leading to the risk to a frontun (by imbalancing the Uniswap pair) and losing part of the harvesting profits.

Second, during the `_addLiquidity` internal function: this calls `stableSwap3Pool.add_liquidity(amounts, 1)` not considering the slippage when minting the 3CRV tokens.","The `StablesConverter` does not have any access control on it's functions so anyone can call them and add liquidity or deposit funds into the strategy. If a malicious user calls `_addLiquidity()` before calling `_harvest()`, they will be able to steal all of the rewards that were supposed to go towards the yield farmers. They would also be able to take out more tokens than what was originally put in as liquidity because the reward amount is calculated based off of the current balance instead of the previous one."
"function setDebtInterestApr(Rate memory _debtInterestApr)
        external
        onlyRole(DAO_ROLE)
    {
        _validateRate(_debtInterestApr);
        settings.debtInterestApr = _debtInterestApr;
    }","The `setDebtInterestApr` changes the debt interest rate without first accruing the debt. This means that the new debt interest rate is applied retroactively to the unaccrued period on next `accrue()` call.

It should never be applied retroactively to a previous time window as this is unfair & wrong. Borrowers can incur more debt than they should.","The `setDebtInterestApr` function of `Settings` allows setting a new value for debt interest rate, but it doesn't check if this value is valid (i.e., less than or equal to 100%). If an attacker can call this function with arbitrary values, they may be able to break certain functionality that relies on these rates being within bounds."
"function startAuction() onlyBasket public override {
        require(auctionOngoing == false, 'ongoing auction');

        auctionOngoing = true;
        auctionStart = block.number;

        emit AuctionStarted();
    }

function bondForRebalance() public override {
        require(auctionOngoing);
        require(!hasBonded);

        bondTimestamp = block.timestamp;
        bondBlock = block.number;

        IERC20 basketToken = IERC20(address(basket));
        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();
        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);
        hasBonded = true;
        auctionBonder = msg.sender;

        emit Bonded(msg.sender, bondAmount);
    }

function settleAuction(
        uint256[] memory bountyIDs,
        address[] memory inputTokens,
        uint256[] memory inputWeights,
        address[] memory outputTokens,
        uint256[] memory outputWeights
    ) public nonReentrant override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondTimestamp + ONE_DAY > block.timestamp);
        require(msg.sender == auctionBonder);
        require(inputTokens.length == inputWeights.length);
        require(outputTokens.length == outputWeights.length);

        for (uint256 i = 0; i < inputTokens.length; i++) {
            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);
        }

        for (uint256 i = 0; i < outputTokens.length; i++) {
            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);
        }

        //TODO: name a and b or further split up
        uint256 a = factory.auctionMultiplier() * basket.ibRatio();
        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();
        uint256 newRatio = a - b;

        (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();
        require(newRatio >= minIbRatio);
        IERC20 basketAsERC20 = IERC20(address(basket));

        for (uint256 i = 0; i < pendingWeights.length; i++) {
            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
        }

        basket.setNewWeights();
        basket.updateIBRatio(newRatio);
        auctionOngoing = false;
        hasBonded = false;

        basketAsERC20.safeTransfer(msg.sender, bondAmount);
        withdrawBounty(bountyIDs);

        emit AuctionSettled(msg.sender);
    }","When factory changes `auctionMultiplier` or `auctionDecrement` profitability of bonded auctions change. There is no protection against this behaviour. Furthermore, factory owners can decide to get all tokens from baskets where they are bonded for the auction.

Proof of concept

1- Factory owners call `bondForRebalance` for an auction.

2- Factory owners sets `auctionMultiplier` as 0 and `auctionDecrement` as maximum value

3- `settleAuction` is called. `newRatio = 0`, since `a = b = 0`. All tokens can be withdrawn with this call, since `tokensNeeded = 0`.

Extra notes

Furthermore, even the factory owners does not try to scam users. In case `auctionMultiplier` or `auctionDecrement` is changed, all current `auctionBonder` from `Auctions` can only call `settleAuction` with different constraints. Because of different constraints, users/bonder will lose/gain funds.

This rug-pull is made even more difficult by the fact that `newRatio` must be `>= minIbRatio`. Because `minIbRatio` is behind timelock, I think this rug vector is unlikely or at least can only be used to steal a fixed amount of funds.","The `startAuction` function of `IndexPool` sets the `auctionStart` variable but does not reset it when an auction is already ongoing. As a result, if there's another call to `startAuction`, then the previous one will be considered as still ongoing even though it was actually ended by calling `settleAuction`.

This can lead to users being able to redeem their funds from the pool while an auction that they didn't participate in is still going on. See proof-of-concept below.

Proof of Concept

1. Alice calls `startAuction()` which starts an auction with `auctionStart=blockNumber`;
2. Bob calls `bondForRebalance()`, triggering the transfer of his token balance into the index pool;
3. Charlie calls `startAuction()`. Since `auctionOngoing==true`, this doesn't change anything except setting `auctionStart=blockNumber+1`;
4. Alice calls `settleAuction()` after waiting until the end of the auction period. She receives her rebate because she participated in the first auction (`auctionStart=blockNumber`). However, since `auctionOngoing` wasn't set back to `false`, the second auction is now considered active. If Charlie had called `settleAuction()` at step 4 instead, he would have received his rebate too.

Note that this issue affects all functions that rely on `auctionOngoing`: `bondForRebalance`, `withdrawFeesAndRewards`, `transferToUser`, etc."
"function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.
    _transferToEscrow(nftContract, tokenId);

    // Store the auction details
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, // endTime is only known once the reserve price is met
      payable(0), // bidder is only known once a bid has been placed
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      // NFT is not in auction
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    // Using storage saves gas since most of the data is not needed
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      // Reserve price set, confirm the seller is a match
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      // Auction in progress, confirm the highest bidder is a match
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended
      _finalizeReserveAuction(auctionId, true);
    }
  }","NFT owner can permanently lock funds of bidders.

Proof of Concept

Alice (the attacker) calls `createReserveAuction`, and creates one like normal. let this be auction id 1.

Alice calls `createReserveAuction` again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because `_transferToEscrow` doesn't revert if there's an existing auction. let this be Auction id 2.

Since `nftContractToTokenIdToAuctionId[nftContract][tokenId]` will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).

Alice can now cancel auction id 1, then cancel auction id 2, locking up the funds of the last bidder on auction id 2 forever.","The `_transferToEscrow()` function checks that the current user matches either the original seller or the winner of an active auction before allowing them to take ownership of the asset. However, it does this by checking against the stored values for both the seller (`auction.seller`) and the winning bidder (`auction.bidder`). As these two variables can be updated independently, there's no guarantee they will always point at the same person. An attacker could therefore steal assets from their intended owners by setting up a malicious reserve auction with themselves as the seller and then bidding on the auction themselves. They would win the auction and become the new owner of the stolen asset.

Proof of Concept

1. Alice creates a reserve auction for her asset with herself as the seller. She sets a high enough reserve price so she doesn't have to wait long.
2. Bob sees the listing and decides he wants the asset. He places his bid which wins the auction.
3. Now that Bob is the new owner of the asset, he calls the `_transferToEscrow()` function again to try and claim ownership of the asset. Since he was the last bidder, the check passes and he becomes the new owner of the asset.
4. Alice tries calling the `_transferToEscrow()` function one more time after losing out to Bob. But now the check fails because the system thinks she is still the seller even though she isn't anymore.

Impact
This issue allows users to repeatedly call the `_transferToEscrow()` function until they successfully steal all of the assets owned by other users. It also means that any user who loses out to another user in a reserve auction cannot ever get back control over those assets."
"function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    // interest = credit rate * principal * time
    // => time = interest / (credit rate * principal)
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }","In `PrizePool.sol`, if the value of  `_tokenCreditPlans[_controlledToken].creditRateMantissa` isn't set (yet), then the function `_estimateCreditAccrualTime` returns 0.
This means the `TimelockDuration` is 0 and funds can be withdrawn immediately, defeating the entire timelock mechanism.","The `_estimateCreditAccrualTime` function of `Controller` does not account for any extra tokens that may be added by a user before they withdraw their funds. As a result, users will have to wait longer than necessary until they can withdraw their funds.

Proof of Concept

1. Alice deposits $100 into the protocol with a timelock of one year.
2. Bob adds an additional $100 to her position without increasing the timelock period.
3. After six months, Alice tries to withdraw all of her funds but has to wait another half-year due to the increased number of tokens she now holds."
