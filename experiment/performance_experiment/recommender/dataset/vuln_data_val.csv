file_name,vuln_title,vuln_explanation,severity,vuln_recommendation,vuln_code
123.md,`AuraBalRewardPool` charges a penalty to all users in the pool if the `AuraLocker` has been shut down,"When claiming their rewards, users are charged a penalty if they take the reward directly, rather than by passing it into the auraLocker. Those are the only two options:

If the pool has been shut down, the auraLocker.lock() call will always revert, which means the user must take the penalty path:",medium,Don't charge the penalty if the locker has been shut down.,"function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //add user balances
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(_amount);

        //add user lock records or add to current
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

function getReward(address _account) external {
        getReward(_account, false);
    }

function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }function getReward(bool _lock) public updateReward(msg.sender) returns (bool) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            if (_lock) {
                auraLocker.lock(msg.sender, reward);
            } else {
                uint256 penalty = (reward * 2) / 10;
                pendingPenalty += penalty;
                rewardToken.safeTransfer(msg.sender, reward - penalty);
            }
            emit RewardPaid(msg.sender, reward, _lock);
        }
        return true;
    }"
106.md,Might not get desired min loan amount if `_originationFeeRate` changes,"Admins can update the origination fee by calling `updateOriginationFeeRate`. Note that a borrower does not receive their `minLoanAmount` set in `createLoan`, they only receive `(1 - originationFee) * minLoanAmount`, see `lend`. Therefore, they need to precalculate the `minLoanAmount` using the current origination fee to arrive at the post-fee amount that they actually receive. If admins then increase the fee, the borrower receives fewer funds than required to cover their rent and might become homeless.",medium,"Reconsider how the min loan amount works. Imo, this `minLoanAmount` should be the post-fee amount, not the pre-fee amount. It's also more intuitive for the borrower when creating the loan.","function createLoan(
        uint256 collateralTokenId,
        address collateralContractAddress,
        uint16 maxPerAnumInterest,
        uint128 minLoanAmount,
        address loanAssetContractAddress,
        uint32 minDurationSeconds,
        address mintBorrowTicketTo
    )
        external
        override
        returns (uint256 id) 
    {
        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');
        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');
        require(collateralContractAddress != lendTicketContract,
        'NFTLoanFacilitator: cannot use tickets as collateral');
        require(collateralContractAddress != borrowTicketContract, 
        'NFTLoanFacilitator: cannot use tickets as collateral');
        
        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);

        unchecked {
            id = _nonce++;
        }

        Loan storage loan = loanInfo[id];
        loan.loanAssetContractAddress = loanAssetContractAddress;
        loan.loanAmount = minLoanAmount;
        loan.collateralTokenId = collateralTokenId;
        loan.collateralContractAddress = collateralContractAddress;
        loan.perAnumInterestRate = maxPerAnumInterest;
        loan.durationSeconds = minDurationSeconds;
        
        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);
        emit CreateLoan(
            id,
            msg.sender,
            collateralTokenId,
            collateralContractAddress,
            maxPerAnumInterest,
            loanAssetContractAddress,
            minLoanAmount,
            minDurationSeconds
        );
    }

function lend(
        uint256 loanId,
        uint16 interestRate,
        uint128 amount,
        uint32 durationSeconds,
        address sendLendTicketTo
    )
        external
        override
        notClosed(loanId)
    {
        Loan storage loan = loanInfo[loanId];
        
        if (loan.lastAccumulatedTimestamp == 0) {
            address loanAssetContractAddress = loan.loanAssetContractAddress;
            require(loanAssetContractAddress != address(0), ""NFTLoanFacilitator: invalid loan"");

            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');
            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');
            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');
        
            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;

            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);
            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;
            ERC20(loanAssetContractAddress).safeTransfer(
                IERC721(borrowTicketContract).ownerOf(loanId),
                amount - facilitatorTake
            );
            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);
        } else {
            uint256 previousLoanAmount = loan.loanAmount;
            // will underflow if amount < previousAmount
            uint256 amountIncrease = amount - previousLoanAmount;

            {
                uint256 previousInterestRate = loan.perAnumInterestRate;
                uint256 previousDurationSeconds = loan.durationSeconds;

                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');
                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');

                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease
                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds 
                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0
                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), 
                ""NFTLoanFacilitator: proposed terms must be better than existing terms"");
            }

            uint256 accumulatedInterest = _interestOwed(
                previousLoanAmount,
                loan.lastAccumulatedTimestamp,
                loan.perAnumInterestRate,
                loan.accumulatedInterest
            );

            require(accumulatedInterest <= type(uint128).max,
            ""NFTLoanFacilitator: accumulated interest exceeds uint128"");

            loan.perAnumInterestRate = interestRate;
            loan.lastAccumulatedTimestamp = uint40(block.timestamp);
            loan.durationSeconds = durationSeconds;
            loan.loanAmount = amount;
            loan.accumulatedInterest = uint128(accumulatedInterest);

            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);
            if (amountIncrease > 0) {
                address loanAssetContractAddress = loan.loanAssetContractAddress;
                ERC20(loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    address(this),
                    amount + accumulatedInterest
                );
                ERC20(loanAssetContractAddress).safeTransfer(
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);
                ERC20(loanAssetContractAddress).safeTransfer(
                    IERC721(borrowTicketContract).ownerOf(loanId),
                    amountIncrease - facilitatorTake
                );
            } else {
                ERC20(loan.loanAssetContractAddress).safeTransferFrom(
                    msg.sender,
                    currentLoanOwner,
                    accumulatedInterest + previousLoanAmount
                );
            }
            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);
            
            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);
        }

        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);
    }

function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {
        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), ""NFTLoanFacilitator: max fee 5%"");
        
        originationFeeRate = _originationFeeRate;

        emit UpdateOriginationFeeRate(_originationFeeRate);
    }"
41.md,Basket becomes unusable if everybody burns their shares,"While handling the fees, the contract calculates the new `ibRatio` by dividing by `totalSupply`. This can be 0 leading to a division by 0.

Impact

If everybody burns their shares, in the next mint, `totalSupply` will be 0, `handleFees` will revert, and so nobody will be able to use the basket anymore.

Proof of Concept

Vulnerable line: contracts/contracts/Basket.sol line 124
You can add the following test to Basket.test.js and see that it reverts (..after you remove ""nonReentrant"" from ""mint"", see other issue):
```js
it(""should divide by 0"", async () => {
await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));
await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));
await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));
await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));
await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));
await basket.connect(addr1).mint(ethers.BigNumber.from(1));
});
```

Tools Used

Manual analysis, hardhat.",medium,"Add a check to `handleFees: if totalSupply= 0`, you can just return, no need to calculate new `ibRatio` / fees. You might want to reset `ibRatio` to BASE at this point.","function handleFees() private {
        if (lastFee == 0) {
            lastFee = block.timestamp;
        } else {
            uint256 startSupply = totalSupply();

            uint256 timeDiff = (block.timestamp - lastFee);
            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;
            uint256 fee = startSupply * feePct / (BASE - feePct);

            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);
            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);
            lastFee = block.timestamp;

            uint256 newIbRatio = ibRatio * startSupply / totalSupply();
            ibRatio = newIbRatio;

            emit NewIBRatio(ibRatio);
        }
    }"
5.md,Out-of-bound index access in function `getAnchorPrice`,"Out-of-bound index access is possible in the function `getAnchorPrice` of `Router.sol` if the number of anchors equals 1 or 2. Also, the returned anchor price is not the overall median in those situations.",low,Consider using `arrayPrices.length/2` as the index to get the median of prices.,"function getAnchorPrice() public view returns (uint anchorPrice) {
        if(arrayPrices.length > 0){
            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage
            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle
        } else {
            anchorPrice = one;          // Edge case for first USDV mint
        }
    }"
70.md,Oracle returns an improperly scaled USDV/VADER price,"The LBT oracle does not properly scale values when calculating prices for VADER or USDV. To show this, consider the simplest case where we expect USDV to return a value of $1 and show that the oracle does not return this value.

Consider the case of the LBT oracle tracking a single USDV-DAI pair where USDV trades 1:1 for DAI and Chainlink reports that DAI is exactly $1. For L397 we get a value of 1e8 as Chainlink reports the price of DAI with 8 decimals of accuracy.

    foreignPrice = getChainlinkPrice(address(foreignAsset));
    foreignPrice = 1e8

We can set `liquidityWeights[i]` and `totalUSDVLiquidityWeight` both to 1 as we only consider a single pair so L399-401 becomes

    totalUSD = foreignPrice;
    totalUSD = 1e8;

L403-408 is slightly more complex but from looking at the code we can calculate `totalUSDV` as shown

    totalUSDV = pairData
        .nativeTokenPriceAverage
        .mul(pairData.foreignUnit)
        .decode144()
    // pairData.nativeTokenPriceAverage == 2**112
    // pairData.foreignUnit = 10**18
    // decode144(x) = x >> 112
    totalUSDV = (2**112).mul(10**18).decode144()
    totalUSDV = 10**18

Using `totalUSD` and `totalUSDV` we can then calculate the return value of `_calculateUSDVPrice`

    returnValue = (totalUSD * 1 ether) / totalUSDV;
    returnValue = 1e8 * 1e18 / 1e18
    returnValue = 1e8

For the oracle implementation to be correct we then expect that the Vader protocol to treat values of 1e8 from the oracle to mean USDV is worth $1. However, from the code, it is intended to be that values of 1e18 represent $1 rather than 1e8.

High severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV - an incorrect value will result in the protocol losing significant funds.",high,"Go over oracle calculation again to ensure that various scale factors are properly accounted for. Some handling of the difference in the number of decimals between the chainlink oracle and the foreign asset should be added.

Build a test suite to ensure that the oracle returns the expected values for simple situations.","function _calculateUSDVPrice(
        uint256[] memory liquidityWeights,
        uint256 totalUSDVLiquidityWeight
    ) internal view returns (uint256) {
        uint256 totalUSD;
        uint256 totalUSDV;
        uint256 totalPairs = usdvPairs.length;

        for (uint256 i; i < totalPairs; ++i) {
            IERC20 foreignAsset = usdvPairs[i];
            ExchangePair storage pairData = twapData[address(foreignAsset)];

            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));

            totalUSD +=
                (foreignPrice * liquidityWeights[i]) /
                totalUSDVLiquidityWeight;

            totalUSDV +=
                (pairData
                    .nativeTokenPriceAverage
                    .mul(pairData.foreignUnit)
                    .decode144() * liquidityWeights[i]) /
                totalUSDVLiquidityWeight;
        }

        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether
        return (totalUSD * 1 ether) / totalUSDV;
    }"
29.md,Unsafe cast in `IndexPool` mint leads to attack,"The `IndexPool.mint` function performs an unsafe cast of `ratio` to the `uint120` type:

```solidity
uint120 ratio = uint120(_div(toMint, totalSupply));
```

Note that `toMint` is chosen by the caller and when choosing `toMint = 2**120 * totalSupply / BASE`, the `ratio` variable will be `2**120` and then truncated to 0 due to the cast.

This allows an attacker to mint LP tokens for free.
They just need to choose the `ratio` such that the `amountIn = ratio * reserve / BASE` variable passes the `require(amountIn >= MIN_BALANCE, ""MIN_BALANCE"");` check.
For example, when choosing `ratio = 2**120 * totalSupply / BASE + 1e16`, an attacker has to pay 1/100th of the current reserves but heavily inflates the LP token supply.

They can then use the inflated LP tokens they received in `burn` to withdraw the entire pool reserves.

POC
I created this POC that implements a hardhat test and shows how to steal the pool tokens:

Impact
An attacker can inflate the LP token pool supply and mint themselves a lot of LP tokens by providing almost no tokens themselves.
The entire pool tokens can be stolen.",high,"Even though Solidity 0.8.x is used, type casts do not throw an error. A SafeCast library must be used everywhere a typecast is done.","function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));
        
        uint120 ratio = uint120(_div(toMint, totalSupply));

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenIn = tokens[i];
            uint120 reserve = records[tokenIn].reserve;
            // @dev If token balance is '0', initialize with `ratio`.
            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;
            require(amountIn >= MIN_BALANCE, ""MIN_BALANCE"");
            // @dev Check Trident router has sent `amountIn` for skim into pool.
            unchecked { // @dev This is safe from overflow - only logged amounts handled.
                require(_balance(tokenIn) >= amountIn + reserve, ""NOT_RECEIVED"");
                records[tokenIn].reserve += amountIn;
            }
            emit Mint(msg.sender, tokenIn, amountIn, recipient);
        }
        _mint(recipient, toMint);
        liquidity = toMint;
    }"
193.md,Reentrancy in buy function for ERC777 tokens allows buying funds with considerable discount,"Current implementation of functions `add`, `remove`, `buy` and `sell` first transfer fractional tokens, and then base tokens.

If this base token is ERC777 (extension of ERC20), we can call this function without updating the base token balance, but updating the fractional token balance.

### Impact

Allows to drain funds of a pairs which implements an ERC-777 token.

### Proof of Concept

function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {
    // *** Checks *** //

    // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used
    require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, ""Invalid ether input"");

    // calculate required input amount using xyk invariant
+   @audit Use current balances
    inputAmount = buyQuote(outputAmount);

    // check that the required amount of base tokens is less than the max amount
    require(inputAmount <= maxInputAmount, ""Slippage: amount in"");

    // *** Effects *** //
+   @audit Modifies just fractional balance
    // transfer fractional tokens to sender
    _transferFrom(address(this), msg.sender, outputAmount);

    // *** Interactions *** //

    if (baseToken == address(0)) {
        // refund surplus eth
        uint256 refundAmount = maxInputAmount - inputAmount;
        if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);
    } else {

        // transfer base tokens in
+       @audit If an ERC-777 token is used, we can re call buy function with the same balance of base token, but with different fractional balance
        ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);

    }
    emit Buy(inputAmount, outputAmount);
}

function buyQuote(uint256 outputAmount) public view returns (uint256) {
    return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);
}

The buy quote is used to calculate the amount of fractional token that the user will receive, and it should be less/equal to **maxInputAmount** sent by parameter in order to achieve a successful execution of function buy.

Current buy quote can be mathematically expressed as: (outputAmount × 1000 × baseTokenReserves) / ((fractionalTokenReserves - outPutAmount) × 997).

Then, about sales

function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {
    // *** Checks *** //

    // calculate output amount using xyk invariant
    outputAmount = sellQuote(inputAmount);

    // check that the outputted amount of fractional tokens is greater than the min amount
    require(outputAmount >= minOutputAmount, ""Slippage: amount out"");

    // *** Effects *** //

    // transfer fractional tokens from sender
+   //@audit fractional balance is updated
    _transferFrom(msg.sender, address(this), inputAmount);

    // *** Interactions *** //

    if (baseToken == address(0)) {
        // transfer ether out
        msg.sender.safeTransferETH(outputAmount);
    } else {
        // transfer base tokens out
+       @audit If an ERC-777 token is used, we can re call sell function with the same balance of base token, but with different fractional balance.
        ERC20(baseToken).safeTransfer(msg.sender, outputAmount);
    }

    emit Sell(inputAmount, outputAmount);
}

function sellQuote(uint256 inputAmount) public view returns (uint256) {
    uint256 inputAmountWithFee = inputAmount * 997;
    return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);
}

Current sellQuote function can be expressed mathematically as:

inputAmount = (inputAmount × 997 × baseTokenReserves) / (fractionalTokenReserves × 1000 + inputAmountWithFee)

Then we can think next scenario to drain a pair which use an ERC-777 token as base token:

1.  Let's suppose the pair has 1000 base tokens(BT777) and 1000 Fractional reserve tokens (FRT)
2.  The attacker call buy function, all with next inputs:
    *   outputAmount = 50
    *   maxInputAmount = 80
3.  The attacker implements a hook, that will be executed 6 times (using a counter inside a malicus contract) when a transfer is done, and call the buy function. After this 6 times the malicious contract is call again, but this times calls the sell function, doing a huge sell for the fractional reserve token obtained.

A simulation of this attack can be visualized in next table

| Operation      | outputAmount (FRT) | maxInputAmount (BT777) | BT777 reserve | FRT reserve | inputAmount (BT777 to pay) | inputAmount < maxInputAmount |
| :------------- | ------------------ | ---------------------- | ------------- | ----------- | -------------------------- | ---------------------------: |
| Attaker buy 1  | 50                 | 80                     | 1000          | 1000        | 52                         |                         TRUE |
| Callback buy 2 | 50                 | 80                     | 1000          | 950         | 55                         |                         TRUE |
| Callback buy 3 | 50                 | 80                     | 1000          | 900         | 59                         |                         TRUE |
| Callback buy 4 | 50                 | 80                     | 1000          | 850         | 62                         |                         TRUE |
| Callback buy 5 | 50                 | 80                     | 1000          | 800         | 66                         |                         TRUE |
| Callback buy 6 | 50                 | 80                     | 1000          | 750         | 71                         |                         TRUE |
| Callback buy 7 | 50                 | 80                     | 1000          | 700         | 77                         |                         TRUE |

The result of this operation is that the attaker/malicious contract has 350 FRT, while BT777 reserve still has 1000 and FRT reserve has 650 tokens. The success execution needs that the attacker pays 442 BT777 eventually.

To do this, the last operation of the malicious contract is calling sell function

| Operation    | inputAmount(BT777) | minOutputAmount | BT777 reserve | FRT reserve | outputAmount (BT777 to receive) | outputAmount > minOutputAmount |
| :----------- | ------------------ | --------------- | ------------- | ----------- | ------------------------------- | -----------------------------: |
| calback Sell | 350                | 442             | 1000          | 650         | 536                             |                           TRUE |

The result is that the attacker now controls 536 BT777, the attacker use this balance to pay the debt of 442 BT77, with a profit of 94 BT77 tokens.",high,"Add openzeppelin nonReentrant modifier to mentioned functions, or state clear in the documentation that this protocol should not be used with ERC777 tokens.","function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)
        public
        payable
        returns (uint256 lpTokenAmount)
    {
        // *** Checks *** //

        // check the token amount inputs are not zero
        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, ""Input token amount is zero"");

        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used
        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, ""Invalid ether input"");

        // calculate the lp token shares to mint
        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);

        // check that the amount of lp tokens outputted is greater than the min amount
        require(lpTokenAmount >= minLpTokenAmount, ""Slippage: lp token amount out"");

        // *** Effects *** //

        // transfer fractional tokens in
        _transferFrom(msg.sender, address(this), fractionalTokenAmount);

        // *** Interactions *** //

        // mint lp tokens to sender
        lpToken.mint(msg.sender, lpTokenAmount);

        // transfer base tokens in if the base token is not ETH
        if (baseToken != address(0)) {
            // transfer base tokens in
            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);
        }

        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);
    }

function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)
        public
        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)
    {
        // *** Checks *** //

        // calculate the output amounts
        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);

        // check that the base token output amount is greater than the min amount
        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, ""Slippage: base token amount out"");

        // check that the fractional token output amount is greater than the min amount
        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, ""Slippage: fractional token out"");

        // *** Effects *** //

        // transfer fractional tokens to sender
        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);

        // *** Interactions *** //

        // burn lp tokens from sender
        lpToken.burn(msg.sender, lpTokenAmount);

        if (baseToken == address(0)) {
            // if base token is native ETH then send ether to sender
            msg.sender.safeTransferETH(baseTokenOutputAmount);
        } else {
            // transfer base tokens to sender
            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);
        }

        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);
    }

function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {
        // *** Checks *** //

        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used
        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, ""Invalid ether input"");

        // calculate required input amount using xyk invariant
        inputAmount = buyQuote(outputAmount);

        // check that the required amount of base tokens is less than the max amount
        require(inputAmount <= maxInputAmount, ""Slippage: amount in"");

        // *** Effects *** //

        // transfer fractional tokens to sender
        _transferFrom(address(this), msg.sender, outputAmount);

        // *** Interactions *** //

        if (baseToken == address(0)) {
            // refund surplus eth
            uint256 refundAmount = maxInputAmount - inputAmount;
            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);
        } else {
            // transfer base tokens in
            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);
        }

        emit Buy(inputAmount, outputAmount);
    }

function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {
        // *** Checks *** //

        // calculate output amount using xyk invariant
        outputAmount = sellQuote(inputAmount);

        // check that the outputted amount of fractional tokens is greater than the min amount
        require(outputAmount >= minOutputAmount, ""Slippage: amount out"");

        // *** Effects *** //

        // transfer fractional tokens from sender
        _transferFrom(msg.sender, address(this), inputAmount);

        // *** Interactions *** //

        if (baseToken == address(0)) {
            // transfer ether out
            msg.sender.safeTransferETH(outputAmount);
        } else {
            // transfer base tokens out
            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);
        }

        emit Sell(inputAmount, outputAmount);
    }"
74.md,DOS pay function,"in the `pay()` function users repay their debt and in line 364: it decreases their debt.

lets say a user wants to repay all his debt, he calls the `pay()` function with his full debt.
an attacker can see it and frontrun to repay a single token for his debt (since it's likely the token uses 18 decimals, a single token is worth almost nothing)
and since your solidity version is above 0.8.0 the line:
`due.debt -= assetsIn[i];` will revert due to underflow

The attacker can keep doing it everytime the user is going to pay and since 1 token is baisicly 0$ (18 decimals) the attacker doesn't lose real money

#### Impact

A DoS on every user that  repay his full debt (or enough that the difference between his total debt to what he pays his negligible)

#### Proof of Concept

From solidity docs

Since Solidity 0.8.0, all arithmetic operations revert on over- and underflow by default, thus making the use of these libraries unnecessary.",medium,if `assetsIn[i]` is bigger than `due.debt` set `assetsIn[i]=due.debt` and `due.debt=0`,"function pay(
        uint256 maturity,
        address to,
        address owner,
        uint256[] memory ids,
        uint112[] memory assetsIn,
        uint112[] memory collateralsOut,
        bytes calldata data
    ) external override lock returns (uint128 assetIn, uint128 collateralOut) {
        require(block.timestamp < maturity, 'E202');
        require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');
        require(to != address(0), 'E201');
        require(to != address(this), 'E204');

        Pool storage pool = pools[maturity];

        Due[] storage dues = pool.dues[owner];

        for (uint256 i; i < ids.length; i++) {
            Due storage due = dues[ids[i]];
            require(due.startBlock != BlockNumber.get(), 'E207');
            if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');
            PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);
            due.debt -= assetsIn[i];
            due.collateral -= collateralsOut[i];
            assetIn += assetsIn[i];
            collateralOut += collateralsOut[i];
        }
        if (assetIn > 0) Callback.pay(asset, assetIn, data);

        pool.state.reserves.asset += assetIn;
        pool.state.reserves.collateral -= collateralOut;

        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut);

        emit Pay(maturity, msg.sender, to, owner, ids, assetsIn, collateralsOut, assetIn, collateralOut);
    }"
131.md,Users can claim more fees than expected if governance migrates current rewardToken again by fault.,"Users can claim more fees than expected if governance migrates current rewardToken again by fault.

In the migrate() function, there is no requirement newRewardToken != rewardToken.
If this function is called with the same ""rewardToken"" parameter, ""_replacedRewardTokens"" will contain the current ""rewardToken"" also.
Then when the user claims fees, ""userShares"" will be added two times for the same token at L302-L305, L314-L317.

It's because ""curRewardTokenData.userFeeIntegrals[user]"" is updated at L332 after the ""userShares"" calculation for past rewardTokens.
So the user can get paid more fees than he should.",medium,"You need to add this require() at L71.

require(newRewardToken != rewardToken, Error.SAME_AS_CURRENT);","function migrate(address newRewardToken) external override onlyGovernance {
        _replacedRewardTokens.remove(newRewardToken);
        _replacedRewardTokens.set(rewardToken, block.timestamp);
        lastMigrationEvent = block.timestamp;
        rewardToken = newRewardToken;
    }"
12.md,Unsafe call to `.decimals`,The `FYToken.constructor` performs an external call to `IERC20Metadata(address(IJoin(join_).asset())).decimals()`. This function was optional in the initial ERC-20 and might fail for old tokens that did not implement it. FyTokens cannot be created for tokens that implemented the old initial ERC20 without the `decimals` function.,low,"Recommend considering using the helper function in the utils to retrieve it `SafeERC20Namer.tokenDecimals`, the same way the `Pool.constructor` works.","constructor(
        bytes6 underlyingId_,
        IOracle oracle_, // Underlying vs its interest-bearing version
        IJoin join_,
        uint256 maturity_,
        string memory name,
        string memory symbol
    ) ERC20Permit(name, symbol, IERC20Metadata(address(IJoin(join_).asset())).decimals()) { // The join asset is this fyToken's underlying, from which we inherit the decimals
        uint256 now_ = block.timestamp;
        require(
            maturity_ > now_ &&
            maturity_ < now_ + MAX_TIME_TO_MATURITY &&
            maturity_ < type(uint32).max,
            ""Invalid maturity""
        );

        underlyingId = underlyingId_;
        join = join_;
        maturity = maturity_;
        underlying = address(IJoin(join_).asset());
        setOracle(oracle_);
    }"
17.md,`BaseVaultAdaptor` assumes `sharePrice` is always in underlying decimals,"The two `BaseVaultAdaptor.calculateShare` functions compute `share = amount.mul(uint256(10)**decimals).div(sharePrice)`

This assumes that the `sharePrice` is always in _token_ decimals and that _token_ decimals is the same as _vault_ decimals.

Both these assumptions happen to be correct for Yearn vaults, but that will not necessarily be the case for other protocols.
As this functionality is in the `BaseVaultAdaptor`, and not in the specific `VaultAdaptorYearnV2_032`, consider generalizing the conversion.

Integrating a token where the token or price is reported in a different precision will lead to potential losses as more shares are computed.

Because the conversion seems highly protocol-specific, it is recommended that `calculateShare` should be an abstract function (like `_getVaultSharePrice`) that is implemented in the specific adaptors.",medium,"Because the conversion seems highly protocol-specific, it is recommended that `calculateShare` should be an abstract function (like `_getVaultSharePrice`) that is implemented in the specific adaptors.","function calculateShare(uint256 amount) private view returns (uint256 share) {
        uint256 sharePrice = _getVaultSharePrice();
        share = amount.mul(uint256(10)**decimals).div(sharePrice);
        uint256 balance = IERC20(vault).balanceOf(address(this));
        share = share < balance ? share : balance;
    }"
58.md,Bad redirects can make it impossible to deposit & withdraw,"The `GatewayVault._push()` function gets `redirects` from the `strategyParams`. If `redirects[i] = j`, vault index `i`'s deposits are redirected to vault index `j`.

Note that the deposits for vault index `i` are cleared, as they are redirected:

for (uint256 j = 0; j < _vaultTokens.length; j++) {
    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];
    amountsByVault[vaultIndex][j] += amountsByVault[i][j];
    amountsByVault[i][j] = 0;
}

The same is true for withdrawals in the `_pull` function. Users might not be able to withdraw this way.

If the `redirects` array is misconfigured, it's possible that all `amountsByVault` are set to zero. For example, if `0` redirects to `1` and `1` redirects to `0`. Or `0` redirects to itself, etc. There are many misconfigurations that can lead to not being able to deposit to the pool anymore.",medium,"The `redirects[i] = j` matrix needs to be restricted. If `i` is redirected to `j`, `j` may not redirect itself. Check for this when setting the `redirects` array.","function _push(uint256[] memory tokenAmounts, bytes memory options)
        internal
        override
        returns (uint256[] memory actualTokenAmounts)
    {
        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);
        bool optimized;
        bytes[] memory vaultsOptions;
        (optimized, vaultsOptions) = _parseOptions(options);

        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256[][] memory tvls = subvaultsTvl();
        uint256[] memory totalTvl = new uint256[](_vaultTokens.length);
        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);
        IGatewayVaultGovernance.DelayedStrategyParams memory strategyParams = IGatewayVaultGovernance(
            address(_vaultGovernance)
        ).delayedStrategyParams(_nft);
        if (optimized && strategyParams.redirects.length > 0) {
            for (uint256 i = 0; i < _subvaultNfts.length; i++) {
                if (strategyParams.redirects[i] == 0) {
                    continue;
                }
                for (uint256 j = 0; j < _vaultTokens.length; j++) {
                    uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];
                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];
                    amountsByVault[i][j] = 0;
                }
            }
        }
        actualTokenAmounts = new uint256[](_vaultTokens.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            if (optimized && (strategyParams.redirects[i] != 0)) {
                continue;
            }
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                if (amountsByVault[i][j] > 0) {
                    _allowTokenIfNecessary(_vaultTokens[j], address(vault));
                }
            }
            uint256[] memory actualVaultTokenAmounts = vault.transferAndPush(
                address(this),
                _vaultTokens,
                amountsByVault[i],
                vaultsOptions[i]
            );
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                actualTokenAmounts[j] += actualVaultTokenAmounts[j];
                totalTvl[j] += tvls[i][j];
            }
        }
        uint256[] memory _limits = IGatewayVaultGovernance(address(_vaultGovernance)).strategyParams(_nft).limits;
        for (uint256 i = 0; i < _vaultTokens.length; i++) {
            require(totalTvl[i] + actualTokenAmounts[i] < _limits[i], ExceptionsLibrary.LIMIT_OVERFLOW);
        }
    }

function _pull(
        address to,
        uint256[] memory tokenAmounts,
        bytes memory options
    ) internal override returns (uint256[] memory actualTokenAmounts) {
        (bool optimized, bytes[] memory vaultsOptions) = _parseOptions(options);

        require(_subvaultNfts.length > 0, ExceptionsLibrary.INITIALIZATION);
        IVaultRegistry registry = _vaultGovernance.internalParams().registry;
        uint256[][] memory tvls = subvaultsTvl();
        uint256[][] memory amountsByVault = CommonLibrary.splitAmounts(tokenAmounts, tvls);
        uint256[] memory _redirects = IGatewayVaultGovernance(address(_vaultGovernance))
            .delayedStrategyParams(_nft)
            .redirects;

        if (optimized && (_redirects.length > 0)) {
            for (uint256 i = 0; i < _subvaultNfts.length; i++) {
                if (_redirects[i] == 0) {
                    continue;
                }
                for (uint256 j = 0; j < _vaultTokens.length; j++) {
                    uint256 vaultIndex = _subvaultNftsIndex[_redirects[i]];
                    amountsByVault[vaultIndex][j] += amountsByVault[i][j];
                    amountsByVault[i][j] = 0;
                }
            }
        }
        actualTokenAmounts = new uint256[](_vaultTokens.length);
        for (uint256 i = 0; i < _subvaultNfts.length; i++) {
            IVault vault = IVault(registry.vaultForNft(_subvaultNfts[i]));
            uint256[] memory actualVaultTokenAmounts = vault.pull(
                to,
                _vaultTokens,
                amountsByVault[i],
                vaultsOptions[i]
            );
            for (uint256 j = 0; j < _vaultTokens.length; j++) {
                actualTokenAmounts[j] += actualVaultTokenAmounts[j];
            }
        }
    }"
89.md,All AMMs have to be past nextFundingTime to update,"settleFunding calls will revert until all AMMs are ready to be updated.

Proof of Concept

AMM 1 has a nextFundingTime of now. AMM 2 has a nextFundingTime in 30 minutes. AMM 1 won't be able to be updated until after AMM 2's nextFundingTime elapses.",medium,You shouldn't revert at the place mentioned in the links to affected code. Just return so that the other AMMs can still get updated.,"function settleFunding()
        override
        external
        onlyClearingHouse
    {
        if (ammState != AMMState.Active) return;
        require(_blockTimestamp() >= nextFundingTime, ""settle funding too early"");

        // premium = twapMarketPrice - twapIndexPrice
        // timeFraction = fundingPeriod(1 hour) / 1 day
        // premiumFraction = premium * timeFraction
        int256 underlyingPrice = getUnderlyingTwapPrice(spotPriceTwapInterval);
        int256 premium = getTwapPrice(spotPriceTwapInterval) - underlyingPrice;
        int256 premiumFraction = (premium * int256(fundingPeriod)) / 1 days;

        // update funding rate = premiumFraction / twapIndexPrice
        _updateFundingRate(premiumFraction, underlyingPrice);

        int256 premiumPerDtoken = posAccumulator * premiumFraction;

        // makers pay slightly more to account for rounding off
        premiumPerDtoken = (premiumPerDtoken / BASE_PRECISION) + 1;

        cumulativePremiumFraction += premiumFraction;
        cumulativePremiumPerDtoken += premiumPerDtoken;

        // Updates for next funding event
        // in order to prevent multiple funding settlement during very short time after network congestion
        uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod;

        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600
        uint256 nextFundingTimeOnHourStart = ((nextFundingTime + fundingPeriod) / 1 hours) * 1 hours;

        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)
        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime
            ? nextFundingTimeOnHourStart
            : minNextValidFundingTime;
    }"
20.md,Mismatch in event definition,"In synthFactory.sol, there's an `event CreateSynth(address indexed token, address indexed pool)`. However the event is emitted with ""synth"" as second output.",low,"Recommend thinking about what's the better variable to be emitted, and correct one of the lines.","function createSynth(address token) external returns(address synth){
        require(getSynth(token) == address(0), ""exists""); // Synth must not already exist
        address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address
        require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true, ""!curated""); // Pool must be Curated
        Synth newSynth; address _token = token;
        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB
        newSynth = new Synth(BASE, _token); // Deploy synth asset contract
        synth = address(newSynth); // Get new synth's address
        addSynth(_token, synth); // Record new synth contract with the SynthFactory
        emit CreateSynth(token, synth);
        return synth;
    }"
64.md,`cancelPromotion()` Unable to cancel unstarted promotions,"For unstarted promotions, `cancelPromotion()` will revert at `block.timestamp - _promotion.startTimestamp` in `_getCurrentEpochId()`. Call stack: `cancelPromotion()` -> `_getRemainingRewards()` -> `_getCurrentEpochId()`.

```solidity
function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
    // _tokensPerEpoch * _numberOfEpochsLeft
    return
        _promotion.tokensPerEpoch *
        (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
}
```

```solidity
function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
    // elapsedTimestamp / epochDurationTimestamp
    return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;
}
```",medium,Consider checking if `_promotion.startTimestamp > block.timestamp` and refund `_promotion.tokensPerEpoch * _promotion.numberOfEpochs` in `cancelPromotion()`.,"function cancelPromotion(uint256 _promotionId, address _to)
        external
        override
        onlyPromotionCreator(_promotionId)
        returns (bool)
    {
        Promotion memory _promotion = _getPromotion(_promotionId);

        _requirePromotionActive(_promotion);
        require(_to != address(0), ""TwabRewards/recipient-not-zero-address"");

        uint256 _remainingRewards = _getRemainingRewards(_promotion);

        delete _promotions[_promotionId];
        _promotion.token.safeTransfer(_to, _remainingRewards);

        emit PromotionCancelled(_promotionId, _remainingRewards);

        return true;
    }

function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {
        // elapsedTimestamp / epochDurationTimestamp
        return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;
    }

function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {
        // _tokensPerEpoch * _numberOfEpochsLeft
        return
            _promotion.tokensPerEpoch *
            (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));
    }"
107.md,Wrong calculation for `yVault` price per share if decimals != 18,"The yVault.getPricePerFullShare() function calculates the price per share by multiplying with 1e18 token decimals with the assumption that the underlying token always has 18 decimals. yVault has the same amount of decimals as its underlying token (see yVault.decimals()). But tokens don't always have 1e18 decimals (e.g. USDC).

Impact

The price per share calculation does not return the correct price for underlying tokens that do not have 18 decimals. This could lead to paying out too little or too much and therefore to a loss for either the protocol or the user.

Proof of Concept

Following test will fail with the current implementation when the underlying vault token has 6 decimals:

NOTE: units() helper function was adapted to accept the desired decimals.

it.only(""should mint the correct amount of tokens for tokens with 6 decimals"", async () => {
  const DECIMALS = 6;

  await token.setDecimals(DECIMALS);
  expect(await yVault.decimals()).to.equal(DECIMALS);

  expect(await yVault.getPricePerFullShare()).to.equal(0);
  await token.mint(user1.address, units(1000, DECIMALS));
  await token.connect(user1).approve(yVault.address, units(1000, DECIMALS));

  await yVault.connect(user1).deposit(units(500, DECIMALS));
  expect(await yVault.balanceOf(user1.address)).to.equal(units(500, DECIMALS));

  await token.mint(strategy.address, units(500, DECIMALS));
  expect(await yVault.getPricePerFullShare()).to.equal(units(2, DECIMALS));
});

Fails with following error: AssertionError: Expected ""2000000000000000000"" to be equal 2000000",medium,"Use vault decimals() instead of hardcoded 1e18 decimals.

function getPricePerFullShare() external view returns (uint256) {
    uint256 supply = totalSupply();
    if (supply == 0) return 0;
    return (balance() * (10**decimals())) / supply; // use decimals() instead of hardcoded 1e18
}","function getPricePerFullShare() external view returns (uint256) {
        uint256 supply = totalSupply();
        if (supply == 0) return 0;
        return (balance() * 1e18) / supply;
    }"
59.md,Users Can Contribute To An Auction Without Directly Committing Collateral Tokens,"`purchaseArbitrageTokens` enables users to commit collateral tokens and in return receive arbitrage tokens which are redeemable in the future for Malt tokens. Each auction specifies a commitment cap which when reached, prevents users from participating in the auction. However, `realCommitment` can be ignored by directly sending the `LiquidityExtension` contract collateral tokens and subsequently calling `purchaseArbitrageTokens`.

#### Proof of Concept

Consider the following scenario:

*   An auction is currently active.
*   A user sends collateral tokens to the `LiquidityExtension` contract.
*   The same user calls `purchaseArbitrageTokens` with amount `0`.
*   The `purchaseAndBurn` call returns a positive `purchased` amount which is subsequently used in auction calculations.

As a result, a user could effectively influence the average malt price used throughout the `Auction` contract.",medium,Consider adding a check to ensure that `realCommitment != 0` in `purchaseArbitrageTokens`.,"function purchaseArbitrageTokens(uint256 amount) external notSameBlock {
    require(auctionActive(currentAuctionId), ""No auction running"");

    uint256 realCommitment = _capCommitment(currentAuctionId, amount);

    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);

    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);
    
    AuctionData storage auction = idToAuction[currentAuctionId];

    require(auction.startingTime <= now, ""Auction hasn't started yet"");
    require(auction.endingTime >= now, ""Auction is already over"");
    require(auction.active == true, ""Auction is not active"");

    auction.commitments = auction.commitments.add(realCommitment);

    if (auction.accountCommitments[msg.sender].commitment == 0) {
      accountCommitmentEpochs[msg.sender].push(currentAuctionId);
    }
    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);
    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);
    auction.maltPurchased = auction.maltPurchased.add(purchased);

    emit AuctionCommitment(
      nextCommitmentId,
      currentAuctionId,
      msg.sender,
      realCommitment,
      purchased
    );

    nextCommitmentId = nextCommitmentId + 1;

    if (auction.commitments >= auction.maxCommitments) {
      _endAuction(currentAuctionId) ;
    }
  }"
61.md,Collateral can be deposited in a finished pool,The depositCollateral function doesn't check the status of the pool so collateral can be deposited in a finished loan. This can happen by mistake and all funds will be lost.,medium,Require loan status to be collection or active in the depositCollateral function.,"function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }"
83.md,`StakingRewards.sol#notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards,"In the current implementation, the contract only checks if balanceOf rewardsToken is greater than or equal to the future rewards.

However, under normal circumstances, since users can not withdraw all their rewards in time, the balance in the contract contains rewards that belong to the users but have not been withdrawn yet. This means the current checks can not be sufficient enough to make sure the contract has enough amount of rewardsToken.

As a result, if the rewardsDistribution mistakenly notifyRewardAmount with a larger amount, the contract may end up in a wrong state that makes some users unable to claim their rewards.

### Proof of Concept

Given:

*   rewardsDuration = 7 days;

1.  Alice stakes 1,000 stakingToken;
2.  rewardsDistribution sends 100 rewardsToken to the contract;
3.  rewardsDistribution calls notifyRewardAmount() with amount = 100;
4.  7 days later, Alice calls earned() and it returns 100 rewardsToken, but Alice choose not to getReward() for now;
5.  rewardsDistribution calls notifyRewardAmount() with amount = 100 without send any fund to contract, the tx will succees;
6.  7 days later, Alice calls earned() 200 rewardsToken, when Alice tries to call getReward(), the transaction will fail due to insufficient balance of rewardsToken.

Expected Results:

The tx in step 5 should revert.",medium,"Consider changing the function notifyRewardAmount to addRward and use transferFrom to transfer rewardsToken into the contract:

function addRward(uint256 reward)
    external
    updateReward(address(0))
{
    require(
        msg.sender == rewardsDistribution,
        ""Caller is not RewardsDistribution contract""
    );

    if (block.timestamp >= periodFinish) {
        rewardRate = reward / rewardsDuration;
    } else {
        uint256 remaining = periodFinish - block.timestamp;
        uint256 leftover = remaining * rewardRate;
        rewardRate = (reward + leftover) / rewardsDuration;
    }

    rewardsToken.safeTransferFrom(msg.sender, address(this), reward);

    lastUpdateTime = block.timestamp;
    periodFinish = block.timestamp + rewardsDuration;
    emit RewardAdded(reward);
}","function notifyRewardAmount(uint256 reward)
        external
        updateReward(address(0))
    {
        require(
            msg.sender == rewardsDistribution,
            ""Caller is not RewardsDistribution contract""
        );

        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - block.timestamp;
            uint256 leftover = remaining * rewardRate;
            rewardRate = (reward + leftover) / rewardsDuration;
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint256 balance = rewardsToken.balanceOf(address(this));
        require(
            rewardRate <= balance / rewardsDuration,
            ""Provided reward too high""
        );

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp + rewardsDuration;
        emit RewardAdded(reward);
    }"
98.md,`ConfigTimeLockController` will put `QuantConfig` in a stalemate (rendering it unusable),"The QuantConfig contract has these important setters, setProtocolAddress(), setProtocolUint256, setProtocolBoolean() and setProtocolRole(). This contract is subjected to a timelock before all such processes above are executed. But, the issue arises in the fact that in configTimeLockController, the state variable minimum delay can be set to an arbitrary value, up to type(uint256).max (cannot assume what value will be set) and could potentially render the QuantConfig contract unusable. All the previous values and addresses would not be able to be changed because of a very high delay being set.

After discussions with one of the devs, it was understood that these values are for the rollaOrderFee which is a part of their limit order protocol contract (outside of the scope of the contest) but given the argument above, its configuration will be severely impacted (old percentage fees won't be able to be changed). Rolla limit order protocol depends on this configuration setting within QuantConfig.",medium,"It is recommended that a constant be declared with a MAXIMUM_DELAY and whatever ‘minimum delay’ that is set thereafter should be below this value since there's another function setDelay() which can also be of high arbitrary value:

require(minimum delay ≤MAXIMUM_DELAY, “ too high”)","function setDelay(bytes32 _protocolValue, uint256 _newDelay)
        external
        onlyRole(EXECUTOR_ROLE)
    {
        // Delays must be greater than or equal to the minimum delay
        delays[_protocolValue] = _newDelay >= minDelay ? _newDelay : minDelay;
    }function setProtocolAddress(bytes32 _protocolAddress, address _newValue)
        external
        override
        onlyOwner
    {
        require(
            _protocolAddress != ProtocolValue.encode(""priceRegistry"") ||
                !protocolBooleans[ProtocolValue.encode(""isPriceRegistrySet"")],
            ""QuantConfig: priceRegistry can only be set once""
        );
        address previousValue = protocolAddresses[_protocolAddress];
        protocolAddresses[_protocolAddress] = _newValue;
        configuredProtocolAddresses.push(_protocolAddress);
        isProtocolValueSet[_protocolAddress][ProtocolValue.Type.Address] = true;

        if (_protocolAddress == ProtocolValue.encode(""priceRegistry"")) {
            protocolBooleans[ProtocolValue.encode(""isPriceRegistrySet"")] = true;
        }

        emit SetProtocolAddress(_protocolAddress, previousValue, _newValue);
    }

function setProtocolUint256(bytes32 _protocolUint256, uint256 _newValue)
        external
        override
        onlyOwner
    {
        uint256 previousValue = protocolUints256[_protocolUint256];
        protocolUints256[_protocolUint256] = _newValue;
        configuredProtocolUints256.push(_protocolUint256);
        isProtocolValueSet[_protocolUint256][ProtocolValue.Type.Uint256] = true;

        emit SetProtocolUint256(_protocolUint256, previousValue, _newValue);
    }

function setProtocolBoolean(bytes32 _protocolBoolean, bool _newValue)
        external
        override
        onlyOwner
    {
        require(
            _protocolBoolean != ProtocolValue.encode(""isPriceRegistrySet"") ||
                !protocolBooleans[ProtocolValue.encode(""isPriceRegistrySet"")],
            ""QuantConfig: can only change isPriceRegistrySet once""
        );
        bool previousValue = protocolBooleans[_protocolBoolean];
        protocolBooleans[_protocolBoolean] = _newValue;
        configuredProtocolBooleans.push(_protocolBoolean);
        isProtocolValueSet[_protocolBoolean][ProtocolValue.Type.Bool] = true;

        emit SetProtocolBoolean(_protocolBoolean, previousValue, _newValue);
    }

function setProtocolRole(string calldata _protocolRole, address _roleAdmin)
        external
        override
        onlyOwner
    {
        _setProtocolRole(_protocolRole, _roleAdmin);
    }"
74.md,borrow() function has state updates after a callback to msg.sender,"In TimeswapPair.sol, the `borrow()` function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to collateral, totalDebtCreated and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.",high,"The callback Callback.borrow(collateral, dueOut.collateral, data); should be placed at the end of the borrow() function after all state updates have taken place.","function borrow(
        uint256 maturity,
        address assetTo,
        address dueTo,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease,
        bytes calldata data
    ) external override lock returns (uint256 id, Due memory dueOut) {
        require(block.timestamp < maturity, 'E202');
        require(assetTo != address(0) && dueTo != address(0), 'E201');
        require(assetTo != address(this) && dueTo != address(this), 'E204');
        require(xDecrease > 0, 'E205');

        Pool storage pool = pools[maturity];
        require(pool.state.totalLiquidity > 0, 'E206');

        BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);

        dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);
        dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);
        dueOut.startBlock = BlockNumber.get();

        Callback.borrow(collateral, dueOut.collateral, data);

        id = pool.dues[dueTo].insert(dueOut);

        pool.state.reserves.asset -= xDecrease;
        pool.state.reserves.collateral += dueOut.collateral;
        pool.state.totalDebtCreated += dueOut.debt;

        pool.state.x -= xDecrease;
        pool.state.y += yIncrease;
        pool.state.z += zIncrease;

        asset.safeTransfer(assetTo, xDecrease);

        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut);
    }"
192.md,Chainlink price feed is not sufficiently validated and can return stale price,"As mentioned by the Tigris protocol documentation, ""Prices provided by the oracle network are also compared to Chainlink's public price feeds for additional security. If prices have more than a 2% difference the transaction is reverted."" The Chainlink price verification logic in the `TradingLibrary.verifyPrice` function serves this purpose. However, besides that `IPrice(_chainlinkFeed).latestAnswer()` uses Chainlink's deprecated `latestAnswer` function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale. When `assetChainlinkPriceInt != 0` is true, it is still possible that `assetChainlinkPriceInt` is stale in which the Chainlink price verification would compare the off-chain price against a stale price returned by the Chainlink price feed. For an off-chain price that has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, which makes the price verification much less secure.

The relevant code snippet is:

```solidity
function verifyPrice(
    uint256 _validSignatureTimer,
    uint256 _asset,
    bool _chainlinkEnabled,
    address _chainlinkFeed,
    PriceData calldata _priceData,
    bytes calldata _signature,
    mapping(address => bool) storage _isNode
)
    external view
{
    ...
    if (_chainlinkEnabled && _chainlinkFeed != address(0)) {
        int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();
        if (assetChainlinkPriceInt != 0) {
            uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());
            require(
                _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&
                _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, ""!chainlinkPrice""
            );
        }
    }
}
```

Based on Chainlink's historical price data documentation, the following can be done to avoid using a stale price returned by the Chainlink price feed:

1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function.
2. `roundId` and `answeredInRound` are also returned. You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh.
3. A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. To check the round, validate that the timestamp on that round is not 0.

Proof of Concept:

1. Alice calls the `Trading.initiateMarketOrder` function, which eventually calls the `TradingLibrary.verifyPrice` function, to initiate a market order.
2. When the `TradingLibrary.verifyPrice` function is called, the off-chain price is compared to the price returned by the Chainlink price feed for the position asset.
3. The price returned by the Chainlink price feed is stale, and the off-chain price has less than a 2% difference when comparing to this stale price.
4. Alice's `Trading.initiateMarketOrder` transaction goes through. However, this transaction should revert because the off-chain price has more than a 2% difference if comparing to a more current price returned by the Chainlink price feed.",medium,"The recommended mitigation steps are to update the code at the specified line in TradingLibrary.sol to use Chainlink's `latestRoundData` function instead of the deprecated `latestAnswer` function. The updated code should be:

```solidity
(uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = IPrice(_chainlinkFeed).latestRoundData();
require(answeredInRound >= roundId, ""price is stale"");
require(updatedAt > 0, ""round is incomplete"");
```

This ensures that the price data is fresh by verifying that the answer is not stale and that the round is complete before proceeding with price verification.","function verifyPrice(
        uint256 _validSignatureTimer,
        uint256 _asset,
        bool _chainlinkEnabled,
        address _chainlinkFeed,
        PriceData calldata _priceData,
        bytes calldata _signature,
        mapping(address => bool) storage _isNode
    )
        external view
    {
        address _provider = (
            keccak256(abi.encode(_priceData))
        ).toEthSignedMessageHash().recover(_signature);
        require(_provider == _priceData.provider, ""BadSig"");
        require(_isNode[_provider], ""!Node"");
        require(_asset == _priceData.asset, ""!Asset"");
        require(!_priceData.isClosed, ""Closed"");
        require(block.timestamp >= _priceData.timestamp, ""FutSig"");
        require(block.timestamp <= _priceData.timestamp + _validSignatureTimer, ""ExpSig"");
        require(_priceData.price > 0, ""NoPrice"");
        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {
            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();
            if (assetChainlinkPriceInt != 0) {
                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());
                require(
                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&
                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, ""!chainlinkPrice""
                );
            }
        }
    }"
30.md,No safety check in `addToken`,"There's no safety check in Manager.sol addToken. There are two possible cases that might happen.

1.  One token being added twice in a Vault. Token would be counted doubly in the vault. There would be two item in the array when querying manager.getTokens(address(this)).

2.  A token first being added to two vaults. The value calculation of the first vault would be broken. As vaults[_token] = _vault; would point to the other vault.

Permission keys should always be treated cautiously. However, calling the same initialize function twice should not be able to destroy the vault. Also, as the protocol develops, there's likely that one token is supported in two vaults. The DAO may mistakenly add the same token twice. I consider this a high-risk issue.",high,"I recommend to add two checks

require(vaults[_token] == address(0));
bool notFound = True;
for(uint256 i; i < tokens[_vault].length; i++) {
    if (tokens[_vault] == _token) {
        notFound = False;
    }
}
require(notFound, ""duplicate token"");","function addToken(
        address _vault,
        address _token
    )
        external
        override
        notHalted
        onlyStrategist
    {
        require(allowedTokens[_token], ""!allowedTokens"");
        require(allowedVaults[_vault], ""!allowedVaults"");
        require(tokens[_vault].length < MAX_TOKENS, "">tokens"");
        require(vaults[_token] == address(0), ""!_token"");
        vaults[_token] = _vault;
        tokens[_vault].push(_token);
        emit TokenAdded(_vault, _token);
    }"
16.md,Potential Out-of-Gas exception due to unbounded loop,"Trading function `executeTrade()` batch executes maker/taker orders against a market. The trader/interface provides arrays of makers/takers which is unbounded. As a result, if the number of orders is too many, there is a risk of this transaction exceeding the block gas limit (which is 15 million currently). See Trader.sol L67 and L78

The impact is that if `executeTrade()` is called with too many orders in the batch, the transaction might exceed block gas limit and revert, resulting in none of the orders are executed.

See similar medium-severity finding from ConsenSys's Audit of Growth DeFi: potential resource exhaustion by external calls performed within an unbounded loop.",low,"Recommend limiting the number or orders executed based on `gasleft()` after every iteration, or estimating the gas cost and enforcing an upper bound on the number of orders allowed in maker/taker arrays.","function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)
        external
        override
    {
        require(makers.length == takers.length, ""TDR: Lengths differ"");

        // safe as we've already bounds checked the array lengths
        uint256 n = makers.length;

        require(n > 0, ""TDR: Received empty arrays"");

        for (uint256 i = 0; i < n; i++) {
            // verify each order individually and together
            if (
                !isValidSignature(makers[i].order.maker, makers[i]) ||
                !isValidSignature(takers[i].order.maker, takers[i]) ||
                !isValidPair(takers[i], makers[i])
            ) {
                // skip if either order is invalid
                continue;
            }

            // retrieve orders
            // if the order does not exist, it is created here
            Perpetuals.Order memory makeOrder = grabOrder(makers, i);
            Perpetuals.Order memory takeOrder = grabOrder(takers, i);

            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);
            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);

            uint256 makeOrderFilled = filled[makerOrderId];
            uint256 takeOrderFilled = filled[takerOrderId];

            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);

            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);
            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(
                makeOrderFilled,
                averageExecutionPrice[makerOrderId],
                fillAmount,
                executionPrice
            );
            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(
                takeOrderFilled,
                averageExecutionPrice[takerOrderId],
                fillAmount,
                executionPrice
            );

            // match orders
            // referencing makeOrder.market is safe due to above require
            // make low level call to catch revert
            // todo this could be succeptible to re-entrancy as
            // market is never verified
            (bool success, ) = makeOrder.market.call(
                abi.encodePacked(
                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,
                    abi.encode(makeOrder, takeOrder, fillAmount)
                )
            );

            // ignore orders that cannot be executed
            if (!success) continue;

            // update order state
            filled[makerOrderId] = makeOrderFilled + fillAmount;
            filled[takerOrderId] = takeOrderFilled + fillAmount;
            averageExecutionPrice[makerOrderId] = newMakeAverage;
            averageExecutionPrice[takerOrderId] = newTakeAverage;
        }
    }"
35.md,ConcentratedLiquidityPoolManager.sol `claimReward()` and `reclaimIncentive()` will fail when `incentive.token` is `token0` or `token1`,"In `ConcentratedLiquidityPosition.collect()`, balances of `token0` and `token1` in bento will be used to pay the fees.

In the case of someone add an incentive with `token0` or `token1`, the incentive in the balance of bento will be used to pay fees until the balance is completely consumed.

As a result, when a user calls `claimReward()`, the contract may not have enough balance to pay (it supposed to have it), cause the transaction to fail.

The same issue applies to `reclaimIncentive()` as well.",medium,"Consider making adding `token0` or `token1` as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when `collect()`.","function collect(
        uint256 tokenId,
        address recipient,
        bool unwrapBento
    ) external returns (uint256 token0amount, uint256 token1amount) {
        require(msg.sender == ownerOf[tokenId], ""NOT_ID_OWNER"");

        Position storage position = positions[tokenId];

        (address token0, address token1) = _getAssets(position.pool);

        {
            (uint256 feeGrowthInside0, uint256 feeGrowthInside1) = position.pool.rangeFeeGrowth(position.lower, position.upper);
            token0amount = FullMath.mulDiv(
                feeGrowthInside0 - position.feeGrowthInside0,
                position.liquidity,
                0x100000000000000000000000000000000
            );
            token1amount = FullMath.mulDiv(
                feeGrowthInside1 - position.feeGrowthInside1,
                position.liquidity,
                0x100000000000000000000000000000000
            );

            position.feeGrowthInside0 = feeGrowthInside0;
            position.feeGrowthInside1 = feeGrowthInside1;
        }

        uint256 balance0 = bento.balanceOf(token0, address(this));
        uint256 balance1 = bento.balanceOf(token1, address(this));
        if (balance0 < token0amount || balance1 < token1amount) {
            (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);

            uint256 newBalance0 = amount0fees + balance0;
            uint256 newBalance1 = amount1fees + balance1;

            /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw
            if (token0amount > newBalance0) token0amount = newBalance0;
            if (token1amount > newBalance1) token1amount = newBalance1;
        }
        _transfer(token0, address(this), recipient, token0amount, unwrapBento);
        _transfer(token1, address(this), recipient, token1amount, unwrapBento);
    }function reclaimIncentive(
        IConcentratedLiquidityPool pool,
        uint256 incentiveId,
        uint256 amount,
        address receiver,
        bool unwrapBento
    ) public {
        Incentive storage incentive = incentives[pool][incentiveId];
        require(incentive.owner == msg.sender, ""NOT_OWNER"");
        require(incentive.expiry < block.timestamp, ""EXPIRED"");
        require(incentive.rewardsUnclaimed >= amount, ""ALREADY_CLAIMED"");
        _transfer(incentive.token, address(this), receiver, amount, unwrapBento);
        emit ReclaimIncentive(pool, incentiveId);
    }

function claimReward(
        uint256 positionId,
        uint256 incentiveId,
        address recipient,
        bool unwrapBento
    ) public {
        require(ownerOf[positionId] == msg.sender, ""OWNER"");
        Position memory position = positions[positionId];
        IConcentratedLiquidityPool pool = position.pool;
        Incentive storage incentive = incentives[position.pool][positionId];
        Stake storage stake = stakes[positionId][incentiveId];
        require(stake.initialized, ""UNINITIALIZED"");
        uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;
        uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;
        uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;
        uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);
        uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;
        incentive.rewardsUnclaimed -= rewards;
        incentive.secondsClaimed += uint160(secondsInside);
        stake.secondsInsideLast += uint160(secondsPerLiquidityInside);
        _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);
        emit ClaimReward(positionId, incentiveId, recipient);
    }"
79.md,Re-enterable Code When Making a Deposit to Stake,"Note: this attack requires `rJoe` to relinquish control during `tranfer()` which under the current RocketJoeToken it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.

This vulnerability would allow the entire rJoe balance to be drained from the contract.

#### Proof of Concept

The function deposit() would be vulnerable to reentrancy if rJoe relinquished control flow.

The following lines show the reward calculations in variable `pending`. These calculations use two state variables `user.amount` and `user.rewardDebt`. Each of these are updated after `_safeRJoeTransfer()`.

Thus if an attacker was able to get control flow during the `rJoe::tranfer()` function they would be able to reenter `deposit()` and the value calculated for `pending`would be the same as the previous iteration hence they would again be transferred `pending` rJoe tokens. During the rJoe transfer the would again gain control of the execution and call `deposit()` again. The process could be repeated until the entire rJoe balance of the contract has been transferred to the attacker.

```solidity
if (user.amount > 0) {
    uint256 pending = (user.amount * accRJoePerShare) /
        PRECISION -
        user.rewardDebt;
    _safeRJoeTransfer(msg.sender, pending);
}
user.amount = user.amount + _amount;
user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;
```",medium,"There are two possible mitigations. First is to use the openzeppelin reentrancy guard over the `deposit()` function which will prevent multiple deposits being made simultaneously.

The second mitigation is to follow the checks-effects-interactions pattern. This would involve updating all state variables before making any external calls.","function deposit(uint256 _amount) external {
        UserInfo storage user = userInfo[msg.sender];

        updatePool();

        if (user.amount > 0) {
            uint256 pending = (user.amount * accRJoePerShare) /
                PRECISION -
                user.rewardDebt;
            _safeRJoeTransfer(msg.sender, pending);
        }
        user.amount = user.amount + _amount;
        user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;

        joe.safeTransferFrom(address(msg.sender), address(this), _amount);
        emit Deposit(msg.sender, _amount);
    }"
42.md,`MochiTreasuryV0.withdrawLock()` Is Callable When Locking Has Been Toggled,"withdrawLock() does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.",medium,"Consider adding `require(lockCrv, ""!lock"");` to `withdrawLock()` to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.","function withdrawLock() external {
        veCrv.withdraw();
    }"
5.md,Unhandled return value of transfer in `transferOut()` of Pools.sol,"ERC20 implementations are not always consistent. Some implementations of transfer and `transferFrom` could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into `require()` statements to handle these failures.

The transfer call on L211 of `transferOut()` could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.

For reference, see similar finding from Consensys Diligence Audit of AAVE Protocol V2",high,Recommend requirements to check the return value and revert on 0/false or use OpenZeppelin’s SafeERC20 wrapper functions.,"function transferOut(address _token, uint _amount, address _recipient) internal {
        if(_token == VADER){
            pooledVADER = pooledVADER - _amount; // Accounting
        } else if(_token == USDV) {
            pooledUSDV = pooledUSDV - _amount;  // Accounting
        }
        if(_recipient != address(this)){
            iERC20(_token).transfer(_recipient, _amount);
        }
    }"
71.md,Signature replay,"The `redeem` method of `PoolTemplate` verifies the data stored in `incident`, and the verification logic of this process is performed as following:
```solidity
require(
    MerkleProof.verify(
        _merkleProof,
        _targets,
        keccak256(
            abi.encodePacked(_insurance.target, _insurance.insured)
        )
    ) ||
        MerkleProof.verify(
            _merkleProof,
            _targets,
            keccak256(abi.encodePacked(_insurance.target, address(0)))
        ),
    ""ERROR: INSURANCE_EXEMPTED""
);
```

As can be seen, the only data related to the `_insurance` are `target` and `insured`, so as the incident has no relation with the `Insurance`, apparently nothing prevents a user to call `insure` with high amounts, after receive the incident, the only thing that prevents this from being reused is that the owner creates the incident with an `_incidentTimestamp` from the past.

So if an owner create a incident from the future it's possible to create a new `insure` that could be reused by the same affected address.

Another lack of input verification that could facilitate this attack is the `_span=0` in the `insure` method.",medium,It is mandatory to add a check in `applyCover` that `_incidentTimestamp` is less than the current date and the `span` argument is greater than 0 in the `insure` method.,"function insure(
        uint256 _amount,
        uint256 _maxCost,
        uint256 _span,
        bytes32 _target
    ) external returns (uint256) {
        //Distribute premium and fee
        uint256 _endTime = _span + block.timestamp;
        uint256 _premium = getPremium(_amount, _span);
        uint256 _fee = parameters.getFeeRate(msg.sender);

        require(
            _amount <= availableBalance(),
            ""ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE""
        );
        require(_premium <= _maxCost, ""ERROR: INSURE_EXCEEDED_MAX_COST"");
        require(_span <= 365 days, ""ERROR: INSURE_EXCEEDED_MAX_SPAN"");
        require(
            parameters.getMinDate(msg.sender) <= _span,
            ""ERROR: INSURE_SPAN_BELOW_MIN""
        );

        require(
            marketStatus == MarketStatus.Trading,
            ""ERROR: INSURE_MARKET_PENDING""
        );
        require(paused == false, ""ERROR: INSURE_MARKET_PAUSED"");

        //current liquidity
        uint256 _liquidity = totalLiquidity();
        uint256 _totalCredit = totalCredit;

        //accrue premium/fee
        uint256[2] memory _newAttribution = vault.addValueBatch(
            _premium,
            msg.sender,
            [address(this), parameters.getOwner()],
            [MAGIC_SCALE_1E6 - _fee, _fee]
        );

        //Lock covered amount
        uint256 _id = allInsuranceCount;
        lockedAmount += _amount;
        Insurance memory _insurance = Insurance(
            _id,
            block.timestamp,
            _endTime,
            _amount,
            _target,
            msg.sender,
            true
        );
        insurances[_id] = _insurance;
        allInsuranceCount += 1;

        //Calculate liquidity for index
        if (_totalCredit > 0) {
            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /
                _liquidity;
            attributionDebt += _attributionForIndex;
            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /
                _totalCredit);
        }

        emit Insured(
            _id,
            _amount,
            _target,
            block.timestamp,
            _endTime,
            msg.sender,
            _premium
        );

        return _id;
    }

function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {
        Insurance storage _insurance = insurances[_id];
        require(_insurance.status == true, ""ERROR: INSURANCE_NOT_ACTIVE"");

        uint256 _payoutNumerator = incident.payoutNumerator;
        uint256 _payoutDenominator = incident.payoutDenominator;
        uint256 _incidentTimestamp = incident.incidentTimestamp;
        bytes32 _targets = incident.merkleRoot;

        require(
            marketStatus == MarketStatus.Payingout,
            ""ERROR: NO_APPLICABLE_INCIDENT""
        );
        require(_insurance.insured == msg.sender, ""ERROR: NOT_YOUR_INSURANCE"");
        require(
            marketStatus == MarketStatus.Payingout &&
                _insurance.startTime <= _incidentTimestamp &&
                _insurance.endTime >= _incidentTimestamp,
            ""ERROR: INSURANCE_NOT_APPLICABLE""
        );
        require(
            MerkleProof.verify(
                _merkleProof,
                _targets,
                keccak256(
                    abi.encodePacked(_insurance.target, _insurance.insured)
                )
            ) ||
                MerkleProof.verify(
                    _merkleProof,
                    _targets,
                    keccak256(abi.encodePacked(_insurance.target, address(0)))
                ),
            ""ERROR: INSURANCE_EXEMPTED""
        );
        _insurance.status = false;
        lockedAmount -= _insurance.amount;

        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /
            _payoutDenominator;

        vault.borrowValue(_payoutAmount, msg.sender);

        emit Redeemed(
            _id,
            msg.sender,
            _insurance.target,
            _insurance.amount,
            _payoutAmount
        );
    }

function applyCover(
        uint256 _pending,
        uint256 _payoutNumerator,
        uint256 _payoutDenominator,
        uint256 _incidentTimestamp,
        bytes32 _merkleRoot,
        string calldata _rawdata,
        string calldata _memo
    ) external override onlyOwner {
        require(paused == false, ""ERROR: UNABLE_TO_APPLY"");
        incident.payoutNumerator = _payoutNumerator;
        incident.payoutDenominator = _payoutDenominator;
        incident.incidentTimestamp = _incidentTimestamp;
        incident.merkleRoot = _merkleRoot;
        marketStatus = MarketStatus.Payingout;
        pendingEnd = block.timestamp + _pending;
        for (uint256 i = 0; i < indexList.length; i++) {
            if (indicies[indexList[i]].credit > 0) {
                IIndexTemplate(indexList[i]).lock();
            }
        }
        emit CoverApplied(
            _pending,
            _payoutNumerator,
            _payoutDenominator,
            _incidentTimestamp,
            _merkleRoot,
            _rawdata,
            _memo
        );
        emit MarketStatusChanged(marketStatus);
    }"
5.md,Misleading comment for `deposit()` function of `Vault.sol`,"Misleading comment on line 76 that says `deposit()` function allows USDV and Synths, but the code only allows Synths. Use of accurate comments helps users read, audit and maintain code. Inaccurate comments can be misleading, obstruct the flagging of vulnerabilities, or even introduce them.",low,"Recommend using accurate and descriptive comments (even NatSpec) correctly describing the function behavior, parameters and return values.","function deposit(address synth, uint amount) external {
        depositForMember(synth, msg.sender, amount);
    }"
49.md,Timelock and events for governor functions,"There are contracts that contain functions that change important parameters of the system, e.g. OverlayV1Mothership has setOVL, initializeMarket, disableMarket, enableMarket, initializeCollateral, enableCollateral, disableCollateral, adjustGlobalParams. None of these functions emit events, nor they are timelocked. Usually, it is a good practice to give time for users to react and adjust to changes.

A similar issue was submitted in a previous contest and assigned a severity of Medium: A previous contest report highlighted a similar issue.",medium,Consider using a timelock for critical params of the system and emitting events to inform the outside world.,"function setOVL (address _ovl) external onlyGovernor {

        ovl = _ovl;

    }

function initializeMarket(address market) external onlyGovernor {

        require(!marketExists[market], ""OVLV1:!!initialized"");

        marketExists[market] = true;
        marketActive[market] = true;

        allMarkets.push(market);

    }

function disableMarket(address market) external onlyGovernor {

        require(marketActive[market], ""OVLV1: !enabled"");

        marketActive[market] = false;

    }

function enableMarket(address market) external onlyGovernor {

        require(marketExists[market], ""OVLV1: !exists"");

        require(!marketActive[market], ""OVLV1: !disabled"");

        marketActive[market] = true;

    }

function initializeCollateral (address _collateral) external onlyGovernor {

        require(!collateralExists[_collateral], ""OVLV1:!!iintialized"");

        collateralExists[_collateral] = true;
        collateralActive[_collateral] = true;

        allCollateral.push(_collateral);

        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);

        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);

    }

function enableCollateral (address _collateral) external onlyGovernor {

        require(collateralExists[_collateral], ""OVLV1:!exists"");

        require(!collateralActive[_collateral], ""OVLV1:!disabled"");

        OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);

        OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);

    }

function disableCollateral (address _collateral) external onlyGovernor {

        require(collateralActive[_collateral], ""OVLV1:!enabled"");

        OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);

        OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);

    }

function adjustGlobalParams(
        uint16 _fee,
        uint16 _feeBurnRate,
        address _feeTo
    ) external onlyGovernor {
        fee = _fee;
        feeBurnRate = _feeBurnRate;
        feeTo = _feeTo;
    }"
16.md,Trader orders can be front-run and users can be denied from trading,"The `Trader` contract accepts two signed orders and tries to match them. Once they are matched and become filled, they can therefore not be matched against other orders anymore.

This allows for a griefing attack where an attacker can deny any other user from trading by observing the mempool and front-running their trades by creating their own order and match it against the counter order instead.

In this way, a trader can be denied from trading. The cost of the griefing attack is that the trader has to match the order themselves, however depending on the liquidity of the order book and the spread, they might be able to do the counter-trade again afterwards, basically just paying the fees.

It could be useful if the attacker is a liquidator and is stopping a user who is close to liquidation from becoming liquid again.

This seems hard to circumvent in the current design. If the order book is also off-chain, the `executeTrade` could also be a bot-only function.",medium,"Tracer will initially maintain an off chain order book that is the entry point for users to make orders (and for market makers to interact with). Orders only get propagated on chain once they have been matched, and they will only be propagated on chain by whitelisted relayers. As such nobody can arbitrarily frontrun the orders with their own.","function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)
        external
        override
    {
        require(makers.length == takers.length, ""TDR: Lengths differ"");

        // safe as we've already bounds checked the array lengths
        uint256 n = makers.length;

        require(n > 0, ""TDR: Received empty arrays"");

        for (uint256 i = 0; i < n; i++) {
            // verify each order individually and together
            if (
                !isValidSignature(makers[i].order.maker, makers[i]) ||
                !isValidSignature(takers[i].order.maker, takers[i]) ||
                !isValidPair(takers[i], makers[i])
            ) {
                // skip if either order is invalid
                continue;
            }

            // retrieve orders
            // if the order does not exist, it is created here
            Perpetuals.Order memory makeOrder = grabOrder(makers, i);
            Perpetuals.Order memory takeOrder = grabOrder(takers, i);

            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);
            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);

            uint256 makeOrderFilled = filled[makerOrderId];
            uint256 takeOrderFilled = filled[takerOrderId];

            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);

            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);
            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(
                makeOrderFilled,
                averageExecutionPrice[makerOrderId],
                fillAmount,
                executionPrice
            );
            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(
                takeOrderFilled,
                averageExecutionPrice[takerOrderId],
                fillAmount,
                executionPrice
            );

            // match orders
            // referencing makeOrder.market is safe due to above require
            // make low level call to catch revert
            // todo this could be succeptible to re-entrancy as
            // market is never verified
            (bool success, ) = makeOrder.market.call(
                abi.encodePacked(
                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,
                    abi.encode(makeOrder, takeOrder, fillAmount)
                )
            );

            // ignore orders that cannot be executed
            if (!success) continue;

            // update order state
            filled[makerOrderId] = makeOrderFilled + fillAmount;
            filled[takerOrderId] = takeOrderFilled + fillAmount;
            averageExecutionPrice[makerOrderId] = newMakeAverage;
            averageExecutionPrice[takerOrderId] = newTakeAverage;
        }
    }"
12.md,Uninitialized or Incorrectly set `auctionInterval` may lead to liquidation engine livelock,"The `grab()` function in Cauldron is used by the Witch or other liquidation engines to grab vaults that are under-collateralized. To prevent re-grabbing without sufficient time for auctioning collateral/debt, the logic uses an `auctionInterval` threshold to give a reasonable window to a liquidation engine that has grabbed the vault.

The `grab()` function has a comment on Line 354: ""// Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that."" indicating a requirement of the `auctionInterval` being equal to one day. This can happen only if the `auctionInterval` is set appropriately. However, this state variable is uninitialized (defaults to 0) and depends on `setAuctionInterval()` being called with the appropriate `auctionInterval_` value, which is also not validated.

Discussion with the project lead indicated that this comment is incorrect. Nevertheless, it is safer to initialize `auctionInterval` at declaration to a safe default value instead of the current 0, which will allow liquidation engines to re-grab vaults without making any progress on liquidation auction. It is also good to add a threshold check-in `setAuctionInterval()` to ensure the new value meets/exceeds a reasonable default value.

The rationale for Medium-severity impact: While the likelihood of this may be low, the impact is high because liquidation engines will keep re-grabbing vaults from each other and potentially result in liquidation bots entering a live-lock situation without making any progress on liquidation auctions. This will result in collateral being stuck and impact the entire protocol's functioning. So, with low likelihood and high impact, the severity (according to OWASP) is medium.",medium,"1. Initialize `auctionInterval` at declaration with a reasonable default value.
2. Add a threshold check in `setAuctionInterval()` to ensure the new value meets/exceeds a reasonable default value.","function setAuctionInterval(uint32 auctionInterval_)
        external
        auth
    {
        auctionInterval = auctionInterval_;
        emit AuctionIntervalSet(auctionInterval_);
    }

function grab(bytes12 vaultId, address receiver)
        external
        auth
    {
        uint32 now_ = uint32(block.timestamp);
        require (auctions[vaultId] + auctionInterval <= now_, ""Vault under auction"");        // Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.

        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);
        require(_level(vault_, balances_, series_) < 0, ""Not undercollateralized"");

        auctions[vaultId] = now_;
        _give(vaultId, receiver);

        emit VaultLocked(vaultId, now_);
    }"
61.md,`PriceOracle` Does Not Filter Price Feed Outliers,"If for whatever reason the Chainlink oracle returns a malformed price due to oracle manipulation or a malfunctioned price, the result will be passed onto users, causing unintended consequences as a result.

In the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.

The above code outlines how prices are utilised regardless of their actual value (assuming it is always a non-zero value).",high,"Consider querying both the Chainlink oracle and Uniswap pool for latest prices, ensuring that these two values are within some upper/lower bounds of each other. It may also be useful to track historic values and ensure that there are no sharp changes in price. However, the first option provides a level of simplicity as UniswapV3's TWAP implementation is incredibly resistant to flash loan attacks. Hence, the main issue to address is a malfunctioning Chainlink oracle.","function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_decimals != 0) {
            return (_price, _decimals);
        }
        revert(""PriceOracle::getLatestPrice - Price Feed doesn't exist"");
    }"
98.md,`OperateProxy.callFunction()` should check if the `callee` is a contract,"As the OperateProxy.sol#callFunction() function not payable, we believe it's not the desired behavior to call a non-contract address and consider it a successful call.

For example, if a certain business logic requires a successful token.transferFrom() call to be made with the OperateProxy, if the token is not a existing contract, the call will return success: true instead of success: false and break the caller's assumption and potentially malfunction features or even cause fund loss to users.

The qBridge exploit (January 2022) was caused by a similar issue.

As a reference, OpenZeppelin's Address.functionCall() will check and require(isContract(target), ""Address: call to non-contract"");",medium,Consider adding a check and throw when the callee is not a contract.,"function callFunction(address callee, bytes memory data) external override {
        require(
            callee != address(0),
            ""OperateProxy: cannot make function calls to the zero address""
        );

        (bool success, bytes memory returnData) = address(callee).call(data);
        require(success, ""OperateProxy: low-level call failed"");
        emit FunctionCallExecuted(tx.origin, returnData);
    }"
36.md,`Auction.sol#settleAuction()` Mishandling bounty state could potentially disrupt `settleAuction()`,"In the `withdrawBounty` function, `bounty.active` should be set to `false` when the bounty is claimed.

However, since `bounty` is stored in memory, the state update will not succeed.

##### Impact

An auction successfully bonded by a regular user won't be able to be settled if they passed seemly active bountyIds, and the bonder will lose the bond.

##### Proof of Concept

1.  Create an auction;
2.  Add a bounty;
3.  Auction settled with bounty claimed;
4.  Create a new auction;
5.  Add a new bounty;
6.  Calling `settleAuction()` with the bountyIds of the 2 seemly active bounties always reverts.",medium,"Change to:

```solidity
Bounty storage bounty = _bounties[bountyIds[i]];
```","function withdrawBounty(uint256[] memory bountyIds) internal {
        // withdraw bounties
        for (uint256 i = 0; i < bountyIds.length; i++) {
            Bounty memory bounty = _bounties[bountyIds[i]];
            require(bounty.active);

            IERC20(bounty.token).transfer(msg.sender, bounty.amount);
            bounty.active = false;

            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);
        }
    }"
66.md,Fee not decayed if past `decayTime`,"The `ThreePieceWiseLinearPriceCurve.calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0 && decay < decayTime` case, but for the `decay > decayTime` case it does not decay at all but should set it to 0 instead.

if (decay > 0 && decay < decayTime) {
    // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay > decayTime should return 0.
    fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime));
} else {
    fee = lastFeePercent;
}",medium,"It seems wrong to handle the `decay == 0` case (decay happened in same block) the same way as the `decay >= decayTime` case (decay happened long time ago) as is done in the `else` branch. I believe it should be like this instead:

// decay == 0 case should be full lastFeePercent
if(decay < decayTime) {
    fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime));
} else {
    // reset to zero if decay >= decayTime
    fee = 0;
}","function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        // Decay within bounds of decay time, then decay the fee. 
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            // If it has been longer than decay time, then reset fee to 0.
            fee = 0;
        }
    }"
36.md,licenseFee can be greater than BASE,"Worst case - no functions that contains `handleFees()` can pass because line 118 will always underflow and revert. You only need `feePct` to be bigger than `BASE` for the `handleFees()` function to fail which will result in a lot of gas wasted and potentially bond burnt.

I did not classify this as high risk because a simple fix would be to simply reduce the licenseFee via `changeLicenseFee`.",medium,"Add these require statement to the following functions:

*   Basket.changeLicenseFee()
    *   `require(newLicenseFee <= BASE, ""changeLicenseFee: license fee cannot be greater than 100%"");`
*   Factory.proposeBasketLicense()
    *   `require(licenseFee <= BASE, ""proposeBasketLicense: license fee cannot be greater than 100%"");`","function handleFees() private {
        if (lastFee == 0) {
            lastFee = block.timestamp;
        } else {
            uint256 startSupply = totalSupply();

            uint256 timeDiff = (block.timestamp - lastFee);
            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;
            uint256 fee = startSupply * feePct / (BASE - feePct);

            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);
            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);
            lastFee = block.timestamp;

            uint256 newIbRatio = ibRatio * startSupply / totalSupply();
            ibRatio = newIbRatio;

            emit NewIBRatio(ibRatio);
        }
    }

function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {
        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);
        if (pendingLicenseFee.licenseFee != 0) {
            require(pendingLicenseFee.licenseFee == newLicenseFee);
            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);
            licenseFee = pendingLicenseFee.licenseFee;

            pendingLicenseFee.licenseFee = 0;

            emit ChangedLicenseFee(licenseFee);
        } else {
            pendingLicenseFee.licenseFee = newLicenseFee;
            pendingLicenseFee.block = block.number;
        }
    }function proposeBasketLicense(
        uint256 licenseFee, 
        string memory tokenName, 
        string memory tokenSymbol, 
        address[] memory tokens,
        uint256[] memory weights
    ) public override returns (uint256 id) {
        basketImpl.validateWeights(tokens, weights);

        require(licenseFee >= minLicenseFee);

        // create proposal object
        Proposal memory proposal = Proposal({
            licenseFee: licenseFee,
            tokenName: tokenName,
            tokenSymbol: tokenSymbol,
            proposer: address(msg.sender),
            tokens: tokens,
            weights: weights,
            basket: address(0)
        });

        emit BasketLicenseProposed(msg.sender, tokenName);
        _proposals.push(proposal);

        return _proposals.length - 1;
    }"
192.md,Lock.sol: assets deposited with Lock.extendLock function are lost,"The `Lock` contract allows end-users to interact with bonds.

There are two functions that allow to lock some amount of assets. The first function is `Lock.lock` which creates a new bond. The second function is `Lock.extendLock`. This function extends the lock for some `_period` and/or increases the locked amount by some `_amount`.

The issue is that the `Lock.extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `Lock.release` is called.

Therefore only the amount of assets deposited via `Lock.lock` can be released again. The amount of assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.

So the amount of assets deposited using `Lock.extendLock` is lost.

Proof of Concept:
1. User A calls `Lock.lock` to lock a certain `_amount` (amount1) of `_asset` for a certain `_period`.
2. User A calls then `Lock.extendLock` and increases the locked amount of the bond by some amount2.
3. User A waits until the bond has expired.
4. User A calls `Lock.release`. This function calculates `totalLocked[asset] -= lockAmount;`. Which will cause a revert because the value of `totalLocked[asset]` is only amount1.

This causes an underflow error and the assets deposited using `Lock.extendLock` are effectively lost.",high,Add `totalLocked[_asset] += amount` to the `Lock.extendLock` function to correctly track the total locked assets and prevent underflow errors during release.,"function lock(
        address _asset,
        uint _amount,
        uint _period
    ) public {
        require(_period <= maxPeriod, ""MAX PERIOD"");
        require(_period >= minPeriod, ""MIN PERIOD"");
        require(allowedAssets[_asset], ""!asset"");

        claimGovFees();

        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        totalLocked[_asset] += _amount;
        
        bondNFT.createLock( _asset, _amount, _period, msg.sender);
    }

function extendLock(
        uint _id,
        uint _amount,
        uint _period
    ) public {
        address _asset = claim(_id);
        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);
        bondNFT.extendLock(_id, _asset, _amount, _period, msg.sender);
    }

function release(
        uint _id
    ) public {
        claimGovFees();
        (uint amount, uint lockAmount, address asset, address _owner) = bondNFT.release(_id, msg.sender);
        totalLocked[asset] -= lockAmount;
        IERC20(asset).transfer(_owner, amount);
    }"
145.md,The `unwrapETH2LD` use `transferFrom` instead of `safeTransferFrom` to transfer ERC721 token,"The `unwrapETH2LD` use `transferFrom` to transfer ERC721 token, the `newRegistrant` could be an unprepared contract.

Proof of Concept

Should a ERC-721 compatible token be transferred to an unprepared contract, it would end up being locked up there. Moreover, if a contract explicitly wanted to reject ERC-721 safeTransfers.
Plus take a look to the OZ safeTransfer comments:
`Usage of this method is discouraged, use safeTransferFrom whenever possible.`",medium,Replace the use of `transferFrom` with `safeTransferFrom` in the `unwrapETH2LD` function to ensure that tokens are only transferred to contracts that are prepared to handle them. This change will prevent tokens from being locked in contracts that do not support receiving ERC721 tokens.,"function unwrapETH2LD(
        bytes32 labelhash,
        address newRegistrant,
        address newController
    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {
        _unwrap(_makeNode(ETH_NODE, labelhash), newController);
        registrar.transferFrom(
            address(this),
            newRegistrant,
            uint256(labelhash)
        );
    }"
17.md,Stricter than needed inequalities may affect borderline scenarios,"Token amounts/prices are typically open-ranged and inclusive of the bounds. Using ‘<‘ or ‘>’ instead of ‘<=‘ and ‘>=‘ may affect borderline scenarios, be considered unintuitive by users, and affect accounting.

- Scenario 1: In calculateVaultSwapData(), the require() check is:
require(withdrawAmount < state.totalCurrentAssetsUsd, ""Withdrawal exceeds system assets"");
The ‘<‘ could be replaced by ‘<=‘

Scenario 2: In withdrawSingleByLiquidity(), the require() check is:
require(balance > minAmount, ""withdrawSingle: !minAmount"");
The ‘>’ should be ‘>=‘ as is used in the similar check in withdrawSingleByExchange().",low,Recommend reconsidering strict inequalities and relaxing them if possible.,"function calculateVaultSwapData(uint256 withdrawAmount)
        private
        view
        returns (uint256[N_COINS] memory swapInAmounts, uint256[N_COINS] memory swapOutPercents)
    {
        // Calculate total assets and total number of strategies
        SystemState memory state = prepareCalculation();

        require(withdrawAmount < state.totalCurrentAssetsUsd, ""Withdrawal exceeds system assets"");
        state.totalCurrentAssetsUsd = state.totalCurrentAssetsUsd.sub(withdrawAmount);

        StablecoinAllocationState memory stableState = allocation.calcVaultTargetDelta(state, false);
        swapInAmounts = stableState.swapInAmounts;
        swapOutPercents = stableState.swapOutPercents;
    }function withdrawSingleByLiquidity(
        uint256 i,
        uint256 minAmount,
        address recipient
    ) external override returns (uint256, uint256) {
        require(msg.sender == withdrawHandler, ""withdrawSingleByLiquidity: !withdrawHandler"");
        IERC20 coin = IERC20(getToken(i));
        crv3pool.remove_liquidity_one_coin(lpToken.balanceOf(address(this)), int128(i), 0);
        uint256 balance = coin.balanceOf(address(this)).sub(assets[i]);
        require(balance > minAmount, ""withdrawSingle: !minAmount"");
        coin.safeTransfer(recipient, balance);
        return (buoy.singleStableToUsd(balance, i), balance);
    }

function withdrawSingleByExchange(
        uint256 i,
        uint256 minAmount,
        address recipient
    ) external override returns (uint256 usdAmount, uint256 balance) {
        require(msg.sender == withdrawHandler, ""withdrawSingleByExchange: !withdrawHandler"");
        IERC20 coin = IERC20(getToken(i));
        balance = coin.balanceOf(address(this)).sub(assets[i]);
        // Are available assets - locked assets for LP vault more than required
        // minAmount. Then estimate USD value and transfer...
        if (minAmount <= balance) {
            uint256[N_COINS] memory inAmounts;
            inAmounts[i] = balance;
            usdAmount = buoy.stableToUsd(inAmounts, false);
            // ...if not, swap other loose assets into target assets before
            // estimating USD value and transfering.
        } else {
            for (uint256 j; j < N_COINS; j++) {
                if (j == i) continue;
                IERC20 inCoin = IERC20(getToken(j));
                uint256 inBalance = inCoin.balanceOf(address(this)).sub(assets[j]);
                if (inBalance > 0) {
                    _exchange(inBalance, int128(j), int128(i));
                    if (coin.balanceOf(address(this)).sub(assets[i]) >= minAmount) {
                        break;
                    }
                }
            }
            balance = coin.balanceOf(address(this)).sub(assets[i]);
            uint256[N_COINS] memory inAmounts;
            inAmounts[i] = balance;
            usdAmount = buoy.stableToUsd(inAmounts, false);
        }
        require(balance >= minAmount);
        coin.safeTransfer(recipient, balance);
    }"
45.md,Rebalance will fail due to low precision of percentages,"The `AssetManager.rebalance` function has a check at the end to ensure that all tokens are deposited again:

```solidity
require(token.balanceOf(address(this)) == 0, ""AssetManager: there are remaining funds in the fund pool"");
```

The idea is that the last market deposits all `remainingTokens` but the last market does not have to support the token in which case the transaction will fail, or the `percentages` parameter needs to be chosen to distribute all tokens before the last one (they need to add up to `1e4`). However, these percentages have a low precision as they are in base points, i.e, the lowest unit is `1 = 0.01%`.
This will leave dust in the contract in most cases as the tokens have much higher precision.

#### POC
Assume the last market does not support the token and thus `percentages` are chosen as `[5000, 5000]` to rebalance the first two markets.
Withdrawing all tokens form the markets leads to a `tokenSupply = token.balanceOf(address(this)) = 10,001`:

Then the deposited amount is `amountToDeposit = (tokenSupply * percentages[i]) / 10000 = 10,001 * 5,000 / 10,000 = 5,000`.
The two deposits will leave dust of `10,001 - 2 * 5,000 = 1` in the contract and the `token.balanceOf(address(this)) == 0` balance check will revert.

#### Impact
Rebalancing will fail in most cases if the last market does not support the token due to precision errors.",medium,"Remove the final zero balance check, or make sure that the last market that is actually deposited to receives all remaining tokens.","function rebalance(address tokenAddress, uint256[] calldata percentages)
        external
        override
        checkMarketSupported(tokenAddress)
        onlyAdmin
    {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        require(percentages.length + 1 == moneyMarkets.length, ""AssetManager: percentages error"");

        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                continue;
            }
            moneyMarkets[i].withdrawAll(tokenAddress, address(this));
        }

        uint256 tokenSupply = token.balanceOf(address(this));

        for (uint256 i = 0; i < percentages.length; i++) {
            if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                continue;
            }
            uint256 amountToDeposit = (tokenSupply * percentages[i]) / 10000;
            if (amountToDeposit == 0) {
                continue;
            }
            token.safeTransfer(address(moneyMarkets[i]), amountToDeposit);
            moneyMarkets[i].deposit(tokenAddress);
        }

        uint256 remainingTokens = token.balanceOf(address(this));
        if (moneyMarkets[moneyMarkets.length - 1].supportsToken(tokenAddress) && remainingTokens > 0) {
            token.safeTransfer(address(moneyMarkets[moneyMarkets.length - 1]), remainingTokens);
            moneyMarkets[moneyMarkets.length - 1].deposit(tokenAddress);
        }

        require(token.balanceOf(address(this)) == 0, ""AssetManager: there are remaining funds in the fund pool"");

        emit LogRebalance(tokenAddress, percentages);
    }"
83.md,`USDMPegRecovery.sol#provide()` Improper design/implementation make it often unable to add liquidity to the `usdm3crv` pool,"In the current implementation of `USDMPegRecovery.sol#provide()`, `addingLiquidity` is calculated solely based on `usdm` balance (truncate at a step of 250k), and it always uses the same amount of 3pool tokens to add_liquidity with.

Based on other functions of the contract, the balance of `usdm` can usually be more than the `pool3` balance, in that case, `usdm3crv.add_liquidity()` will fail.

### Impact

When the balance of `pool3` is less than `usdm` (which is can be a common scenario), funds cannot be added to the curve pool.

For example:

When the contract got 5M of USDM and 4.2M of `pool3` tokens, it won't be possible to call `provide()` and add liquidity to the `usdm3crv` pool, as there are not enough pool3 tokens to match the 5M of USDM yet.

We expect it to add liquidity with 4M of USDM and 4M of pool3 tokens in that case.",medium,"Change to:

```solidity
function provide(uint256 _minimumLP) external onlyGuardian {
    require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, ""<liquidity"");
    uint256 tokenBalance = Math.min(usdm.balanceOf(address(this), pool3.balanceOf(address(this));
    // truncate amounts under step
    uint256 addingLiquidity = (tokenBalance / step) * step;
    // match usdm : pool3 = 1 : 1
    uint256[2] memory amounts = [addingLiquidity, addingLiquidity];
    usdm.approve(address(usdm3crv), addingLiquidity);
    pool3.approve(address(usdm3crv), addingLiquidity);
    usdm3crv.add_liquidity(amounts, _minimumLP);
}
```","function provide(uint256 _minimumLP) external onlyGuardian {
        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, ""<liquidity"");
        // truncate amounts under step
        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;
        // match usdm : pool3 = 1 : 1
        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];
        usdm.approve(address(usdm3crv), addingLiquidity);
        pool3.approve(address(usdm3crv), addingLiquidity);
        usdm3crv.add_liquidity(amounts, _minimumLP);
    }"
54.md,Potential economic attack on UDT grants to the referrer,"In the current implementation, `Unlock.sol#recordKeyPurchase()` will send `estimatedGasForPurchase * tx.gasprice` worth of UDT to the referrer.

We believe there are multiple potential economic attack vectors to exploit this.

If `estimatedGasForPurchase` is misconfigured to a higher amount than the actual avg gas cost for a purchase call, or future network upgrades make the actual gas cost become lower than the configured `estimatedGasForPurchase`, it can be exploited simply by creating a lock and call `purchase()` many times to mint UDT.

Even if `estimatedGasForPurchase` is configured to an amount similar to the actual gas cost, a more sophisticated attack is still possible:

#### Proof of Concept

Given:

*   `estimatedGasForPurchase` is configured as `200,000`;
*   The gas cost of a regular purchase call is about `200,000`.

The attacker can create a lock contract and set the token address to a special gas saving token, which will SELFDESTRUCT to get a gas refund on `transfer`.

The attacker can:

1.  Mint gas saving token with gas price: `1 gwei`;
2.  Call `purchase()` and use 48 contract slots with gas price: `1000 gwei`;

Total gas saved will be ~0.8 ETH (or other native tokens, eg. BNB, MATIC). Therefore, the attacker will profit ~0.8 ETH worth of UDT.

As the protocol may leak value based on certain network assumptions, this is considered medium severity: vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.

The tokens that are used to compute GDP and distribute tokens have to be approved by the DAO (right now only USDC, DAI and BAT have been approved on mainnet, and only USDC on Polygon). It is unlikely the DAO would approve gas tokens given that they could result in leakage of UDT, so this is considered minor.",medium,"Consider setting a global daily upper limit of total UDT grants to referrers, plus, an upper limit for UDT minted per purchase.","function recordKeyPurchase(
    uint _value,
    address _referrer
  )
    public
    onlyFromDeployedLock()
  {
    if(_value > 0) {
      uint valueInETH;
      address tokenAddress = IPublicLock(msg.sender).tokenAddress();
      if(tokenAddress != address(0) && tokenAddress != weth) {
        // If priced in an ERC-20 token, find the supported uniswap oracle
        IUniswapOracle oracle = uniswapOracles[tokenAddress];
        if(address(oracle) != address(0)) {
          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);
        }
      }
      else {
        // If priced in ETH (or value is 0), no conversion is required
        valueInETH = _value;
      }

      grossNetworkProduct = grossNetworkProduct + valueInETH;
      // If GNP does not overflow, the lock totalSales should be safe
      locks[msg.sender].totalSales += valueInETH;

      // Mint UDT
      if(_referrer != address(0))
      {
        IUniswapOracle udtOracle = uniswapOracles[udt];
        if(address(udtOracle) != address(0))
        {
          // Get the value of 1 UDT (w/ 18 decimals) in ETH
          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);

          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut
          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;

          // or tokensToDistribute is capped by network GDP growth
          uint maxTokens = 0;
          if (chainId > 1)
          {
            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5
            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));
            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;
          } else {
            // Mainnet: we mint new token using log curve
            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;
          }

          // cap to GDP growth!
          if(tokensToDistribute > maxTokens)
          {
            tokensToDistribute = maxTokens;
          }

          if(tokensToDistribute > 0)
          {
            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer
            uint devReward = tokensToDistribute * 20 / 100;
            if (chainId > 1)
            {
              uint balance = IMintableERC20(udt).balanceOf(address(this));
              if (balance > tokensToDistribute) {
                // Only distribute if there are enough tokens
                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);
                IMintableERC20(udt).transfer(owner(), devReward);
              }
            } else {
              // No distribnution
              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);
              IMintableERC20(udt).mint(owner(), devReward);
            }
          }
        }
      }
    }
  }"
36.md,Basket becomes unusable if everybody burns their shares,"While handling the fees, the contract calculates the new `ibRatio` by dividing by `totalSupply`. This can be 0 leading to a division by 0.

Impact

If everybody burns their shares, in the next mint, `totalSupply` will be 0, `handleFees` will revert, and so nobody will be able to use the basket anymore.

Proof of Concept

Vulnerable line:
You can add the following test to Basket.test.js and see that it reverts:
```js
it(""should divide by 0"", async () => {
await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));
await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));

    await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));
    await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));
    await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));
    await basket.connect(addr1).mint(ethers.BigNumber.from(1));
});
```

Tools Used

Manual analysis, hardhat.",medium,"Add a check to `handleFees`: if `totalSupply= 0`, you can just return, no need to calculate new `ibRatio` / fees. You might want to reset `ibRatio` to BASE at this point.","function handleFees() private {
        if (lastFee == 0) {
            lastFee = block.timestamp;
        } else {
            uint256 startSupply = totalSupply();

            uint256 timeDiff = (block.timestamp - lastFee);
            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;
            uint256 fee = startSupply * feePct / (BASE - feePct);

            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);
            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);
            lastFee = block.timestamp;

            uint256 newIbRatio = ibRatio * startSupply / totalSupply();
            ibRatio = newIbRatio;

            emit NewIBRatio(ibRatio);
        }
    }"
100.md,Withdrawal delay can be circumvented,"After initiating a withdrawal with `initiateWithdrawal`, it's still possible to transfer the collateral tokens. This can be used to create a second account, transfer the accounts to them and initiate withdrawals at a different time frame such that one of the accounts is always in a valid withdrawal window, no matter what time it is. If the token owner now wants to withdraw they just transfer the funds to the account that is currently in a valid withdrawal window.

Also, note that each account can withdraw the specified `amount`. Creating several accounts and circling & initiating withdrawals with all of them allows withdrawing larger amounts **even at the same block** as they are purchased in the future.

I consider this high severity because it breaks core functionality of the Collateral token.

### Proof of Concept

For example, assume the `_delayedWithdrawalExpiry = 20` blocks. Account A owns 1000 collateral tokens, they create a second account B.

*   At `block=0`, A calls `initiateWithdrawal(1000)`. They send their balance to account B.
*   At `block=10`, B calls `initiateWithdrawal(1000)`. They send their balance to account A.
*   They repeat these steps, alternating the withdrawal initiation every 10 blocks.
*   One of the accounts is always in a valid withdrawal window (`initiationBlock < block && block <= initiationBlock + 20`). They can withdraw their funds at any time.",high,"If there's a withdrawal request for the token owner (`_accountToWithdrawalRequest[owner].blockNumber > 0`), disable their transfers for the time.

// pseudo-code not tested
beforeTransfer(from, to, amount) {
  super();
  uint256 withdrawalStart =  _accountToWithdrawalRequest[from].blockNumber;
  if(withdrawalStart > 0 && withdrawalStart + _delayedWithdrawalExpiry < block.number) {
    revert(); // still in withdrawal window
  }
}","function initiateWithdrawal(uint256 _amount) external override {
        /**
         * Checking the balance before initiation is necessary since a user
         * could initiate an unlimited withdrawal amount ahead of time,
         * negating the protection a delayed withdrawal offers.
         */
        require(balanceOf(msg.sender) >= _amount, ""Insufficient balance"");
        _accountToWithdrawalRequest[msg.sender].amount = _amount;
        _accountToWithdrawalRequest[msg.sender].blockNumber = block.number;
    }"
26.md,Deposits don't work with fee-on transfer tokens,"There are ERC20 tokens that may make certain customizations to their ERC20 contracts. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`. Others are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).

The `RCTreasury.deposit()` function will credit more deposits than the contract actually received:

```solidity
erc20.safeTransferFrom(msgSender(), address(this), _amount);
user[_user].deposit += SafeCast.toUint128(_amount);
```",medium,"Recommend ensuring that the `erc20` token does not implement any customizations. Alternatively, a mitigation is to measure the asset change right before and after the asset-transferring routines.","function deposit(uint256 _amount, address _user)
        external
        override
        balancedBooks
        returns (bool)
    {
        require(!globalPause, ""Deposits are disabled"");
        require(
            erc20.allowance(msgSender(), address(this)) >= _amount,
            ""User not approved to send this amount""
        );
        require(
            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,
            ""Limit hit""
        );
        require(_amount > 0, ""Must deposit something"");
        if (whitelistEnabled) {
            require(hasRole(WHITELIST, _user), ""Not in whitelist"");
        }
        erc20.safeTransferFrom(msgSender(), address(this), _amount);

        // do some cleaning up, it might help cancel their foreclosure
        orderbook.removeOldBids(_user);

        user[_user].deposit += SafeCast.toUint128(_amount);
        totalDeposits += _amount;
        emit LogAdjustDeposit(_user, _amount, true);

        // this deposit could cancel the users foreclosure
        assessForeclosure(_user);
        return true;
    }"
52.md,(dex-v1) BasePool.mint() function can be frontrun,"In the contract BasePool the mint function can be frontrun. This will assign the NFT to the attacker which later on he can burn it retrieving the corresponding `_nativeAsset` and `_foreignAsset` initially deposited by the frontrun victim.

Proof of Concept:
User1 transfers 1000 `_nativeAsset` tokens and 1000 `_foreignAsset` tokens into the BasePool contract.
User1 calls the `BasePool.mint()` function to retrieve his NFT.
Attacker is constantly polling for an increase of the balance of `_nativeAsset` and `_foreignAsset` of the contract OR attacker is constantly scanning the mempool for `mint()` function calls.
Attacker detects an increase of balance of `_nativeAsset` and `_foreignAsset` OR attacker detects a `mint()` function call in the mempool.
Attacker frontruns the mint call and retrieves the NFT. Gets a NFT that is worth 1000 `_nativeAssets` and 1000 `_foreignAssets`.
User1 gets a NFT that is worth 0 `_nativeAssets` and 0 `_foreignAssets`.
Attacker burns the NFT retrieving the corresponding `_nativeAsset` and `_foreignAsset` initially deposited by the victim.",high,Include in the `mint()` function the transfer of `_nativeAssets` and `_foreignAssets` to the smart contract.,"function mint(address to)
        external
        override
        nonReentrant
        returns (uint256 liquidity)
    {
        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings
        uint256 balanceNative = nativeAsset.balanceOf(address(this));
        uint256 balanceForeign = foreignAsset.balanceOf(address(this));
        uint256 nativeDeposit = balanceNative - reserveNative;
        uint256 foreignDeposit = balanceForeign - reserveForeign;

        uint256 totalLiquidityUnits = totalSupply;
        if (totalLiquidityUnits == 0)
            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach
        else
            liquidity = VaderMath.calculateLiquidityUnits(
                nativeDeposit,
                reserveNative,
                foreignDeposit,
                reserveForeign,
                totalLiquidityUnits
            );

        require(
            liquidity > 0,
            ""BasePool::mint: Insufficient Liquidity Provided""
        );

        uint256 id = positionId++;

        totalSupply += liquidity;
        _mint(to, id);

        positions[id] = Position(
            block.timestamp,
            liquidity,
            nativeDeposit,
            foreignDeposit
        );

        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);

        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);
        emit PositionOpened(msg.sender, id, liquidity);
    }"
47.md,Unable to transfer `WrappedIbbtc` if Oracle go down,"In `WrappedIbbtc`, user will not be able to transfer if `oracle.pricePerShare()` (L124) revert. This is because `balanceToShares()` is called in both transfer and `transferFrom`, which included a call to `pricePerShare()`.

If this is the expected behavior, note that `WrappedIbbtcEth` is behaving the opposite as it uses the cached value in a local variable `pricePerShare`, which is only updated upon call to `updatePricePerShare()`.",medium,"Depending on the specification, one of them need to be changed.","function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// @dev the _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// @dev the naming confusion is due to maintaining original ERC20 code as much as possible

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

function pricePerShare() public view virtual returns (uint256) {
        return oracle.pricePerShare();
    }

function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare());
    }function updatePricePerShare() public virtual returns (uint256) {
        pricePerShare = core.pricePerShare();
        lastPricePerShareUpdate = now;

        emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);
    }

function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(sender, recipient, amountInShares);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, ""ERC20: transfer amount exceeds allowance""));
        return true;
    }

function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        /// The _balances mapping represents the underlying ibBTC shares (""non-rebased balances"")
        /// Some naming confusion emerges due to maintaining original ERC20 var names

        uint256 amountInShares = balanceToShares(amount);

        _transfer(_msgSender(), recipient, amountInShares);
        return true;
    }

function balanceToShares(uint256 balance) public view returns (uint256) {
        return balance.mul(1e18).div(pricePerShare);
    }"
16.md,Wrong price scale for `GasOracle`,"The `GasOracle` uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.

However, the scaling depends on the underlying decimals of the two oracles and could be anything. But the code assumes it's in 18 decimals.

> ""Returned value is USD/Gas * 10^18 for compatibility with rest of calculations""

There is a `toWad` function that seems to involve scaling but it is never used.

The impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported.",high,"Recommend checking `chainlink.decimals()` to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the `latestAnswer` function always returns the answer in 18 decimals.","function latestAnswer() external view override returns (uint256) {
        uint256 gasPrice = uint256(gasOracle.latestAnswer());
        uint256 ethPrice = uint256(priceOracle.latestAnswer());

        uint256 result = PRBMathUD60x18.mul(gasPrice, ethPrice);
        return result;
    }

function toWad(uint256 raw, IChainlinkOracle _oracle) internal view returns (uint256) {
        IChainlinkOracle oracle = IChainlinkOracle(_oracle);
        // reset the scaler for consistency
        uint8 _decimals = oracle.decimals(); // 9
        require(_decimals <= MAX_DECIMALS, ""GAS: too many decimals"");
        uint256 scaler = uint256(10**(MAX_DECIMALS - _decimals));
        return raw * scaler;
    }"
83.md,Wrong reward token calculation in MasterChef contract,"When adding new token pool for staking in MasterChef contract

function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock)

All other, already added, pools should be updated but currently they are not.
Instead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it's share during the next update.
Therefore, user rewards are not computed correctly (will be always smaller).

Proof of Concept

Scenario 1:

1.  Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100)
    and 1 block later Alice stakes 10 tokens in the first pool.
2.  1 week passes
3.  Alice withdraws her 10 tokens and claims X amount of reward tokens.
    and 1 block later Bob stakes 10 tokens in the first pool.
4.  1 week passes
5.  Owner adds new pool (second pool) for staking with points = 100 (totalPoints=200)
    and 1 block later Bob withdraws his 10 tokens and claims X/2 amount of reward tokens.
    But he should get X amount

Scenario 2:

1.  Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100).
2.  1 block later Alice, Bob and Charlie stake 10 tokens there (at the same time).
3.  1 week passes
4.  Owner adds new pool (second pool) for staking with points = 400 (totalPoints=500)
5.  Right after that, when Alice, Bob or Charlie wants to withdraw tokens and claim rewards they will only be able to claim 20% of what they should be eligible for, because their pool is updated with 20% (100/500) rewards instead of 100% (100/100) rewards for the past week.",high,Update all existing pools before adding new pool. Use the massUdpate() function which is already present ... but unused.,"function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {
        require(_token != address(0), ""zero address"");
        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocationPoints);
        require(pid[_token] == 0, ""already registered""); // pid starts from 0
        poolInfo.push(
            PoolInfo({
                depositToken: IERC20(_token),
                allocPoint: _allocationPoints,
                lastRewardBlock: lastRewardBlock,
                accConcurPerShare: 0,
                depositFeeBP: _depositFee
            })
        );
        pid[_token] = poolInfo.length - 1;
    }"
52.md,Incorrect Price Consultation Results,"The `TwapOracle.consult()` function iterates over all token pairs which belong to either `VADER` or `USDV` and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs.

Let's say we wanted to query the price of `USDV`, we would sum up any token pair where `USDV == pairData.token0`.

The sum consists of the following:

* Price of `USDV` denominated in terms of `token1` (`USDV/token1`).
* Price of token1 denominated in terms of `USD` (`token1/USD`).

Consider the following example:

* `SUSHI` is the only registered token pair that exists alongside `USDV`.
* Hence, calculating `sumNative` gives us an exchange rate that is denominated as `USDV/SUSHI`.
* Similarly, `sumUSD` gives us the following denominated pair, `SUSHI/USD`.
* I'd expect the result to equal `sumUSD * token.decimals() * sumNative` which should give us a USDV/USD denominated result.

However, the protocol calculates it as `(sumUSD * token.decimals()) / sumNative` which gives us a `SUSHI^2 / (USD*USDV)` denominated result. This seems incorrect.

I'd classify this issue as high risk as the oracle returns false results upon being consulted. This can lead to issues in other areas of the protocol that use this data in performing sensitive actions.",high,"To calculate the correct consultation of a given token, the result should return `sumUSD * token.decimals() * sumNative` instead to ensure the target token to consult is denominated in `USD` and contains the correct number of decimals.","function consult(address token) public view returns (uint256 result) {
        uint256 pairCount = _pairs.length;
        uint256 sumNative = 0;
        uint256 sumUSD = 0;

        for (uint256 i = 0; i < pairCount; i++) {
            PairData memory pairData = _pairs[i];

            if (token == pairData.token0) {
                //
                // TODO - Review:
                //   Verify price1Average is amount of USDV against 1 unit of token1
                //

                sumNative += pairData.price1Average.mul(1).decode144(); // native asset amount
                if (pairData.price1Average._x != 0) {
                    require(sumNative != 0);
                }

                (
                    uint80 roundID,
                    int256 price,
                    ,
                    ,
                    uint80 answeredInRound
                ) = AggregatorV3Interface(_aggregators[pairData.token1])
                        .latestRoundData();

                require(
                    answeredInRound >= roundID,
                    ""TwapOracle::consult: stale chainlink price""
                );
                require(
                    price != 0,
                    ""TwapOracle::consult: chainlink malfunction""
                );

                sumUSD += uint256(price) * (10**10);
            }
        }
        require(sumNative != 0, ""TwapOracle::consult: Sum of native is zero"");
        result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);
    }"
67.md,`totalUnderlyingMinusSponsored()` may revert on underflow and malfunction the contract,"As a function that many other functions depended on, `totalUnderlyingMinusSponsored()` can revert on underflow when  `sponsorAmount > totalUnderlying()` which is possible and has been considered elsewhere in this contract:

if (_force && sponsorAmount > totalUnderlying()) {
    sponsorToTransfer = totalUnderlying();
}

#### Proof of Concept

*   Underlying token = USDT
*   Swap Fee = 0.04%

1.  Sponsor call `sponsor()` and send 10,000 USDT

*   totalSponsored = 10,000

2.  `NonUSTStrategy.sol#doHardWork()` swapped USDT for UST

*   pendingDeposits = 9,996
*   totalUnderlying() = 9,996

3.  Alice tries to call `deposit()`, the tx will revet due to underflow in `totalUnderlyingMinusSponsored()`.",medium,"Change to:

function totalUnderlyingMinusSponsored() public view returns (uint256) {
    uint256 _totalUnderlying = totalUnderlying();
    if (totalSponsored > _totalUnderlying) {
        return 0;
    }
    return _totalUnderlying - totalSponsored;
}","function totalUnderlyingMinusSponsored() public view returns (uint256) {
        // TODO no invested amount yet
        return totalUnderlying() - totalSponsored;
    }"
30.md,`VaultHelper` deposits don't work with fee-on transfer tokens,"There are ERC20 tokens that may make certain customizations to their ERC20 contracts. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`. Others are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).

Impact
The `VaultHelper`'s `depositVault()` and `depositMultipleVault` functions transfer `_amount` to `this` contract using `IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);`. This could have a fee, and less than `_amount` ends up in the contract. The next actual vault deposit using `IVault(_vault).deposit(_token, _amount);` will then try to transfer more than the `this` contract actually has and will revert the transaction.",medium,One possible mitigation is to measure the asset change right before and after the asset-transferring routines. This is already done correctly in the `Vault.deposit` function.,"function depositVault(
        address _vault,
        address _token,
        uint256 _amount
    )
        external
    {
        require(_amount > 0, ""!_amount"");
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);
        IERC20(_token).safeApprove(_vault, 0);
        IERC20(_token).safeApprove(_vault, _amount);
        uint256 _shares = IVault(_vault).deposit(_token, _amount);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }

function depositMultipleVault(
        address _vault,
        address[] calldata _tokens,
        uint256[] calldata _amounts
    )
        external
    {
        require(_tokens.length == _amounts.length, ""!length"");

        for (uint8 i = 0; i < _amounts.length; i++) {
            require(_amounts[i] > 0, ""!_amounts"");
            IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amounts[i]);
            IERC20(_tokens[i]).safeApprove(_vault, 0);
            IERC20(_tokens[i]).safeApprove(_vault, _amounts[i]);
        }
        uint256 _shares = IVault(_vault).depositMultiple(_tokens, _amounts);
        address _gauge = IVault(_vault).gauge();
        if (_gauge != address(0)) {
            IERC20(_vault).safeApprove(_gauge, 0);
            IERC20(_vault).safeApprove(_gauge, _shares);
            ILiquidityGaugeV2(_gauge).deposit(_shares);
            IERC20(_gauge).safeTransfer(msg.sender, _shares);
        } else {
            IERC20(_vault).safeTransfer(msg.sender, _shares);
        }
    }"
94.md,An offer made after auction end can be stolen by an auction winner,"An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as _transferFromEscrow being called by _acceptOffer will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.

This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.

When an auction has ended, there is a possibility to make the offers for an auctioned NFT as:

makeOffer checks _isInActiveAuction:

_isInActiveAuction returns false when auctionIdToAuction[auctionId].endTime < block.timestamp, so makeOffer above can proceed:

Then, the auction winner can call acceptOffer -> _acceptOffer (or setBuyPrice -> _autoAcceptOffer -> _acceptOffer).

_acceptOffer will try to transfer directly, and then calls _transferFromEscrow:

If the auction has ended, but a winner hasn't picked up the NFT yet, the direct transfer will fail, proceeding with _transferFromEscrow in the FNDNFTMarket defined order:

NFTMarketOffer._transferFromEscrow will call super as nftContractToIdToOffer was already deleted:

NFTMarketBuyPrice._transferFromEscrow will call super as there is no buy price set:

Finally, NFTMarketReserveAuction._transferFromEscrow will send the NFT to the winner via _finalizeReserveAuction, not to the user who made the offer:

The recipient user who made the offer is not present in this logic, the NFT is being transferred to the auction.bidder, and the original acceptOffer will go through successfully.",high,"An attempt to set a buy price from auction winner will lead to auction finalisation, so _buy cannot be called with a not yet finalised auction, this way the NFTMarketReserveAuction._transferFromEscrow L550-L560 logic is called from the NFTMarketOffer._acceptOffer only.

This way the fix is to update L556-L560 for the described case as:

Now:
    // Finalization will revert if the auction has not yet ended.
    _finalizeReserveAuction(auctionId, false);

    // Finalize includes the transfer, so we are done here.
    return;

To be, we leave the NFT in the escrow and let L564 super call to transfer it to the recipient:

    // Finalization will revert if the auction has not yet ended.
    _finalizeReserveAuction(auctionId, true);","function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      /*
       * Save gas by calling core directly since it cannot have another escrow requirement
       * (buy price set or another auction listed) until this one has been finalized.
       */
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        // The auction has not received any bids yet so it may be invalided.

        if (auction.seller != seller) {
          // The account trying to transfer the NFT is not the current owner.
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        // Remove the auction.
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        // If the auction has started, the highest bidder will be the new owner.

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        // Finalization will revert if the auction has not yet ended.
        _finalizeReserveAuction(auctionId, false);

        // Finalize includes the transfer, so we are done here.
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }function setBuyPrice(
    address nftContract,
    uint256 tokenId,
    uint256 price
  ) external nonReentrant {
    // If there is a valid offer at this price or higher, accept that instead.
    if (_autoAcceptOffer(nftContract, tokenId, price)) {
      return;
    }

    if (price > type(uint96).max) {
      // This ensures that no data is lost when storing the price as `uint96`.
      revert NFTMarketBuyPrice_Price_Too_High();
    }

    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];

    // Store the new price for this NFT.
    buyPrice.price = uint96(price);

    if (buyPrice.seller == address(0)) {
      // Transfer the NFT into escrow, if it's already in escrow confirm the `msg.sender` is the owner.
      _transferToEscrow(nftContract, tokenId);

      // The price was not previously set for this NFT, store the seller.
      buyPrice.seller = payable(msg.sender);
    } else if (buyPrice.seller != msg.sender) {
      // Buy price was previously set by a different user
      revert NFTMarketBuyPrice_Only_Owner_Can_Set_Price(buyPrice.seller);
    }

    emit BuyPriceSet(nftContract, tokenId, msg.sender, price);
  }

function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    if (buyPrice.seller != address(0)) {
      // A buy price was set for this NFT.
      if (buyPrice.seller != seller) {
        // When there is a buy price set, the `buyPrice.seller` is the owner of the NFT.
        revert NFTMarketBuyPrice_Seller_Mismatch(buyPrice.seller);
      }

      // Invalidate the buy price as the NFT will no longer be in escrow.
      _invalidateBuyPrice(nftContract, tokenId);
    }
    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }"
12.md,YieldMath.sol / Log2: >= or > ?,"The V1 version of `YieldMath.sol` contains "">="" (larger or equal), while the V2 version of `YieldMath.sol` contains "">"" (larger) in the log_2 function. This change doesn't seem logical and might lead to miss calculations. The difference is present in several adjacent lines.
```solidity
function log_2 (uint128 x)
...
b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}
```
and
```solidity
function log_2(uint128 x)
...
b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}
```",high,Recommend checking which version is the correct version and fix the incorrect version.,"function log_2(uint128 x)
  internal pure returns(uint128) {
    unchecked {
      require(x != 0);

      uint b = x;

      uint l = 0xFE000000000000000000000000000000;

      if(b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}
      if(b < 0x1000000000000000000000000) {l -= 0x40000000000000000000000000000000; b <<= 32;}
      if(b < 0x10000000000000000000000000000) {l -= 0x20000000000000000000000000000000; b <<= 16;}
      if(b < 0x1000000000000000000000000000000) {l -= 0x10000000000000000000000000000000; b <<= 8;}
      if(b < 0x10000000000000000000000000000000) {l -= 0x8000000000000000000000000000000; b <<= 4;}
      if(b < 0x40000000000000000000000000000000) {l -= 0x4000000000000000000000000000000; b <<= 2;}
      if(b < 0x80000000000000000000000000000000) {l -= 0x2000000000000000000000000000000; b <<= 1;}

      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000;} /*
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2;}
      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) l |= 0x1; */

      return uint128(l);
    }
  }"
113.md,The return value `success` of the get function of the INFTOracle interface is not checked,"The get function of the INFTOracle interface returns two values, but the success value is not checked when used in the NFTPairWithOracle contract. When success is false, NFTOracle may return stale data.",high,"(bool success, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
require(success);","function get(address pair, uint256 tokenId) external returns (bool success, uint256 rate);  // Error: Function body might be cropped."
110.md,StakedCitadel: wrong setupVesting function name,"In the `_withdraw` function of the StakedCitadel contract, the setupVesting function of vesting is called, while in the StakedCitadelVester contract, the function name is vest, which will cause the _withdraw function to fail, so that the user cannot withdraw the tokens.",high,"Use the correct function name. Update the interface IVesting to use the vest function and call IVesting(vesting).vest(msg.sender, _amount, block.timestamp) instead of setupVesting.","function vest(
        address recipient,
        uint256 _amount,
        uint256 _unlockBegin
    ) external {
        require(msg.sender == vault, ""StakedCitadelVester: only xCTDL vault"");
        require(_amount > 0, ""StakedCitadelVester: cannot vest 0"");

        vesting[recipient].lockedAmounts =
            vesting[recipient].lockedAmounts +
            _amount;
        vesting[recipient].unlockBegin = _unlockBegin;
        vesting[recipient].unlockEnd = _unlockBegin + vestingDuration;

        emit Vest(
            recipient,
            vesting[recipient].lockedAmounts,
            _unlockBegin,
            vesting[recipient].unlockEnd
        );
    }function _withdraw(uint256 _shares) internal nonReentrant {
        require(_shares != 0, ""0 Shares"");

        uint256 r = (balance() * _shares) / totalSupply();
        _burn(msg.sender, _shares);

        // Check balance
        uint256 b = token.balanceOf(address(this));
        if (b < r) {
            uint256 _toWithdraw = r - b;
            IStrategy(strategy).withdraw(_toWithdraw);
            uint256 _after = token.balanceOf(address(this));
            uint256 _diff = _after - b;
            if (_diff < _toWithdraw) {
                r = b + _diff;
            }
        }

        uint256 _fee = _calculateFee(r, withdrawalFee);
        uint256 _amount = r - _fee;

        // Send funds to vesting contract and setup vesting
        IVesting(vesting).setupVesting(msg.sender, _amount, block.timestamp);
        token.safeTransfer(vesting, _amount);

        // After you burned the shares, and you have sent the funds, adding here is equivalent to depositing
        // Process withdrawal fee
        if(_fee > 0) {
            _mintSharesFor(treasury, _fee, balance() - _fee);
        }
    }"
21.md,Unbounded iteration over all staking tokens,"The `SherX.getTotalSherXUnminted` function iterates over all elements of the `tokensStaker` array.

The transactions could fail if the arrays get too big and the transaction would consume more gas than the block limit.
This will then result in a denial of service for the desired functionality and break core functionality.

The severity is low as only governance can whitelist these tokens but not the protocols themselves.",low,Recommend keeping the array size small.,"function getTotalSherXUnminted() external view override returns (uint256) {
    SherXStorage.Base storage sx = SherXStorage.sx();
    GovStorage.Base storage gs = GovStorage.gs();

    uint256 total =
      block
        .number
        .sub(gs.watsonsSherxLastAccrued)
        .mul(sx.sherXPerBlock)
        .mul(gs.watsonsSherxWeight)
        .div(uint16(-1));
    for (uint256 i; i < gs.tokensStaker.length; i++) {
      total = total.add(getUnmintedSherX(gs.tokensStaker[i]));
    }
    return total;
  }"
71.md,Initial pool deposit can be stolen,"Note that the `PoolTemplate.initialize` function, called when creating a market with `Factory.createMarket`, calls a vault function to transfer an initial deposit amount (`conditions[1]`) *from* the initial depositor (`_references[4]`).

The initial depositor needs to first approve the vault contract for the `transferFrom` to succeed.

An attacker can then frontrun the `Factory.createMarket` transaction with their own market creation (it does not have access restrictions) and create a market *with different parameters* but still passing in `_conditions[1]=amount` and `_references[4]=victim`.

A market with parameters that the initial depositor did not want (different underlying, old whitelisted registry/parameter contract, etc.) can be created with their tokens and these tokens are essentially lost.",high,"Can the initial depositor be set to `Factory.createMarket`'s `msg.sender`, instead of being able to pick a whitelisted one as `_references[4]`?","function initialize(
        string calldata _metaData,
        uint256[] calldata _conditions,
        address[] calldata _references
    ) external override {
        require(
            initialized == false &&
                bytes(_metaData).length > 0 &&
                _references[0] != address(0) &&
                _references[1] != address(0) &&
                _references[2] != address(0) &&
                _references[3] != address(0) &&
                _references[4] != address(0) &&
                _conditions[0] <= _conditions[1],
            ""ERROR: INITIALIZATION_BAD_CONDITIONS""
        );
        initialized = true;

        string memory _name = string(
            abi.encodePacked(
                ""InsureDAO-"",
                IERC20Metadata(_references[1]).name(),
                ""-PoolInsurance""
            )
        );
        string memory _symbol = string(
            abi.encodePacked(""i-"", IERC20Metadata(_references[1]).symbol())
        );
        uint8 _decimals = IERC20Metadata(_references[0]).decimals();

        initializeToken(_name, _symbol, _decimals);

        registry = IRegistry(_references[2]);
        parameters = IParameters(_references[3]);
        vault = IVault(parameters.getVault(_references[1]));

        metadata = _metaData;

        marketStatus = MarketStatus.Trading;

        if (_conditions[1] > 0) {
            _depositFrom(_conditions[1], _references[4]);
        }
    }

function _depositFrom(uint256 _amount, address _from)
        internal
        returns (uint256 _mintAmount)
    {
        require(
            marketStatus == MarketStatus.Trading && paused == false,
            ""ERROR: DEPOSIT_DISABLED""
        );
        require(_amount > 0, ""ERROR: DEPOSIT_ZERO"");

        _mintAmount = worth(_amount);

        vault.addValue(_amount, _from, address(this));

        emit Deposit(_from, _amount, _mintAmount);

        //mint iToken
        _mint(_from, _mintAmount);
    }"
131.md,Inconsistency in view functions can lead to users believing they’re due for more BKD rewards,"The view functions used for a user to check their claimable rewards vary in their implementation. This can cause users to believe they are due X amount but will receive Y.

If the inflationRecipient is set, then poolStakedIntegral will be incremented in claimableRewards() but not in any other function like allClaimableRewards() or poolCheckpoint().

If a user calls claimableRewards() after the inflationRepient has been set, claimableRewards() will return a larger value than allClaimableRewards() or the amount actually returned by claimRewards().

I'm still fairly conflicted on severity as the impact is going to be quite small, however at this time, because the ""code is wrong"", I still think Medium Severity to be valid.",medium,"To make the logic consistent, claimableRewards() needs if (inflationRecipient == address(0)) added to it.","function claimRewards(address beneficiary) external virtual override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        _userCheckpoint(beneficiary);
        uint256 amount = perUserShare[beneficiary];
        uint256 crvAmount = perUserShareCrv[beneficiary];
        uint256 cvxAmount = perUserShareCvx[beneficiary];
        if (amount <= 0 && crvAmount <= 0 && cvxAmount <= 0) return 0;
        perUserShare[beneficiary] = 0;
        perUserShareCrv[beneficiary] = 0;
        perUserShareCvx[beneficiary] = 0;
        _crvLastEarned -= crvAmount;
        _cvxLastEarned -= cvxAmount;
        IController(controller).inflationManager().mintRewards(beneficiary, amount);
        IERC20(crv).safeTransfer(beneficiary, crvAmount);
        IERC20(cvx).safeTransfer(beneficiary, cvxAmount);
        emit RewardClaimed(beneficiary, amount, crvAmount, cvxAmount);
        return amount;
    }

function claimableRewards(address user) external view virtual override returns (uint256) {
        uint256 ammStakedIntegral_ = ammStakedIntegral;
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        if (user == inflationRecipient) {
            return
                perUserShare[inflationRecipient] +
                IController(controller).inflationManager().getAmmRateForToken(ammToken) *
                timeElapsed;
        }
        if (!killed && totalStaked > 0) {
            ammStakedIntegral_ +=
                IController(controller).inflationManager().getAmmRateForToken(ammToken) *
                timeElapsed.scaledDiv(totalStaked);
        }
        return
            perUserShare[user] +
            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);
    }

function allClaimableRewards(address user) external view override returns (uint256[3] memory) {
        uint256 ammStakedIntegral_ = ammStakedIntegral;
        uint256 crvStakedIntegral_ = crvStakedIntegral;
        uint256 cvxStakedIntegral_ = cvxStakedIntegral;
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);

        // This might lead to some inaccuracies in between poolCheckpoints if someone sends CRV
        uint256 crvEarned = IERC20(crv).balanceOf(address(this)) +
            crvRewardsContract.earned(address(this)) -
            _crvLastEarned;
        uint256 cvxEarned = getCvxMintAmount(crvEarned);

        if (!killed && totalStaked > 0) {
            if (inflationRecipient == address(0)) {
                ammStakedIntegral_ +=
                    (IController(controller).inflationManager().getAmmRateForToken(ammToken)) *
                    (timeElapsed).scaledDiv(totalStaked);
            }
            crvStakedIntegral_ += (crvEarned).scaledDiv(totalStaked);
            cvxStakedIntegral_ += (cvxEarned).scaledDiv(totalStaked);
        }
        uint256 bkdRewards;
        if (user == inflationRecipient) {
            bkdRewards =
                perUserShare[user] +
                IController(controller).inflationManager().getAmmRateForToken(ammToken) *
                timeElapsed;
        } else {
            bkdRewards =
                perUserShare[user] +
                balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);
        }
        uint256 crvRewards = perUserShareCrv[user] +
            balances[user].scaledMul(crvStakedIntegral_ - perUserCrvStakedIntegral[user]);
        uint256 cvxRewards = perUserShareCvx[user] +
            balances[user].scaledMul(cvxStakedIntegral_ - perUserCvxStakedIntegral[user]);
        uint256[3] memory allRewards = [bkdRewards, crvRewards, cvxRewards];
        return allRewards;
    }

function poolCheckpoint() public virtual override returns (bool) {
        if (killed) {
            return false;
        }
        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);
        uint256 currentRate = IController(controller).inflationManager().getAmmRateForToken(
            ammToken
        );
        crvRewardsContract.getReward();
        uint256 crvEarned = IERC20(crv).balanceOf(address(this));
        uint256 cvxEarned = IERC20(cvx).balanceOf(address(this));

        // Update the integral of total token supply for the pool
        if (totalStaked > 0) {
            if (inflationRecipient == address(0)) {
                ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);
            } else {
                perUserShare[inflationRecipient] += currentRate * timeElapsed;
            }
            crvStakedIntegral += (crvEarned - _crvLastEarned).scaledDiv(totalStaked);
            cvxStakedIntegral += (cvxEarned - _cvxLastEarned).scaledDiv(totalStaked);
        }
        _crvLastEarned = crvEarned;
        _cvxLastEarned = cvxEarned;
        ammLastUpdated = uint48(block.timestamp);
        return true;
    }"
36.md,No minimum rate in the auction may break the protocol under network failure,"The auction contract decides a new `ibRatio` in the function `settleAuction`.

```solidity
uint256 a = factory.auctionMultiplier() * basket.ibRatio();
uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();
uint256 newRatio = a - b;
```

There's a chance that `newRatio` would be really close to zero. This imposes too much risk on the protocol. The network may not really be healthy all the time. Solana and Arbitrum were down and Ethereum was suffered a forking issue recently. Also, the network may be jammed from time to time. This could cause huge damage to a protocol. Please refer to Black Thursday for makerdao 8.32 million was liquidated for 0 dai.

Given the chance that all user may lose their money, I consider this is a medium-risk issue.",medium,I recommend setting a minimum `ibRatio` when a publisher publishes a new index. The auction should be killed if the `ibRatio` is too low.,"function settleAuction(
        uint256[] memory bountyIDs,
        address[] memory inputTokens,
        uint256[] memory inputWeights,
        address[] memory outputTokens,
        uint256[] memory outputWeights
    ) public override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondTimestamp + ONE_DAY > block.number);
        require(msg.sender == auctionBonder);

        for (uint256 i = 0; i < inputTokens.length; i++) {
            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);
        }

        for (uint256 i = 0; i < outputTokens.length; i++) {
            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);
        }

        uint256 a = factory.auctionMultiplier() * basket.ibRatio();
        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();
        uint256 newRatio = a - b;

        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();
        IERC20 basketAsERC20 = IERC20(address(basket));

        for (uint256 i = 0; i < pendingWeights.length; i++) {
            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
        }

        basketAsERC20.transfer(msg.sender, bondAmount);
        withdrawBounty(bountyIDs);
        basket.setNewWeights();
        basket.updateIBRatio(newRatio);
        auctionOngoing = false;
        hasBonded = false;

        emit AuctionSettled(msg.sender);
    }"
51.md,`customPrecisionMultipliers` would be rounded to zero and break the pool,"`CustomPrecisionMultipliers` are set in the constructor:

```solidity
customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18);
```

`originalPrecisionMultipliers` equal to 1 if the token's decimal = 18. The target price could only be an integer.

If the target price is bigger than 10**18, the user can deposit and trade in the pool. Though, the functionality would be far from the spec.

If the target price is set to be smaller than 10**18, the pool would be broken and all funds would be stuck.

I consider this is a high-risk issue.

We can also trigger the bug by setting a pool with target price = 0.5. (0.5 * 10**18)",high,"I recommend providing extra 10**18 in both multipliers.

```solidity
customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).mul(10**18).div(10 ** 18);
customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1].mul(10**18);
```

The customswap only supports two tokens in a pool, there's should be enough space. Recommend the devs to go through the trade-off saddle finance has paid to support multiple tokens. The code could be more clean and efficient if the pools' not support multiple tokens.","constructor(
        IERC20[] memory _pooledTokens,
        uint8[] memory decimals,
        string memory lpTokenName,
        string memory lpTokenSymbol,
        uint256 _a,
        uint256 _a2,
        uint256 _fee,
        uint256 _adminFee,
        uint256 _withdrawFee,
        uint256 _targetPrice
        // IAllowlist _allowlist
    ) public OwnerPausable() ReentrancyGuard() {
        // Check _pooledTokens and precisions parameter
        require(_pooledTokens.length == 2, ""_pooledTokens.length must be 2 in length"");
        require(decimals.length == 2, ""decimals.length must be 2 in length"");
        require(
            _pooledTokens.length == decimals.length,
            ""_pooledTokens decimals mismatch""
        );

        // uint256[] memory originalPrecisionMultipliers = new uint256[](decimals.length);

        for (uint8 i = 0; i < _pooledTokens.length; i++) {
            if (i > 0) {
                // Check if index is already used. Check if 0th element is a duplicate.
                require(
                    tokenIndexes[address(_pooledTokens[i])] == 0 &&
                        _pooledTokens[0] != _pooledTokens[i],
                    ""Duplicate tokens""
                );
            }
            require(
                address(_pooledTokens[i]) != address(0),
                ""The 0 address isn't an ERC-20""
            );
            require(
                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,
                ""Token decimals exceeds max""
            );
            targetPriceStorage.originalPrecisionMultipliers[i] =
                10 **
                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(
                        uint256(decimals[i])
                    );

            tokenIndexes[address(_pooledTokens[i])] = i;
        }

        uint256[2] memory customPrecisionMultipliers;
        customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18);
        customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1];
        // console.log(""customPrecisionMultipliers[0] %s"", customPrecisionMultipliers[0]);

        // Check _a, _a2 _fee, _adminFee, _withdrawFee, _allowlist parameters
        require(_a >= 0 && _a <= SwapUtils.MAX_A, ""_a not within the limits"");
        require(_a2 >= 0 && _a2 <= SwapUtils.MAX_A, ""_a2 not within the limits"");
        require(_fee < SwapUtils.MAX_SWAP_FEE, ""_fee exceeds maximum"");
        require(
            _adminFee < SwapUtils.MAX_ADMIN_FEE,
            ""_adminFee exceeds maximum""
        );
        require(
            _withdrawFee < SwapUtils.MAX_WITHDRAW_FEE,
            ""_withdrawFee exceeds maximum""
        );
        // require(
        //     _allowlist.getPoolCap(address(0x0)) == uint256(0x54dd1e),
        //     ""Allowlist check failed""
        // );

        // Initialize swapStorage struct
        swapStorage.lpToken = new LPToken(
            lpTokenName,
            lpTokenSymbol,
            SwapUtils.POOL_PRECISION_DECIMALS
        );
        swapStorage.pooledTokens = _pooledTokens;
        swapStorage.tokenPrecisionMultipliers = customPrecisionMultipliers;
        swapStorage.balances = new uint256[](_pooledTokens.length);
        
        targetPriceStorage.initialTargetPrice = _targetPrice/*.mul(SwapUtils.TARGET_PRICE_PRECISION)*/;
        targetPriceStorage.futureTargetPrice = _targetPrice/*.mul(SwapUtils.TARGET_PRICE_PRECISION)*/;
        targetPriceStorage.initialTargetPriceTime = 0;
        targetPriceStorage.futureTargetPriceTime = 0;

        swapStorage.initialA = _a.mul(SwapUtils.A_PRECISION);
        swapStorage.futureA = _a.mul(SwapUtils.A_PRECISION);
        swapStorage.initialATime = 0;
        swapStorage.futureATime = 0;
        
        swapStorage.initialA2 = _a2.mul(SwapUtils.A_PRECISION);
        swapStorage.futureA2 = _a2.mul(SwapUtils.A_PRECISION);
        swapStorage.initialA2Time = 0;
        swapStorage.futureA2Time = 0;
        
        swapStorage.swapFee = _fee;
        swapStorage.adminFee = _adminFee;
        swapStorage.defaultWithdrawFee = _withdrawFee;

        // Initialize variables related to guarding the initial deposits
        // allowlist = _allowlist;
        // guarded = true;
    }"
49.md,Fee double counting for underwater positions,"Actual available fees are less than recorded. That's because a part of them corresponds to underwater positions, and will not have the correct amount stored with the contract: when calculation happens the fee is recorded first, then there is a check for position health, and the funds are channeled to cover the debt firsthand. This way in a case of unfunded position the fee is recorded, but cannot be allocated, so the fees accounted can be greater than the value of fees stored.

This can lead to fee withdrawal malfunction, i.e. `disburse()` will burn more and attempt to transfer more than needed. This leads either to inability to withdraw fees when disburse is failing due to lack of funds, or funds leakage to fees and then inability to perform other withdrawals because of lack of funds.

The fees are accounted for before position health check and aren't corrected thereafter when there is a shortage of funds.",medium,"Adjust fees after position health check: accrue fees only on a remaining part of position that is available after taking debt into account.

Now:
```solidity
uint _feeAmount = _userNotional.mulUp(mothership.fee());

uint _userValueAdjusted = _userNotional - _feeAmount;
if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt;
else _userValueAdjusted = 0;
```
To be:
```solidity
uint _feeAmount = _userNotional.mulUp(mothership.fee());

uint _userValueAdjusted = _userNotional - _feeAmount;
if (_userValueAdjusted > _userDebt) {
    _userValueAdjusted -= _userDebt;
} else {
    _userValueAdjusted = 0;
    _feeAmount = _userNotional > _userDebt ? _userNotional - _userDebt : 0;
}
```","function disburse () public {

        (   uint256 _marginBurnRate,
            uint256 _feeBurnRate,
            address _feeTo ) = mothership.getUpdateParams();

        uint _feeForward = fees;
        uint _feeBurn = _feeForward.mulUp(_feeBurnRate);
        _feeForward = _feeForward - _feeBurn;

        uint _liqForward = liquidations;
        uint _liqBurn = _liqForward.mulUp(_marginBurnRate);
        _liqForward -= _liqBurn;

        fees = 0;
        liquidations = 0;

        emit Update(
            _feeForward,
            _feeBurn,
            _liqForward,
            _liqBurn
        );

        ovl.burn(address(this), _feeBurn + _liqBurn);
        ovl.transfer(_feeTo, _feeForward + _liqForward);

    }"
110.md,Funding.deposit() doesn't work if there is no discount set,"### Impact

The Funding contract's `deposit()` function uses the `getAmountOut()` function to determine how many citadel tokens the user should receive for their deposit. But, if no discount is set, the function always returns 0. Now the `deposit()` function tries to deposit 0 tokens for the user through the StakedCitadel contract. But, that function requires the number of tokens to be `!= 0`. The transaction reverts.

This means, that no deposits are possible. Unless there is a discount.

### Proof of Concept

`Funding.deposit()` calls `getAmountOut()`.

Here's the `getAmountOut()` function:

```sol
    function getAmountOut(uint256 _assetAmountIn)
        public
        view
        returns (uint256 citadelAmount_)
    {
        uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;

        if (funding.discount > 0) {
            citadelAmount_ =
                (citadelAmountWithoutDiscount * MAX_BPS) /
                (MAX_BPS - funding.discount);
        }

        // unless the above if block is executed, `citadelAmount_` is 0 when this line is executed.
        // 0 = 0 / x
        citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;
    }
```

Call to `StakedCitadel.depositFor()`.

require statement that makes the whole transaction revert.",medium,"### Recommended Mitigation Steps

Change the `getAmountOut()` function to:

```sol
    function getAmountOut(uint256 _assetAmountIn)
        public
        view
        returns (uint256 citadelAmount_)
    {

        uint256 citadelAmount_ = _assetAmountIn * citadelPriceInAsset;

        if (funding.discount > 0) {
            citadelAmount_ =
                (citadelAmount_ * MAX_BPS) /
                (MAX_BPS - funding.discount);
        }

        citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;
    }
```","function deposit(uint256 _assetAmountIn, uint256 _minCitadelOut)
        external
        onlyWhenPriceNotFlagged
        gacPausable
        nonReentrant
        returns (uint256 citadelAmount_)
    {
        require(_assetAmountIn > 0, ""_assetAmountIn must not be 0"");
        require(
            funding.assetCumulativeFunded + _assetAmountIn <= funding.assetCap,
            ""asset funding cap exceeded""
        );
        funding.assetCumulativeFunded = funding.assetCumulativeFunded + _assetAmountIn;
        // Take in asset from user
        citadelAmount_ = getAmountOut(_assetAmountIn);
        require(citadelAmount_ >= _minCitadelOut, ""minCitadelOut"");

        asset.safeTransferFrom(msg.sender, saleRecipient, _assetAmountIn);
        
        // Deposit xCitadel and send to user
        // TODO: Check gas costs. How does this relate to market buying if you do want to deposit to xCTDL?
        xCitadel.depositFor(msg.sender, citadelAmount_);

        emit Deposit(
            msg.sender,
            _assetAmountIn,
            citadelAmount_
        );
    }

function getAmountOut(uint256 _assetAmountIn)
        public
        view
        returns (uint256 citadelAmount_)
    {
        uint256 citadelAmountWithoutDiscount = _assetAmountIn * citadelPriceInAsset;

        if (funding.discount > 0) {
            citadelAmount_ =
                (citadelAmountWithoutDiscount * MAX_BPS) /
                (MAX_BPS - funding.discount);
        }

        citadelAmount_ = citadelAmount_ / assetDecimalsNormalizationValue;
    }function deposit(uint256 _amount) external whenNotPaused {
        _depositWithAuthorization(_amount, new bytes32[](0));
    }

function deposit(uint256 _amount, bytes32[] memory proof)
        external
        whenNotPaused
    {
        _depositWithAuthorization(_amount, proof);
    }

function depositFor(address _recipient, uint256 _amount)
        external
        whenNotPaused
    {
        _depositForWithAuthorization(_recipient, _amount, new bytes32[](0));
    }

function depositFor(
        address _recipient,
        uint256 _amount,
        bytes32[] memory proof
    ) external whenNotPaused {
        _depositForWithAuthorization(_recipient, _amount, proof);
    }"
23.md,`DateTime.isValidMarketMaturity` bounds should be tighter,"`DateTime.isValidMarketMaturity` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.

The impact is that ""Valid"" `maxMarketIndex` values above 7 will break and return with an error.",low,Recommend that the upper bound on `maxMarketIndex` should be set to `7`.,"function getTradedMarket(uint256 index) internal pure returns (uint256) {
        require(index != 0); // dev: get traded market index is zero

        if (index == 1) return Constants.QUARTER;
        if (index == 2) return 2 * Constants.QUARTER;
        if (index == 3) return Constants.YEAR;
        if (index == 4) return 2 * Constants.YEAR;
        if (index == 5) return 5 * Constants.YEAR;
        if (index == 6) return 10 * Constants.YEAR;
        if (index == 7) return 20 * Constants.YEAR;

        revert(""CG: invalid index"");
    }

function isValidMarketMaturity(
        uint256 maxMarketIndex,
        uint256 maturity,
        uint256 blockTime
    ) internal pure returns (bool) {
        require(maxMarketIndex > 0, ""CG: no markets listed"");
        require(maxMarketIndex < 10, ""CG: market index bound"");

        if (maturity % Constants.QUARTER != 0) return false;
        uint256 tRef = DateTime.getReferenceTime(blockTime);

        for (uint256 i = 1; i <= maxMarketIndex; i++) {
            if (maturity == tRef.add(DateTime.getTradedMarket(i))) return true;
        }

        return false;
    }"
60.md,Wrong shortfall calculation,"Every time an account is settled, if shortfall is created, due to a wrong calculation shortfall will double in size and add the new shortfall.

#### Impact

Loss of funds: users won't be able to withdraw the correct amount of funds. Somebody would have to donate funds to resolve the wrong shortfall.

#### Proof of Concept

We can see in the `settleAccount` of `OptimisticLedger` that `self.shortfall` ends up being `self.shortfall+self.shortfall+newShortfall`:

```solidity
function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)
internal returns (UFixed18 shortfall) {
    Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);

    if (newBalance.sign() == -1) {
        shortfall = self.shortfall.add(newBalance.abs());
        newBalance = Fixed18Lib.ZERO;
    }

    self.balances[account] = newBalance.abs();
    self.shortfall = self.shortfall.add(shortfall);
}
```

Additionally, you can add the following line to the ""shortfall reverts if depleted"" test in `Collateral.test.js`, line 190:

```js
await collateral.connect(productSigner).settleAccount(userB.address, -50)
```

Previously the test product had 50 shortfall. Now we added 50 more, but the test will print that the actual shortfall is 150, and not 100 as it should be.",high,"Move the setting of `self.shortfall` to inside the if function and change the line to:
```
    self.shortfall = shortfall
```","function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)
    internal returns (UFixed18 shortfall) {
        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);

        if (newBalance.sign() == -1) {
            shortfall = self.shortfall.add(newBalance.abs());
            newBalance = Fixed18Lib.ZERO;
        }

        self.balances[account] = newBalance.abs();
        self.shortfall = self.shortfall.add(shortfall);
    }"
17.md,Incorrect use of operator leads to arbitrary minting of GVT tokens,"The `distributeStrategyGainLoss()` function distributes any gains or losses generated from a harvest and is expected to be called only by valid protocol vault adaptors. It is an externally visible function and the access control is indirectly enforced on `msg.sender` by checking that `vaultIndexes[msg.sender]` is a valid index range 1-4. However, the operator used in the `require()` is `||` instead of `&&`, which allows an arbitrary `msg.sender`, i.e. attacker, to bypass the check.

Scenario: An arbitrary non-vault address calling this function will get an index of 0 because of default mapping value in `vaultIndexes[msg.sender]`, which will fail the `> 0` check, but pass the `<= N_COINS + 1` check (`N_COINS = 3`) because `0 <= 4` which will allow control to go past this check.

Furthermore, on L362, `index=0` will underflow the -1 decrement (due to lack of `SafeMath.sub` and use of < 0.8.0 solc) and the index will be set to `(uint256_MAX - 1)`. This will allow execution to proceed to the ""else"" part of conditional meant for curve LP vault. Therefore, this will allow any random address to call this function with arbitrary values of gain/loss and distribute arbitrary gain/loss appearing to come from Curve vault.

The attack control flow:
* -> `Controller.distributeStrategyGainLoss(ARBITRARY_HIGH_VALUE_OF_GAIN, 0)`
* -> `index = 0` passes check for the `index <= N_COINS + 1` part of predicate on L357 in `Controller.sol`
* -> `index = uint256_MAX` after L362
* -> `gainUsd = ibuoy.lpToUsd(ARBITRARY_HIGH_VALUE_OF_GAIN);` on L371 in `Controller.sol`
* -> `ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);` on L376 in `Controller.sol`
* -> `(gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);` on L254 in `PnL.sol`
* -> `performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);` on L186 of `PnL.sol`
* ->  `gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);` on L256 in `PnL.sol`",high,"Recommend changing `||` to `&&` in `require()` on L357 of `Controller.sol` to prevent arbitrary addresses from going past this check. Or, consider exercising explicit access control for the authorized vault adaptors.

Confirmed and Fix has been implemented in release version.","function distributeStrategyGainLoss(uint256 gain, uint256 loss) external override {
        uint256 index = vaultIndexes[msg.sender];
        require(index > 0 || index <= N_COINS + 1, ""!VaultAdaptor"");
        IPnL ipnl = IPnL(pnl);
        IBuoy ibuoy = IBuoy(buoy);
        uint256 gainUsd;
        uint256 lossUsd;
        index = index - 1;
        if (index < N_COINS) {
            if (gain > 0) {
                gainUsd = ibuoy.singleStableToUsd(gain, index);
            } else if (loss > 0) {
                lossUsd = ibuoy.singleStableToUsd(loss, index);
            }
        } else {
            if (gain > 0) {
                gainUsd = ibuoy.lpToUsd(gain);
            } else if (loss > 0) {
                lossUsd = ibuoy.lpToUsd(loss);
            }
        }
        ipnl.distributeStrategyGainLoss(gainUsd, lossUsd, reward);
        // Check if curve spot price within tollerance, if so update them
        if (ibuoy.updateRatios()) {
            // If the curve ratios were successfully updated, realize system price changes
            ipnl.distributePriceChange(_totalAssets());
        }
    }function handleInvestGain(
        uint256 gvtAssets,
        uint256 pwrdAssets,
        uint256 profit,
        address reward
    )
        private
        view
        returns (
            uint256,
            uint256,
            uint256
        )
    {
        uint256 performanceBonus;
        if (performanceFee > 0 && reward != address(0)) {
            performanceBonus = profit.mul(performanceFee).div(PERCENTAGE_DECIMAL_FACTOR);
            profit = profit.sub(performanceBonus);
        }
        if (rebase) {
            uint256 totalAssets = gvtAssets.add(pwrdAssets);
            uint256 gvtProfit = profit.mul(gvtAssets).div(totalAssets);
            uint256 pwrdProfit = profit.mul(pwrdAssets).div(totalAssets);

            uint256 factor = pwrdAssets.mul(10000).div(gvtAssets);
            if (factor > 10000) factor = 10000;
            if (factor < 8000) {
                factor = factor.mul(3).div(8).add(3000);
            } else {
                factor = factor.sub(8000).mul(2).add(6000);
            }

            uint256 portionFromPwrdProfit = pwrdProfit.mul(factor).div(10000);
            gvtAssets = gvtAssets.add(gvtProfit.add(portionFromPwrdProfit));
            pwrdAssets = pwrdAssets.add(pwrdProfit.sub(portionFromPwrdProfit));
        } else {
            gvtAssets = gvtAssets.add(profit);
        }
        return (gvtAssets, pwrdAssets, performanceBonus);
    }

function distributeStrategyGainLoss(
        uint256 gain,
        uint256 loss,
        address reward
    ) external override {
        require(msg.sender == controller, ""!Controller"");
        uint256 lastGA = lastGvtAssets;
        uint256 lastPA = lastPwrdAssets;
        uint256 performanceBonus;
        uint256 gvtAssets;
        uint256 pwrdAssets;
        int256 investPnL;
        if (gain > 0) {
            (gvtAssets, pwrdAssets, performanceBonus) = handleInvestGain(lastGA, lastPA, gain, reward);
            if (performanceBonus > 0) {
                gvt.mint(reward, gvt.factor(gvtAssets), performanceBonus);
                gvtAssets = gvtAssets.add(performanceBonus);
            }

            lastGvtAssets = gvtAssets;
            lastPwrdAssets = pwrdAssets;
            investPnL = int256(gain);
        } else if (loss > 0) {
            (lastGvtAssets, lastPwrdAssets) = handleLoss(lastGA, lastPA, loss);
            investPnL = -int256(loss);
        }

        emit LogPnLExecution(
            0,
            investPnL,
            investPnL,
            0,
            0,
            performanceBonus,
            lastGA,
            lastPA,
            lastGvtAssets,
            lastPwrdAssets
        );
    }"
192.md,Incorrect Assumption of Stablecoin Market Stability,"The `StableVault` contract attempts to group all types of stablecoins under a single token which can be minted for any of the stablecoins supported by the system as well as burned for any of them.

This is at minimum a medium-severity vulnerability as the balance sheet of the `StableVault` will consist of multiple assets which do not have a one-to-one exchange ratio between them as can be observed by trading pools such as Curve as well as the Chainlink oracle reported prices themselves.

Given that the contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices, the balance sheet of the contract can be arbitraged (especially by flash-loans) to swap an undesirable asset (i.e. USDC which at the time of submission was valued at 0.99994853 USD) for a more desirable asset (i.e. USDT which at the time of submission was valued at 1.00000000 USD) acquiring an arbitrage in the price by selling the traded asset.",high,"We advise the `StableVault` to utilize Chainlink oracles for evaluating the inflow of assets instead, ensuring that all inflows and outflows of stablecoins are fairly evaluated based on their ""neutral"" USD price rather than their subjective on-chain price or equality assumption.","function deposit(address _token, uint256 _amount) public {
        require(allowed[_token], ""Token not listed"");
        IERC20(_token).transferFrom(_msgSender(), address(this), _amount);
        IERC20Mintable(stable).mintFor(
            _msgSender(),
            _amount*(10**(18-IERC20Mintable(_token).decimals()))
        );
    }

function withdraw(address _token, uint256 _amount) external returns (uint256 _output) {
        IERC20Mintable(stable).burnFrom(_msgSender(), _amount);
        _output = _amount/10**(18-IERC20Mintable(_token).decimals());
        IERC20(_token).transfer(
            _msgSender(),
            _output
        );
    }"
83.md,`StakingRewards.recoverERC20` allows owner to rug the `rewardsToken`,"`StakingRewards.recoverERC20` rightfully checks against the `stakingToken` being sweeped away.
However, there's no check against the `rewardsToken` which over time will sit in this contract.

This is the case of an admin privilege, which allows the owner to sweep the rewards tokens, perhaps as a way to rug depositors.

### Proof of Concept

Calling `StakingRewards.recoverERC20(rewardsToken, rewardsToken.balanceOf(this))` enables the `owner` to sweep the token.",medium,"Add an additional check

            require(
                tokenAddress != address(rewardsToken),
                ""Cannot withdraw the rewards token""
            );","function recoverERC20(address tokenAddress, uint256 tokenAmount)
        external
        onlyOwner
    {
        require(
            tokenAddress != address(stakingToken),
            ""Cannot withdraw the staking token""
        );
        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }"
29.md,"`IndexPool.mint` The first liquidity provider is forced to supply assets in the same amount, which may cause a significant amount of fund loss","When `reserve == 0`, `amountIn` for all the tokens will be set to the same amount: `ratio`, regardless of the weights, decimals and market prices of the assets.

The first liquidity provider may not be aware of this so that it may create an arbitrage opportunity for flashbots to take a significant portion of the value of The first liquidity provider's liquidity.

Proof of Concept
Given:

*   A `IndexPool` of 99% USDT and 1% WBTC;
*   Alice is the first liquidity provider.

1.  Alice transfers 1e18 WBTC and 1e18 USDT to mint 100e18 of liquidity;
2.  Bob can use 100e18 USDT (~$100) to swap out most of the balance of WBTC.

Impact
A significant portion (>90% in the case above) of the user's funds can be lost due to arbitrage.",high,Consider allowing the first liquidity provider to use custom `amountIn` values for each token or always takes the MIN_BALANCE of each token.,"function mint(bytes calldata data) public override lock returns (uint256 liquidity) {
        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));
        
        uint120 ratio = uint120(_div(toMint, totalSupply));

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenIn = tokens[i];
            uint120 reserve = records[tokenIn].reserve;
            // @dev If token balance is '0', initialize with `ratio`.
            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;
            require(amountIn >= MIN_BALANCE, ""MIN_BALANCE"");
            // @dev Check Trident router has sent `amountIn` for skim into pool.
            unchecked { // @dev This is safe from overflow - only logged amounts handled.
                require(_balance(tokenIn) >= amountIn + reserve, ""NOT_RECEIVED"");
                records[tokenIn].reserve += amountIn;
            }
            emit Mint(msg.sender, tokenIn, amountIn, recipient);
        }
        _mint(recipient, toMint);
        liquidity = toMint;
    }"
100.md,Strategy Migration May Leave Tokens in the Old Strategy Impacting Share Calculations,"If a strategy does not have sufficient funds to `withdraw()` for the full amount then it is possible that tokens will be left in this yield contract during `migrate()`.

It is common for withdrawal from a strategy to withdraw less than a user's balance. The reason is that these yield protocols may lend the deposited funds to borrowers, if there is less funds in the pool than the withdrawal amount the withdrawal may succeed but only transfer the funds available rather than the full withdrawal amount.

The impact of tokens remaining in the old strategy is that when we call `StrategyController.totalValue()` this will only account for the tokens deposited in the new strategy and not those stuck in the previous strategy. Therefore `totalValue()` is undervalued.

Thus, when a user calls `Collateral.deposit()` the share calculations `_shares = (_amountToDeposit * totalSupply()) / (_valueBefore);` will be over stated (note: `uint256 _valueBefore = _strategyController.totalValue();`). Hence, the user will receive more shares than they should.

The old tokens may be recovered by calling `migrate()` back to the old strategy. If this is done then `totalValue()` will now include the tokens previously stuck. The recent depositer may now withdraw and will be owed `(_strategyController.totalValue() * _amount) / totalSupply()`. Since `totalValue()` is now includes the previously stuck tokens  `_owed` will be overstated and the user will receive more collateral than they should.

The remaining users who had deposited before `migrate()` will lose tokens proportional to their share of the `totalSupply()`.",high,"The recommendation is to ensure that `require(_oldStrategy.totalValue() == 0)` after calling `_oldStrategy.withdraw()`. This ensures that no funds are left in the strategy. Consider the code example below.

        function migrate(IStrategy _newStrategy)
            external
            override
            onlyOwner
            nonReentrant
        {
            uint256 _oldStrategyBalance;
            IStrategy _oldStrategy = _strategy;
            _strategy = _newStrategy;
            _baseToken.approve(address(_newStrategy), type(uint256).max);
            if (address(_oldStrategy) != address(0)) {
                _baseToken.approve(address(_oldStrategy), 0);
                _oldStrategyBalance = _oldStrategy.totalValue();
                _oldStrategy.withdraw(address(this), _oldStrategyBalance);
                require(_oldStrategy.totalValue() == 0)
                _newStrategy.deposit(_baseToken.balanceOf(address(this)));
            }
            emit StrategyMigrated(
                address(_oldStrategy),
                address(_newStrategy),
                _oldStrategyBalance
            );
        }","function deposit(uint256 _amount)
        external
        override
        onlyVault
        nonReentrant
    {
        _baseToken.safeTransferFrom(_vault, address(this), _amount);
        _strategy.deposit(_baseToken.balanceOf(address(this)));
    }

function migrate(IStrategy _newStrategy)
        external
        override
        onlyOwner
        nonReentrant
    {
        uint256 _oldStrategyBalance;
        IStrategy _oldStrategy = _strategy;
        _strategy = _newStrategy;
        _baseToken.approve(address(_newStrategy), type(uint256).max);
        if (address(_oldStrategy) != address(0)) {
            _baseToken.approve(address(_oldStrategy), 0);
            _oldStrategyBalance = _oldStrategy.totalValue();
            _oldStrategy.withdraw(address(this), _oldStrategyBalance);
            _newStrategy.deposit(_baseToken.balanceOf(address(this)));
        }
        emit StrategyMigrated(
            address(_oldStrategy),
            address(_newStrategy),
            _oldStrategyBalance
        );
    }

function totalValue() external view override returns (uint256) {
        return _baseToken.balanceOf(address(this)) + _strategy.totalValue();
    }"
190.md,Users do not receive owed tokens if `TokenSender` contract cannot cover their owed amount.,"The `TokenSender.send()` method is called during the course of users withdrawing or redeeming tokens from the protocol. The method is called via `DepositHook.hook()`, `RedeemHook.hook()`, and `WithdrawHook.hook()`. These in turn are called in `prePOMarket.redeem()` or `Collateral.deposit()`/`.withdraw()`.

`TokenSender.send()` contains some logic to return early without sending any of the ""outputToken"", such as if the price of the outputToken has fallen below an adjustable lower bound, or if the amount would be 0.

However, it also checks its own balance to see if it can cover the required amount. If it cannot, it simply doesn't send tokens. These tokens are intended to be a compensation for fees paid elsewhere in the process, and thus do represent a value loss.

The documentation in `ITokenSender.sol` states this is so the protocol doesn't halt the redeem and deposit/withdraw actions.

### Impact

The warden agrees that the protocol halting is generally undesirable.

However, there isn't any facility in the code for the user who triggered the overage amount to be able to later receive their tokens when the contract is topped up. They must rely upon governance to send them any owed tokens. This increases centralization risks and isn't necessary.

Since the contract makes no attempt to track the tokens that should have been sent, manually reviewing and verifying owed tokens becomes a non-trivial task if any more than a handful of users were affected.

Since the user did receive their underlying collateral in any case and the loss isn't necessarily permanent, medium seems to be the right severity for this issue.

### Proof of Concept

Bob wants to redeem his long and short tokens via `PrePOMarket.redeem()`. However, Alice's redemption prior to his, significantly drained the `TokenSender` contract of its tokens. As a result, Bob's redemption fails to benefit him in the amount of the outputToken he should have received in compensation for the fees paid.

Because the quantity of tokens paid to Bob is partially dependent upon the token's price at the time of redemption, the protocol might shoulder more downside loss (token price dropped compared to when Bob redeemed, must pay out more tokens) or Bob might suffer upside loss (price went up compared to time of redemption, Bob loses the difference).

Bob's recourse is to contact the project administrators and try to have his tokens sent to him manually. Agreeing to a value adds friction to the process.",medium,"The `TokenSender` contract should track users whose balance wasn't covered in a mapping, as well as a function for them to manually claim tokens later on if the contract's balance is topped up. Such a function might record the price at redemption time, or it might calculate it with the current price.","function send(address recipient, uint256 unconvertedAmount) external override onlyAllowedMsgSenders {
    uint256 scaledPrice = (_price.get() * _priceMultiplier) / MULTIPLIER_DENOMINATOR;
    if (scaledPrice <= _scaledPriceLowerBound) return;
    uint256 outputAmount = (unconvertedAmount * _outputTokenDecimalsFactor) / scaledPrice;
    if (outputAmount == 0) return;
    if (outputAmount > _outputToken.balanceOf(address(this))) return;
    _outputToken.transfer(recipient, outputAmount);
  }function deposit(address _recipient, uint256 _amount) external override nonReentrant returns (uint256) {
    uint256 _fee = (_amount * depositFee) / FEE_DENOMINATOR;
    if (depositFee > 0) { require(_fee > 0, ""fee = 0""); }
    else { require(_amount > 0, ""amount = 0""); }
    baseToken.transferFrom(msg.sender, address(this), _amount);
    uint256 _amountAfterFee = _amount - _fee;
    if (address(depositHook) != address(0)) {
      baseToken.approve(address(depositHook), _fee);
      depositHook.hook(_recipient, _amount, _amountAfterFee);
      baseToken.approve(address(depositHook), 0);
    }
    /// Converts amount after fee from base token units to collateral token units.
    uint256 _collateralMintAmount = (_amountAfterFee * 1e18) / baseTokenDenominator;
    _mint(_recipient, _collateralMintAmount);
    emit Deposit(_recipient, _amountAfterFee, _fee);
    return _collateralMintAmount;
  }

function withdraw(uint256 _amount) external override nonReentrant {
    uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;
    uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;
    if (withdrawFee > 0) { require(_fee > 0, ""fee = 0""); }
    else { require(_baseTokenAmount > 0, ""amount = 0""); }
    _burn(msg.sender, _amount);
    uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;
    if (address(withdrawHook) != address(0)) {
      baseToken.approve(address(withdrawHook), _fee);
      withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);
      baseToken.approve(address(withdrawHook), 0);
    }
    baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);
    emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee);
  }function hook(address sender, uint256 amountBeforeFee, uint256 amountAfterFee) external virtual override onlyAllowedMsgSenders {
    require(_accountList.isIncluded(sender), ""redeemer not allowed"");
    uint256 fee = amountBeforeFee - amountAfterFee;
    if (fee > 0) {
      IPrePOMarket(msg.sender).getCollateral().transferFrom(msg.sender, _treasury, fee);
      _tokenSender.send(sender, fee);
    }
  }function hook(
    address _sender,
    uint256 _amountBeforeFee,
    uint256 _amountAfterFee
  ) external override onlyCollateral {
    require(withdrawalsAllowed, ""withdrawals not allowed"");
    if (lastGlobalPeriodReset + globalPeriodLength < block.timestamp) {
      lastGlobalPeriodReset = block.timestamp;
      globalAmountWithdrawnThisPeriod = _amountBeforeFee;
    } else {
      require(globalAmountWithdrawnThisPeriod + _amountBeforeFee <= globalWithdrawLimitPerPeriod, ""global withdraw limit exceeded"");
      globalAmountWithdrawnThisPeriod += _amountBeforeFee;
    }
    if (lastUserPeriodReset + userPeriodLength < block.timestamp) {
      lastUserPeriodReset = block.timestamp;
      userToAmountWithdrawnThisPeriod[_sender] = _amountBeforeFee;
    } else {
      require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, ""user withdraw limit exceeded"");
      userToAmountWithdrawnThisPeriod[_sender] += _amountBeforeFee;
    }
    depositRecord.recordWithdrawal(_amountBeforeFee);
    uint256 _fee = _amountBeforeFee - _amountAfterFee;
    if (_fee > 0) {
      collateral.getBaseToken().transferFrom(address(collateral), _treasury, _fee);
      _tokenSender.send(_sender, _fee);
    }
  }function hook(address _sender, uint256 _amountBeforeFee, uint256 _amountAfterFee) external override onlyCollateral {
    require(depositsAllowed, ""deposits not allowed"");
    if (!_accountList.isIncluded(_sender)) require(_satisfiesScoreRequirement(_sender), ""depositor not allowed"");
    depositRecord.recordDeposit(_sender, _amountAfterFee);
    uint256 _fee = _amountBeforeFee - _amountAfterFee;
    if (_fee > 0) {
      collateral.getBaseToken().transferFrom(address(collateral), _treasury, _fee);
      _tokenSender.send(_sender, _fee);
    }
  }"
54.md,Missing scaling factor in `recordKeyPurchase`?,"The `Unlock.recordKeyPurchase` function computes the `maxTokens` as:

maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;

Note that `grossNetworkProduct` was already increased by `valueInETH` in the code before.
Meaning, the `(2 + 2 * valueInETH / grossNetworkProduct)` part of the computation will almost always be `2` as usually `grossNetworkProduct > 2 * valueInETH`, and thus the `2 * valueInETH / grossNetworkProduct` is zero by integer division.

#### Impact

The `maxTokens` curve might not be computed as intended and lead to being able to receive more token rewards than intended.",medium,"The comment ""we distribute tokens using asymptotic curve between 0 and 0.5"" should be more clear to indicate how exactly the curve looks like. It could be that a floating-point number was desired instead of the integer division in `2 * valueInETH / grossNetworkProduct`. In that case, consider adding a scaling factor to this term and divide by it at the end of the computation again.","function recordKeyPurchase(
    uint _value,
    address _referrer
  )
    public
    onlyFromDeployedLock()
  {
    if(_value > 0) {
      uint valueInETH;
      address tokenAddress = IPublicLock(msg.sender).tokenAddress();
      if(tokenAddress != address(0) && tokenAddress != weth) {
        // If priced in an ERC-20 token, find the supported uniswap oracle
        IUniswapOracle oracle = uniswapOracles[tokenAddress];
        if(address(oracle) != address(0)) {
          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);
        }
      }
      else {
        // If priced in ETH (or value is 0), no conversion is required
        valueInETH = _value;
      }

      grossNetworkProduct = grossNetworkProduct + valueInETH;
      // If GNP does not overflow, the lock totalSales should be safe
      locks[msg.sender].totalSales += valueInETH;

      // Mint UDT
      if(_referrer != address(0))
      {
        IUniswapOracle udtOracle = uniswapOracles[udt];
        if(address(udtOracle) != address(0))
        {
          // Get the value of 1 UDT (w/ 18 decimals) in ETH
          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);

          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut
          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;

          // or tokensToDistribute is capped by network GDP growth
          uint maxTokens = 0;
          if (chainId > 1)
          {
            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5
            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));
            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;
          } else {
            // Mainnet: we mint new token using log curve
            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;
          }

          // cap to GDP growth!
          if(tokensToDistribute > maxTokens)
          {
            tokensToDistribute = maxTokens;
          }

          if(tokensToDistribute > 0)
          {
            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer
            uint devReward = tokensToDistribute * 20 / 100;
            if (chainId > 1)
            {
              uint balance = IMintableERC20(udt).balanceOf(address(this));
              if (balance > tokensToDistribute) {
                // Only distribute if there are enough tokens
                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);
                IMintableERC20(udt).transfer(owner(), devReward);
              }
            } else {
              // No distribnution
              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);
              IMintableERC20(udt).mint(owner(), devReward);
            }
          }
        }
      }
    }
  }"
5.md,Users may unintentionally remove liquidity under a phishing attack.,"The `removeLiquidity` function in `Pools.sol` uses `tx.origin` to determine the person who wants to remove liquidity. However, such a design is dangerous since the pool assumes that this function is called from the router, which may not be true if the user is under a phishing attack, and he could unintentionally remove liquidity.

Vader's security assumption is a user is not phished.",high,"Consider making the function `_removeLiquidity` external, which can be utilized by the router, providing information of which person removes his liquidity.","function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router
    }"
59.md,No max for advanceIncentive,"The function setAdvanceIncentive of DAO.sol doesn't check for a maximum value of incentive. If incentive would be very large, then advanceIncentive would be very large and the function advance() would mint a large amount of malt.

The function setAdvanceIncentive() can only be called by an admin, but a mistake could be made. Also if an admin would want to do a rug pull, this would be an ideal place to do it.",medium,Check for a reasonable maximum value in advance(),"function advance() external {
    require(block.timestamp >= getEpochStartTime(epoch + 1), ""Cannot advance epoch until start of new epoch"");

    incrementEpoch();

    malt.mint(msg.sender, advanceIncentive * 1e18);

    emit Advance(epoch, block.number, block.timestamp);
  }

function setAdvanceIncentive(uint256 incentive)
    external
    onlyRole(ADMIN_ROLE, ""Must have admin role"")
  {
    advanceIncentive = incentive;
    emit SetAdvanceIncentive(incentive);
  }"
21.md,User's `calcUnderlyingInStoredUSD` value is underestimated,"The `calcUnderlyingInStoredUSD()` function of `SherX` should return `calcUnderlyingInStoredUSD(getSherXBalance())` instead of `calcUnderlyingInStoredUSD(sx20.balances[msg.sender])` since there could be `SherX` unallocated to the user at the time of the function call. A similar function, `calcUnderlying()`, calculates the user's underlying tokens based on the user's current balance plus the unallocated ones.",low,Recommend changing `sx20.balances[msg.sender]` to `getSherXBalance()` at line 141 in `SherX.sol`.,"function calcUnderlyingInStoredUSD() external view override returns (uint256) {
    SherXERC20Storage.Base storage sx20 = SherXERC20Storage.sx20();
    return calcUnderlyingInStoredUSD(sx20.balances[msg.sender]);
  }

function calcUnderlyingInStoredUSD(uint256 _amount) public view override returns (uint256 usd) {
    SherXStorage.Base storage sx = SherXStorage.sx();
    GovStorage.Base storage gs = GovStorage.gs();

    uint256 total = LibSherX.getTotalSherX();
    if (total == 0) {
      return 0;
    }
    for (uint256 i; i < gs.tokensSherX.length; i++) {
      IERC20 token = gs.tokensSherX[i];

      usd = usd.add(
        PoolStorage
          .ps(token)
          .sherXUnderlying
          .add(LibPool.getTotalAccruedDebt(token))
          .mul(_amount)
          .mul(sx.tokenUSD[token])
          .div(10**18)
          .div(total)
      );
    }
  }"
42.md,`treasuryShare` is Overwritten in `FeePoolV0._shareMochi()`,"The `FeePoolV0.sol` contract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury and `vMochi` contracts. However, when `distributeMochi()` is called to distribute `mochi` tokens to `veCRV` holders, both `mochiShare` and `treasuryShare` is flushed from the contract when there are still `usdm` tokens in the contract.

Proof of Concept:

Consider the following scenario:

*   The `FeePoolV0.sol` contract contains 100 `usdm` tokens at an exchange rate of 1:1 with `mochi` tokens.
*   `updateReserve()` is called to set the split of `usdm` tokens such that `treasuryShare` has claim on 20 `usdm` tokens and `mochiShare` has claim on the other 80 tokens.
*   A `veCRV` holder seeks to increase their earnings by calling `distributeMochi()` before `sendToTreasury()` has been called.
*   As a result, 80 `usdm` tokens are converted to `mochi` tokens and  locked in a curve rewards pool.
*   Consequently, `mochiShare` and `treasuryShare` is set to `0` (aka flushed).
*   The same user calls `updateReserve()` to split the leftover 20 `usdm` tokens between `treasuryShare` and `mochiShare`.
*   `mochiShare` is now set to 16 `usdm` tokens.
*   The above process is repeated to distribute `mochi` tokens to `veCRV` holders again and again.
*   The end result is that `veCRV` holders have been able to receive all tokens that were intended to be distributed to the treasury.",high,Consider removing the line in `FeePoolV0.sol` where `treasuryShare` is flushed.,"function distributeMochi() external {
        // buy Mochi with mochiShare
        _buyMochi();
        _shareMochi();
    }"
20.md,Missing revert if denominator = 0,"In Synth.sol, the function burnSynth() calculates a division between two variables. Since they can be zero, it's better to have a require with a clear error message when the division is not possible, otherwise an user wouldn't know why a transaction reverted.",low,"Recommend adding a require(denom != 0, ""LPDebt = 0"").","function burnSynth() external returns (bool){
        uint _syntheticAmount = balanceOf(address(this)); // Get the received synth units
        uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; // share = amount * part/total
        mapSynth_LPBalance[msg.sender] -= _amountUnits; // Reduce lp balance
        mapSynth_LPDebt[msg.sender] -= _syntheticAmount; // Reduce debt by synths being burnt
        if(_amountUnits > 0){
            _burn(address(this), _syntheticAmount); // Burn the synths
            Pool(msg.sender).burn(_amountUnits); // Burn the LP tokens
        }
        return true;
    }"
52.md,`BasePool.mint()` Is Callable By Anyone,The `BasePool.mint()` function differs from its implementation in `BasePoolV2.mint()` in which it lacks an `onlyRouter` modifier. This ensures that users cannot call this function directly as `VaderRouter.addLiquidity()` performs some necessary input validation which can be bypassed by directly calling `BasePool.mint()`.,medium,Consider adding an `onlyRouter` modifier to the `BasePool.mint()` function to ensure users cannot directly call this function.,"function mint(address to)
        external
        override
        nonReentrant
        returns (uint256 liquidity)
    {
        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings
        uint256 balanceNative = nativeAsset.balanceOf(address(this));
        uint256 balanceForeign = foreignAsset.balanceOf(address(this));
        uint256 nativeDeposit = balanceNative - reserveNative;
        uint256 foreignDeposit = balanceForeign - reserveForeign;

        uint256 totalLiquidityUnits = totalSupply;
        if (totalLiquidityUnits == 0)
            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach
        else
            liquidity = VaderMath.calculateLiquidityUnits(
                nativeDeposit,
                reserveNative,
                foreignDeposit,
                reserveForeign,
                totalLiquidityUnits
            );

        require(
            liquidity > 0,
            ""BasePool::mint: Insufficient Liquidity Provided""
        );

        uint256 id = positionId++;

        totalSupply += liquidity;
        _mint(to, id);

        positions[id] = Position(
            block.timestamp,
            liquidity,
            nativeDeposit,
            foreignDeposit
        );

        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);

        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);
        emit PositionOpened(msg.sender, id, liquidity);
    }"
83.md,Rogue pool in Shelter,"Shelter contract can steal user tokens.

Proof of Concept

Shelter `client` can call `activate` on an already activated token, this will reset its start time, so if the client activate a token when it `GRACE_PERIOD` is almost finished, it will reset this time.
This will prevent the user to call `withdraw` because the condition `activated[_token] + GRACE_PERIOD < block.timestamp` but will allow the client to call `deactivate` and receive all funds from the users because it will satisfy the condition `activated[_token] + GRACE_PERIOD > block.timestamp`.

Steps:

*   client `activate` tokenA.
*   Users deposit tokenA using `donate`.
*   client `activate` tokenA again until they has enough tokens.
*   More users use `donate`.
*   client deactivate tokenA and receive all tokens.",medium,"*   Avoid `activate` twice for the same token
*   `donate` only after the `GRACE_PERIOD`","function donate(IERC20 _token, uint256 _amount) external {
        require(activated[_token] != 0, ""!activated"");
        savedTokens[_token] += _amount;
        _token.safeTransferFrom(msg.sender, address(this), _amount);
    }

function activate(IERC20 _token) external override onlyClient {
        activated[_token] = block.timestamp;
        savedTokens[_token] = _token.balanceOf(address(this));
        emit ShelterActivated(_token);
    }

function deactivate(IERC20 _token) external override onlyClient {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, ""too late"");
        activated[_token] = 0;
        savedTokens[_token] = 0;
        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));
        emit ShelterDeactivated(_token);
    }"
42.md,Changing engine.nft contract breaks vaults,"Governance can change the `engine.nft` address which is used by vaults to represent collateralized debt positions (CDP).
When minting a vault using `MochiVault.mint` the address returned ID will be used and overwrite the state of an existing debt position and set its status to `Idle`.

Impact:
Changing the NFT address will allow overwriting existing CDPs.",medium,Disallow setting a new NFT address or ensure that the new NFT's IDs start at the old NFT's IDs.,"function mint(address _recipient, address _referrer)
        public
        returns (uint256 id)
    {
        id = engine.nft().mint(address(asset), _recipient);
        details[id].debtIndex = liveDebtIndex();
        details[id].status = Status.Idle;
        details[id].referrer = _referrer;
    }"
36.md,Factory.sol - lack of checks in `setAuctionDecrement` will cause reverts in Auction::settleAuction(),"`setAuctionDecrement` doesn't check for a min nor a max amount
This means we can change `auctionDecrement` which would allow `owner` to set `auctionDecrement` to 0

This will cause the function `settleAuction` in Auction.sol to revert

This allows the owner to block auctions from being settled

Proof of Concept

`setAuctionDecrement(0)`
Now `settleAuction` will revert due to division by 0",medium,"Add checks in `setAuctionDecrement`
Refactor to
function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {
    require(newAuctionDecrement > AMOUNT);
    require(newAuctionDecrement <= AMOUNT_2);
    auctionDecrement = newAuctionDecrement;
}","function settleAuction(
        uint256[] memory bountyIDs,
        address[] memory inputTokens,
        uint256[] memory inputWeights,
        address[] memory outputTokens,
        uint256[] memory outputWeights
    ) public override {
        require(auctionOngoing);
        require(hasBonded);
        require(bondTimestamp + ONE_DAY > block.number);
        require(msg.sender == auctionBonder);

        for (uint256 i = 0; i < inputTokens.length; i++) {
            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);
        }

        for (uint256 i = 0; i < outputTokens.length; i++) {
            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);
        }

        uint256 a = factory.auctionMultiplier() * basket.ibRatio();
        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();
        uint256 newRatio = a - b;

        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();
        IERC20 basketAsERC20 = IERC20(address(basket));

        for (uint256 i = 0; i < pendingWeights.length; i++) {
            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;
            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);
        }

        basketAsERC20.transfer(msg.sender, bondAmount);
        withdrawBounty(bountyIDs);
        basket.setNewWeights();
        basket.updateIBRatio(newRatio);
        auctionOngoing = false;
        hasBonded = false;

        emit AuctionSettled(msg.sender);
    }"
7.md,Use 'receive' when expecting eth and empty call data,"Contract CEther fallback function was refactored to be compatible with the Solidity 0.6 version:

```solidity
/**
* @notice Send Ether to CEther to mint
*/
fallback () external payable {
    (uint err,) = mintInternal(msg.value);
    requireNoError(err, ""mint failed"");
}
```

From Solidity 0.6 documentation:

""The unnamed function commonly referred to as “fallback function” was split up into a new fallback function that is defined using the fallback keyword and a receive ether function defined using the receive keyword. If present, the receive ether function is called whenever the call data is empty (whether or not ether is received). This function is implicitly payable. The new fallback function is called when no other function matches (if the receive ether function does not exist then this includes calls with empty call data). You can make this function payable or not. If it is not payable then transactions not matching any other function which send value will revert. You should only need to implement the new fallback function if you are following an upgrade or proxy pattern.""

In this case, ""receive"" may be more suitable as the function is expecting to receive ether and empty call data.",low,"Recommend replacing ""fallback"" with ""receive"".","fallback () external payable {
        (uint err,) = mintInternal(msg.value);
        requireNoError(err, ""mint failed"");
    }"
83.md,`USDMPegRecovery.sol#withdraw()` withdraw may often fail,"However, because the `withdraw()` function takes funds from the balance of the contract, once the majority of the funds are added to the curve pool via `provide()`. The `withdraw()` may often fail due to insufficient funds in the balance.

### Proof of Concept

1.  Alice deposits `4M` USDM and `4M` pool3 tokens;
2.  Guardian calls `provide()` and all the `usdm` and `pool3` to `usdm3crv`;
3.  Alice calls `withdraw()`, the tx will fail, due to insufficient balance.",medium,Consider calling `usdm3crv.remove_liquidity_one_coin()` when the balance is insufficient for the user's withdrawal.,"function withdraw(Liquidity calldata _withdrawal) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_withdrawal.usdm > 0) {
            require(unlockable, ""!unlock usdm"");
            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));
            total.usdm -= _withdrawal.usdm;
            user.usdm -= _withdrawal.usdm;
        }

        if(_withdrawal.pool3 > 0) {
            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));
            total.pool3 -= _withdrawal.pool3;
            user.pool3 -= _withdrawal.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Withdraw(msg.sender, _withdrawal);
    }"
89.md,InsuranceFund depositors can be priced out & deposits can be stolen,"The `InsuranceFund.deposit` function mints initial `shares` equal to the deposited amount. The deposit / withdraw functions also use the VUSD contract balance for the shares computation. (`balance() = vusd.balanceOf(address(this))`)

It's possible to increase the share price to very high amounts and price out smaller depositors.

### Proof of Concept

*   `deposit(_amount = 1)`: Deposit the smallest unit of VUSD as the first depositor. Mint 1 share and set the total supply and VUSD balance to `1`.
*   Perform a direct transfer of `1000.0` VUSD to the `InsuranceFund`. The `balance()` is now `1000e6 + 1`
*   Doing any deposits of less than `1000.0` VUSD will mint zero shares: `shares = _amount * _totalSupply / _pool = 1000e6 * 1 / (1000e6 + 1) = 0`.
*   The attacker can call `withdraw(1)` to burn their single share and receive the entire pool balance, making a profit. (`balance() * _shares / totalSupply() = balance()`)

I give this a high severity as the same concept can be used to always steal the initial insurance fund deposit by frontrunning it and doing the above-mentioned steps, just sending the frontrunned deposit amount to the contract instead of the fixed `1000.0`.
They can then even repeat the steps to always frontrun and steal any deposits.",high,The way UniswapV2 prevents this is by requiring a minimum deposit amount and sending 1000 initial shares to the zero address to make this attack more expensive. The same mitigation can be done here.,"function deposit(uint _amount) external {
        settlePendingObligation();
        // we want to protect new LPs, when the insurance fund is in deficit
        require(pendingObligation == 0, ""IF.deposit.pending_obligations"");

        uint _pool = balance();
        uint _totalSupply = totalSupply();
        if (_totalSupply == 0 && _pool > 0) { // trading fee accumulated while there were no IF LPs
            vusd.safeTransfer(governance, _pool);
            _pool = 0;
        }

        vusd.safeTransferFrom(msg.sender, address(this), _amount);
        uint shares = 0;
        if (_pool == 0) {
            shares = _amount;
        } else {
            shares = _amount * _totalSupply / _pool;
        }
        _mint(msg.sender, shares);
        emit FundsAdded(msg.sender, _amount, block.timestamp);
    }

function withdraw(uint _shares) external {
        settlePendingObligation();
        require(pendingObligation == 0, ""IF.withdraw.pending_obligations"");
        uint amount = balance() * _shares / totalSupply();
        _burn(msg.sender, _shares);
        vusd.safeTransfer(msg.sender, amount);
        emit FundsWithdrawn(msg.sender, amount, block.timestamp);
    }"
42.md,Tokens Can Be Stolen By Frontrunning `VestedRewardPool.vest()` and `VestedRewardPool.lock()`,"The `VestedRewardPool.sol` contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their `mochi`. The `vest()` function does not utilise `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to `vest()` and effectively steal a recipient's vested tokens. The same issue applies to the `lock()` function.",high,"Ensure that users understand that this function should not be interacted directly as this could result in lost `mochi` tokens. Additionally, it might be worthwhile creating a single externally facing function which calls `safeTransferFrom()`, `vest()` and `lock()` in a single transaction.","function vest(address _recipient) external checkClaimable(_recipient) {
        uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;
        uint256 weightedEnd = (vesting[_recipient].vested *
            vesting[_recipient].ends +
            amount *
            (block.timestamp + 90 days)) /
            (vesting[_recipient].vested + amount);
        vesting[_recipient].vested += amount;
        vesting[_recipient].ends = weightedEnd;
        mochiUnderManagement += amount;
    }

function lock(uint256 _amount) external checkClaimable(msg.sender) {
        mochi.approve(address(vMochi), _amount);
        (, uint256 end) = vMochi.locked(msg.sender);
        if (end >= block.timestamp + 90 days) {
            vMochi.depositFor(msg.sender, _amount);
        } else {
            revert(""lock should be longer than 90 days"");
        }
        vesting[msg.sender].vested -= _amount;
        mochiUnderManagement -= _amount;
    }"
25.md,`ERC20Rewards` claiming can fail if no reward tokens,The `ERC20Rewards` contract assumes that enough `rewardsToken` are in the contract to pay out when `claim` is called but this value is never checked and claiming rewards can fail.,low,"When setting new rewards periods, make sure that enough `rewardsToken`s are in the contract to cover the entire period.","function claim(address to)
        external
        returns (uint256 claiming)
    {
        _updateRewardsPerToken();
        claiming = _updateUserRewards(msg.sender);
        rewards[msg.sender].accumulated = 0; // A Claimed event implies the rewards were set to zero
        rewardsToken.transfer(to, claiming);
        emit Claimed(to, claiming);
    }"
98.md,`COLLATERAL_MINTER_ROLE` can be granted by the deployer of `QuantConfig` and mint arbitrary amount of tokens,"Using the mintCollateralToken() function of CollateralToken, an address with COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens.

If the private key of the deployer or an address with the COLLATERAL_MINTER_ROLE is compromised, the attacker will be able to mint an unlimited amount of collateral tokens.

We believe this is unnecessary and poses a serious centralization risk.",medium,"Consider removing the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter.","function mintCollateralToken(
        address recipient,
        uint256 collateralTokenId,
        uint256 amount
    ) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_MINTER_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral minter can mint CollateralTokens""
        );

        emit CollateralTokenMinted(recipient, collateralTokenId, amount);

        _mint(recipient, collateralTokenId, amount, """");
    }"
131.md,Amount distributed can be inaccurate when updating weights,"When updating pool inflation rates, other pools see their `currentRate` being modified without having `poolCheckpoint` called, which leads to false computations.

This will lead to either users losing a part of their claims, but can also lead to too many tokens could be distributed, preventing some users from claiming due to the `totalAvailableToNow` requirement in `Minter`.

Imagine you have 2 AMM pools A and B, both with an `ammPoolWeight` of 100, where `poolCheckpoint` has not been called for a moment. Then, imagine calling `executeAmmTokenWeight` to reduce the weight of A to 0.

Only A is checkpointed, so when B will be checkpointed it will call `getAmmRateForToken`, which will see a pool weight of 100 and a total weight of 100 over the whole period since the last checkpoint of B, which is false, therefore it will distribute too many tokens. This is critical as the minter expects an exact or lower than expected distribution due to the requirement of `totalAvailableToNow`.

In the opposite direction, when increasing weights, it will lead to less tokens being distributed in some pools than planned, leading to a loss for users.",medium,"Checkpoint every `LpStakerVault`, `KeeperGauge` or `AmmGauge` when updating the weights of one of them.","function executeAmmTokenWeight(address token) external override returns (uint256) {
        bytes32 key = _getAmmGaugeKey(token);
        _executeAmmTokenWeight(token, key, isInflationWeightManager(msg.sender));
        return currentUInts256[key];
    }

function getAmmRateForToken(address token) external view override returns (uint256) {
        if (minter == address(0) || totalAmmTokenWeight == 0) {
            return 0;
        }
        bytes32 key = _getAmmGaugeKey(token);
        uint256 ammInflationRate = Minter(minter).getAmmInflationRate();
        uint256 ammTokenInflationRate = (currentUInts256[key] * ammInflationRate) /
            totalAmmTokenWeight;
        return ammTokenInflationRate;
    }"
114.md,A malicious early user/attacker can manipulate the vault's `pricePerShare` to take an unfair share of future users' deposits,"This is a well-known attack vector for new contracts that utilize pricePerShare for accounting.

A malicious early user can `supplyTokenTo()` with `1 wei` of `_underlyingAssetAddress` token as the first depositor of the `AaveV3YieldSource.sol`, and get `1 wei` of shares token.

Then the attacker can send `10000e18 - 1` of `aToken` and inflate the price per share from 1.0000 to an extreme value of 1.0000e22 ( from `(1 + 10000e18 - 1) / 1`) .

As a result, the future user who deposits `19999e18` will only receive `1 wei` (from `19999e18 * 1 / 10000e18`) of shares token.

They will immediately lose `9999e18` or half of their deposits if they `redeemToken()` right after the `supplyTokenTo()`.

Furthermore, after the PPS has been inflated to an extremely high value (`10000e18`), the attacker can also redeem tokens up to `9999e18` for free, (burn `0` shares) due to the precision loss.",high,"Consider requiring a minimal amount of share tokens to be minted for the first minter, and send a port of the initial mints as a reserve to the DAO address so that the pricePerShare can be more resistant to manipulation.

Also, consider adding `require(_shares > 0, ""AaveV3YS/shares-gt-zero"");` before `_burn(msg.sender, _shares);`.","function redeemToken(uint256 _redeemAmount) external override nonReentrant returns (uint256) {
    address _underlyingAssetAddress = _tokenAddress();
    IERC20 _assetToken = IERC20(_underlyingAssetAddress);

    uint256 _shares = _tokenToShares(_redeemAmount);
    _burn(msg.sender, _shares);

    uint256 _beforeBalance = _assetToken.balanceOf(address(this));
    _pool().withdraw(_underlyingAssetAddress, _redeemAmount, address(this));
    uint256 _afterBalance = _assetToken.balanceOf(address(this));

    uint256 _balanceDiff = _afterBalance.sub(_beforeBalance);
    _assetToken.safeTransfer(msg.sender, _balanceDiff);

    emit RedeemedToken(msg.sender, _shares, _redeemAmount);
    return _balanceDiff;
  }

function _tokenToShares(uint256 _tokens) internal view returns (uint256) {
    uint256 _supply = totalSupply();

    // shares = (tokens * totalShares) / yieldSourceATokenTotalSupply
    return _supply == 0 ? _tokens : _tokens.mul(_supply).div(aToken.balanceOf(address(this)));
  }

function _sharesToToken(uint256 _shares) internal view returns (uint256) {
    uint256 _supply = totalSupply();

    // tokens = (shares * yieldSourceATokenTotalSupply) / totalShares
    return _supply == 0 ? _shares : _shares.mul(aToken.balanceOf(address(this))).div(_supply);
  }"
52.md,Tokens with fee on transfer are not supported,"There are ERC20 tokens that charge fee for every `transfer()` or `transferFrom()`, E.g `Vader` token.

In the current implementation, `BasePoolV2.sol#mint()` assumes that the received amount is the same as the transfer amount, and uses it to calculate liquidity units.

The function `mint` transfers tokens from the user to the contract using `safeTransferFrom` and then calculates liquidity units based on the deposit amounts passed in as parameters. However, if the token charges a fee on transfer, the actual amount received by the contract will be less than the amount transferred, causing the liquidity calculation to be incorrect. This can lead to inaccurate liquidity units being minted and potential economic discrepancies in the pool.",medium,Consider calling `balanceOf()` to get the actual balances after the transfer to ensure the correct amount of tokens received is used in liquidity calculations.,"function mint(
        IERC20 foreignAsset,
        uint256 nativeDeposit,
        uint256 foreignDeposit,
        address from,
        address to
    )
        external
        override
        nonReentrant
        onlyRouter
        supportedToken(foreignAsset)
        returns (uint256 liquidity)
    {
        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(
            foreignAsset
        ); // gas savings

        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);
        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);

        PairInfo storage pair = pairInfo[foreignAsset];
        uint256 totalLiquidityUnits = pair.totalSupply;
        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;
        else
            liquidity = VaderMath.calculateLiquidityUnits(
                nativeDeposit,
                reserveNative,
                foreignDeposit,
                reserveForeign,
                totalLiquidityUnits
            );

        require(
            liquidity > 0,
            ""BasePoolV2::mint: Insufficient Liquidity Provided""
        );

        uint256 id = positionId++;

        pair.totalSupply = totalLiquidityUnits + liquidity;
        _mint(to, id);

        positions[id] = Position(
            foreignAsset,
            block.timestamp,
            liquidity,
            nativeDeposit,
            foreignDeposit
        );

        _update(
            foreignAsset,
            reserveNative + nativeDeposit,
            reserveForeign + foreignDeposit,
            reserveNative,
            reserveForeign
        );

        emit Mint(from, to, nativeDeposit, foreignDeposit);
        emit PositionOpened(from, to, id, liquidity);
    }"
16.md,Can set values to more than 100%,"There are several setter functions that do not check if the amount is less than 100% including:

- TracerPerpetualSwaps: setFeeRate, setDeleveragingCliff, setInsurancePoolSwitchStage
- Insurance: setFeeRate, setDeleveragingCliff, setInsurancePoolSwitchStage

The impact is that setting values to more than 100% might lead to unintended functionality.",low,Recommend ensuring that the parameters are less than 100%.,"function setFeeRate(uint256 _feeRate) external override onlyOwner {
        feeRate = _feeRate;
    }

function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {
        deleveragingCliff = _deleveragingCliff;
    }

function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {
        insurancePoolSwitchStage = _insurancePoolSwitchStage;
    }"
23.md,`NoteERC20.getPriorVotes` includes current unclaimed incentives,"The `NoteERC20.getPriorVotes` function is supposed to return the voting strength of an account at a specific block in the past. This should be a static value but it directly includes the current unclaimed incentives due to the `getUnclaimedVotes(account)` call. Users that didn't even have tokens at the time of proposal creation (but are now interested in voting on the proposal), can farm unclaimed incentives and impact the outcome of the proposal.",low,Adding checkpoints for all unclaimed incentives would be the correct solution but was probably not done because it'd cost too much gas. It also needs to be ensured that incentives cannot be increased through flash-loaning of assets.,"function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {
        require(blockNumber < block.number, ""Note::getPriorVotes: not yet determined"");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return _add96(
                checkpoints[account][nCheckpoints - 1].votes,
                getUnclaimedVotes(account),
                ""Note::getPriorVotes: uint96 overflow""
            );
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return
                    _add96(
                        cp.votes,
                        getUnclaimedVotes(account),
                        ""Note::getPriorVotes: uint96 overflow""
                    );
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }

        return
            _add96(
                checkpoints[account][lower].votes,
                getUnclaimedVotes(account),
                ""Note::getPriorVotes: uint96 overflow""
            );
    }"
20.md,Can't add BNB with `createPoolADD`,"The function `createPoolADD()` supports the input of BNB, which it detects by checking `token == address(0)`.
Later it calls `_handleTransferIn(token, ...);` with the original value of token, which can be 0.

However in the function `_handleTransferIn()` in poolFactory.sol there is no provision to transfer BNB (it doesn't check for _token == 0), so it will revert when you try to add BNB.

As a comparison, the function `_handleTransferIn()` of Router.sol does check for _token == address(0) and takes appropriate action.",low,Recommend applying the same function as `_handleTransferIn` of Router.sol to `_handleTransferIn` of poolFactory.sol. Better yet deduplicate the function by moving it to a library/included solidity file. Note:  There is also a  `_handleTransferIn` in Synth.sol which isn't used.,"function createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){
        require(getPool(token) == address(0)); // Must be a valid token
        require((inputToken > 0 && inputBase >= (10000*10**18)), ""!min""); // User must add at least 10,000 SPARTA liquidity & ratio must be finite
        Pool newPool; address _token = token;
        if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB
        require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18
        newPool = new Pool(BASE, _token); // Deploy new pool
        pool = address(newPool); // Get address of new pool
        mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory
        _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool
        _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool
        arrayPools.push(pool); // Add pool address to the pool array
        arrayTokens.push(_token); // Add token to the listed array
        isListedPool[pool] = true; // Record pool as currently listed
        Pool(pool).addForMember(msg.sender); // Perform the liquidity-add for the user
        emit CreatePool(token, pool);
        return pool;
    }

function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){
        if(_amount > 0) {
            uint startBal = iBEP20(_token).balanceOf(_pool); 
            iBEP20(_token).transferFrom(msg.sender, _pool, _amount); 
            actual = iBEP20(_token).balanceOf(_pool) - (startBal);
        }
    }"
105.md,Emergency mode enable/disable issue,"Enabling emergency mode should be one way process that sets contract(s) in emergency mode. It should be not possible to revert that process, otherwise it puts owner of the contract(s) in very privileged position. Owner can trigger emergency mode, perform emergency withdrawal operations without any restrictions and then disable emergency mode.",medium,It is recommended to remove `bool trigger` parameter from `triggerEmergencyWithdraw` function and set `emergency` to `true` after successfully executing function.,"function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }"
105.md,`PaladinRewardReserve.sol` may have potential bugs if it uses new tokens as rewards,"Currently, PaladinRewardReserve.sol has following behaviors:

*   mapping(address => bool) public approvedSpenders does not store the info regarding which token it targets
*   setNewSpender, updateSpenderAllowance, removeSpender and transferToken functions can set token arbitrarily

Hence, some corner cases may happen as follows:

*   Use TokenA at PaladinRewardReserve.sol and do operations.
*   Start TokenB as rewards at PaladinRewardReserve.sol.
*   All the information stored in approvedSpenders was intended for TokenA. So it is possible that following corner cases happen:
    *   setNewSpender function cannot set new token
    *   If userA is already added in approvedSpenders for TokenA, it can call updateSpenderAllowance.",medium,"Do either of followings depending on the product specification:

(1) If PAL token is only used and other token will never be used at PaladinRewardReserve.sol, stop having address token argument at setNewSpender, updateSpenderAllowance, removeSpender and transferToken functions. Instead, set token at the constructor or other ways, and limit the ability to flexibly set token from functions.

(2) If other tokens potentially will be used at PaladinRewardReserve.sol, update data structure of approvedSpenders mapping and change the logic.
Firstly, it should also contain the info which token it targets such as mapping(address => address => bool).
Secondly, it should rewrite the require logic at each function as follows.

    require(!approvedSpenders[spender][token], ""Already Spender on the specified Token"");

    require(approvedSpenders[spender][token], ""Not approved Spender on the specified Token"");","function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {
        require(!approvedSpenders[spender], ""Already Spender"");
        approvedSpenders[spender] = true;
        IERC20(token).safeApprove(spender, amount);

        emit NewSpender(token, spender, amount);
    }

function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);

        emit UpdateSpender(token, spender, amount);
    }

function removeSpender(address token, address spender) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        approvedSpenders[spender] = false;
        IERC20(token).safeApprove(spender, 0);

        emit RemovedSpender(token, spender);
    }

function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {
        IERC20(token).safeTransfer(receiver, amount);
    }"
3.md,Price feed can be manipulated,"Anyone can trigger an update to the price feed by calling `PriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true)`. If the update window has passed, the price will be computed by simulating a Uniswap-like trade with the amounts. This simulation uses the reserves of the Uniswap pairs which can be changed drastically using flash loans to yield almost arbitrary output amounts, and thus prices. Wrong prices break the core functionality of the contracts such as borrowing on margin, liquidations, etc.",high,Recommend against using the Uniswap spot price as the real price. Uniswap itself warns against this and instead recommends implementing a TWAP price oracle using the `price*CumulativeLast` variables.,"function getCurrentPriceInPeg(
        address token,
        uint256 inAmount,
        bool forceCurBlock
    ) public returns (uint256) {
        TokenPrice storage tokenPrice = tokenPrices[token];
        if (forceCurBlock) {
            if (
                block.number - tokenPrice.blockLastUpdated > priceUpdateWindow
            ) {
                // update the currently cached price
                return getPriceFromAMM(token, inAmount);
            } else {
                // just get the current price from AMM
                return viewCurrentPriceInPeg(token, inAmount);
            }
        } else if (tokenPrice.tokenPer1k == 0) {
            // do the best we can if it's at zero
            return getPriceFromAMM(token, inAmount);
        }

        if (block.number - tokenPrice.blockLastUpdated > priceUpdateWindow) {
            // update the price somewhat
            getPriceFromAMM(token, inAmount);
        }

        return (inAmount * 1000 ether) / tokenPrice.tokenPer1k;
    }"
70.md,`previousPrices` Is Never Updated Upon Syncing Token Price,"The `LiquidityBasedTWAP` contract attempts to accurately track the price of `VADER` and `USDV` while still being resistant to flash loan manipulation and short-term volatility. The `previousPrices` array is meant to track the last queried price for the two available paths, namely `VADER` and `USDV`.

The `setupVader` function configures the `VADER` token by setting `previousPrices` and adding a token pair. However, `syncVaderPrice` does not update `previousPrices` after syncing, causing `currentLiquidityEvaluation` to be dependent on the initial price for `VADER`. As a result, liquidity weightings do not accurately reflect the current and most up to date price for `VADER`.

This same issue also affects how `USDV` calculates `currentLiquidityEvaluation`.

This issue is of high risk and heavily impacts the accuracy of the TWAP implementation as the set price for `VADER/USDV` diverges from current market prices. For example, as the Chainlink oracle price and initial price for `VADER` diverge, `currentLiquidityEvaluation` will begin to favour either on-chain or off-chain price data depending on which price result is greater. The following calculation for `currentLiquidityEvaluation` outlines this behaviour.

    currentLiquidityEvaluation =
        (reserveNative * previousPrices[uint256(Paths.VADER)]) +
        (reserveForeign * getChainlinkPrice(pairData.foreignAsset));",high,Consider updating `previousPrices[uint256(Paths.VADER)]` and `previousPrices[uint256(Paths.USDV)]` after syncing the respective prices for the two tokens. This will ensure the most up to date price is used when evaluating liquidity for all available token pairs.,"function syncVaderPrice()
        public
        override
        returns (
            uint256[] memory pastLiquidityWeights,
            uint256 pastTotalLiquidityWeight
        )
    {
        uint256 _totalLiquidityWeight;
        uint256 totalPairs = vaderPairs.length;
        pastLiquidityWeights = new uint256[](totalPairs);
        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];

        for (uint256 i; i < totalPairs; ++i) {
            IUniswapV2Pair pair = vaderPairs[i];
            ExchangePair storage pairData = twapData[address(pair)];
            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;

            if (timeElapsed < pairData.updatePeriod) continue;

            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;
            uint256 currentLiquidityEvaluation = _updateVaderPrice(
                pair,
                pairData,
                timeElapsed
            );

            pastLiquidityWeights[i] = pastLiquidityEvaluation;

            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;

            _totalLiquidityWeight += currentLiquidityEvaluation;
        }

        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;
    }

function _updateVaderPrice(
        IUniswapV2Pair pair,
        ExchangePair storage pairData,
        uint256 timeElapsed
    ) internal returns (uint256 currentLiquidityEvaluation) {
        bool isFirst = pair.token0() == vader;

        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();

        (uint256 reserveNative, uint256 reserveForeign) = isFirst
            ? (reserve0, reserve1)
            : (reserve1, reserve0);

        (
            uint256 price0Cumulative,
            uint256 price1Cumulative,
            uint256 currentMeasurement
        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));

        uint256 nativeTokenPriceCumulative = isFirst
            ? price0Cumulative
            : price1Cumulative;

        unchecked {
            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(
                uint224(
                    (nativeTokenPriceCumulative -
                        pairData.nativeTokenPriceCumulative) / timeElapsed
                )
            );
        }

        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;

        pairData.lastMeasurement = currentMeasurement;

        currentLiquidityEvaluation =
            (reserveNative * previousPrices[uint256(Paths.VADER)]) +
            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));
    }

function setupVader(
        IUniswapV2Pair pair,
        IAggregatorV3 oracle,
        uint256 updatePeriod,
        uint256 vaderPrice
    ) external onlyOwner {
        require(
            previousPrices[uint256(Paths.VADER)] == 0,
            ""LBTWAP::setupVader: Already Initialized""
        );

        previousPrices[uint256(Paths.VADER)] = vaderPrice;

        _addVaderPair(pair, oracle, updatePeriod);
    }"
109.md,"`_execute` can potentially reorder a batch of commands while executing, breaking any assumptions on command orders.","Since this is important, we quote it again instead of referring to our other bug report on a different, yet related bug. The context within which a command is executed is extremely important.

> AxelarGatewayMultisig.execute() takes a signed batch of commands. Each command has a corresponding commandID. This is guaranteed to be unique from the Axelar network. execute intentionally allows retrying a commandID if the command failed to be processed; this is because commands are state dependent, and someone might submit command 2 before command 1 causing it to fail.

Thus if an attacker manages to rearrange execution order of commands within a batch, it should probably be treated seriously. This is exactly what might happen here due to reentrancy. A malicious player that managed to gain reentrancy over execute can easily execute later commands in a batch before earlier commands are fully executed, effectively breaking all assumptions on command executed context.

### Proof of Concept

The `_execute` function and its wrapper `execute` are both reentrant.

        function execute(bytes calldata input) external override;
        function _execute(bytes memory data, bytes[] memory signatures) internal;

Thus if an attacker manages to reenter the `_execute` function with the same batch of commands and signatures, previously successfully executed and ongoing commands will be skipped due to premature marking of the success flag.

            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */

This allows later commands to be executed before the current ongoing command is finished. The reentrant attack can be nested to perform further reordering of commands.

Generally speaking, other unrelated batches of signed commands can only be executed, but since the assumption of ordering is most likely stronger within a single batch, we focus on illustrating the single batch scenario above.",medium,"Make execute nonReentrant

Add an ever increasing nonce to signatures to prevent replay

        function execute(bytes calldata input) nonReentrant external override {
            ...
        }","function execute(bytes calldata input) external override {
        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));

        _execute(data, signatures);
    }

function _execute(bytes memory data, bytes[] memory signatures) internal {
        uint256 signatureCount = signatures.length;

        address[] memory signers = new address[](signatureCount);

        for (uint256 i; i < signatureCount; i++) {
            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);
        }

        (
            uint256 chainId,
            Role signersRole,
            bytes32[] memory commandIds,
            string[] memory commands,
            bytes[] memory params
        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));

        if (chainId != block.chainid) revert InvalidChainId();

        if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();

        uint256 commandsLength = commandIds.length;

        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();

        bool areValidCurrentOwners;
        bool areValidRecentOwners;
        bool areValidRecentOperators;

        if (signersRole == Role.Owner) {
            areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);
            areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);
        } else if (signersRole == Role.Operator) {
            areValidRecentOperators = _areValidRecentOperators(signers);
        }

        for (uint256 i; i < commandsLength; i++) {
            bytes32 commandId = commandIds[i];

            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */

            bytes4 commandSelector;
            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));

            if (commandHash == SELECTOR_DEPLOY_TOKEN) {
                if (!areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.deployToken.selector;
            } else if (commandHash == SELECTOR_MINT_TOKEN) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.mintToken.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;
            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;
            } else if (commandHash == SELECTOR_BURN_TOKEN) {
                if (!areValidRecentOperators && !areValidRecentOwners) continue;

                commandSelector = AxelarGatewayMultisig.burnToken.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;
            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {
                if (!areValidCurrentOwners) continue;

                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;
            } else {
                continue; /* Ignore if unknown command received */
            }

            // Prevent a re-entrancy from executing this command before it can be marked as successful.
            _setCommandExecuted(commandId, true);
            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));
            _setCommandExecuted(commandId, success);

            if (success) {
                emit Executed(commandId);
            }
        }
    }"
23.md,DAO proposals can be executed by anyone due to vulnerable `TimelockController`,"The `GovernorAlpha` inherits from a vulnerable `TimelockController`. This `TimelockController` allows an `EXECUTOR` role to escalate privileges and also gain the proposer role. The bug is that `_executeBatch` checks if the proposal was scheduled only **after** the transactions have been executed. This allows inserting a call into the batch that schedules the batch itself, and the entire batch will succeed. As the custom `GovernorAlpha.executeProposal` function removed the original ""queued state check"" (`require(state(proposalId) == ProposalState.Queued`), the attack can be executed by anyone, even without the `EXEUCTOR_ROLE`.

Proof of concept:
1. Create a proposal using `propose`. The `calldata` will be explained in the next step. (This can be done by anyone passing the min `proposalThreshold`)
2. Call `executeProposal(proposalId, ...)` such that the following calls are made:

call-0: grantRole(TIME_LOCK_ADMIN, attackerContract)
call-1: grantRole(EXECUTOR, attackerContract)
call-2: grantRole(PROPOSER, attackerContract)
call-3: updateDelay(0) // such that _afterCall ""isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) <= block.timestamp"" passes
call-4: attackerContract.hello() // this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function's args and we may not be self-referential)
// attackerContract is proposer & executor now and can directly call scheduleBatch & executeBatch without having to create a proposal

The impact is that, anyone who can create a proposal can become `Timelock` admin (proposer & executor) and execute arbitrary transactions as the DAO-controlled `GovernorAlpha`. Note that this contract has severe privileges and an attacker can now do anything that previously required approval of the DAO. For example, they could update the `globalTransferOperator` and steal all tokens.",high,Recommend updating the vulnerable contract to `TimelockController v3.4.2` as it currently uses `OpenZeppelin/openzeppelin-contracts@3.4.0-solc-0.7`.,"function executeProposal(
        uint256 proposalId,
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata calldatas
    ) external payable {
        Proposal storage proposal = proposals[proposalId];
        proposal.executed = true;

        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);
        require(computedOperationHash == proposal.operationHash, ""Operation hash mismatch"");
        // Execute batch will revert if the call has not been scheduled
        _executeBatch(targets, values, calldatas, proposalId);

        emit ProposalExecuted(proposalId);
    }

function _executeBatch(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata calldatas,
        uint256 proposalId
    ) private {
        this.executeBatch(targets, values, calldatas, bytes32(0), bytes32(proposalId));
    }"
14.md,`ATokenYieldSource` mixes aTokens and underlying when redeeming,"The `ATokenYieldSource.redeemToken` function burns `aTokens` and sends out underlying; however, it's used in a reverse way in the code: The `balanceDiff` is used as the `depositToken` that is transferred out but it's computed on the **aTokens** that were burned instead of on the `depositToken` received. It should not directly lead to issues as aTokens are 1-to-1 with their underlying but we still recommend doing it correctly to make the code more robust against any possible rounding issues.",low,"Recommend computing `balanceDiff` on the underyling balance (`depositToken`), not on the aToken. Then, subtract the actual burned aTokens from the user shares.","function redeemToken(uint256 redeemAmount) external override nonReentrant returns (uint256) {
    uint256 shares = _tokenToShares(redeemAmount);
    _burn(msg.sender, shares);

    uint256 beforeBalance = aToken.balanceOf(address(this));
    _lendingPool().withdraw(address(_tokenAddress()), redeemAmount, address(this));
    uint256 afterBalance = aToken.balanceOf(address(this));

    uint256 balanceDiff = beforeBalance.sub(afterBalance);
    IERC20Upgradeable(depositToken()).safeTransfer(msg.sender, balanceDiff);

    emit RedeemedToken(msg.sender, shares, redeemAmount);
    return balanceDiff;
  }"
42.md,Improper Validation Of `create2` Return Value,The `BeaconProxyDeployer.deploy()` function is used to deploy lightweight proxy contracts that act as each asset's vault. The function does not revert properly if there is a failed contract deployment or revert from the `create2` opcode as it does not properly check the returned address for bytecode. The `create2` opcode returns the expected address which will never be the zero address (as is what is currently checked).,medium,"The recommended mitigation was to update `iszero(result)` to `iszero(extcodesize(result))` in the line mentioned above. This change has already been made in the corresponding library, however, this needs to also be reflected in Mochi's contracts.","function deploy(address beacon, bytes memory initializationCalldata)
        internal
        returns (address result)
    {
        bytes memory createCode =
            abi.encodePacked(
                type(Create2BeaconMaker).creationCode,
                abi.encode(address(beacon), initializationCalldata)
            );
        bytes32 salt = bytes32(0);

        // solhint-disable-next-line no-inline-assembly
        assembly {
            let encoded_data := add(0x20, createCode) // load initialization code.
            let encoded_size := mload(createCode) // load the init code's length.
            result := create2(
                // call `CREATE2` w/ 4 arguments.
                0, // forward any supplied endowment.
                encoded_data, // pass in initialization code.
                encoded_size, // pass in init code's length.
                salt // pass in the salt value.
            )

            // pass along failure message from failed contract deployment and revert.
            if iszero(result) {
                returndatacopy(0, 0, returndatasize())
                revert(0, returndatasize())
            }
        }
    }"
145.md,`ERC1155Fuse`: `_transfer` does not revert when sent to the old owner,"The `safeTransferFrom` does not comply with the ERC1155 standard when the token is sent to the old owner.

According to the EIP-1155 standard for the `safeTransferFrom`:

> MUST revert if balance of holder for token `_id` is lower than the `_value` sent.

Let's say `alice` does not hold any token of `tokenId`, and `bob` holds one token of `tokenId`. Then alice tries to send one token of `tokenId` to bob with `safeTranferFrom(alice, bob, tokenId, 1, """")`.  In this case, even though alice's balance (= 0) is lower than the amount (= 1) sent, the `safeTransferFrom` will not revert. Thus, violating the EIP-1155 standard.
It can cause problems for other contracts using this token, since they assume the token was transferred if the `safeTransferFrom` does not revert. However, in the example above, no token was actually transferred.",medium,Revert even if the `to` address already owns the token.,"function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(to != address(0), ""ERC1155: transfer to the zero address"");
        require(
            from == msg.sender || isApprovedForAll(from, msg.sender),
            ""ERC1155: caller is not owner nor approved""
        );

        _transfer(from, to, id, amount, data);
    }

function _transfer(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal {
        (address oldOwner, uint32 fuses, uint64 expiry) = getData(id);
        if (oldOwner == to) {
            return;
        }

        if (!_canTransfer(fuses)) {
            revert OperationProhibited(bytes32(id));
        }

        require(
            amount == 1 && oldOwner == from,
            ""ERC1155: insufficient balance for transfer""
        );
        _setData(id, to, fuses, expiry);

        emit TransferSingle(msg.sender, from, to, id, amount);

        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);
    }"
145.md,`BytesUtils`: compare will not revert when the `offset` and `len` exceeds the bytes lengths,"Compare will return false answer without reverting when the inputs are not valid.

The `compare` function is used for `compareNames`. The names are supposed to be DNS wire format. If the strings are malformed, it is possible to give out-of-range `offset`, `len`, `otheroffset`, and `otherlen`. When it happens, the `compare` will return some false values, without reverting, since the validity of `offset` and `len` are not checked.

// dnssec-oracle/BytesUtils.sol::compare
// The length of self and other are not enforced",medium,"Check whether the `offset`, `len` are within the length of `self`, as well as for the `other`.","function compare(bytes memory self, bytes memory other) internal pure returns (int) {
        return compare(self, 0, self.length, other, 0, other.length);
    }

function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {
        uint shortest = len;
        if (otherlen < len)
        shortest = otherlen;

        uint selfptr;
        uint otherptr;

        assembly {
            selfptr := add(self, add(offset, 32))
            otherptr := add(other, add(otheroffset, 32))
        }
        for (uint idx = 0; idx < shortest; idx += 32) {
            uint a;
            uint b;
            assembly {
                a := mload(selfptr)
                b := mload(otherptr)
            }
            if (a != b) {
                // Mask out irrelevant bytes and check again
                uint mask;
                if (shortest > 32) {
                    mask = type(uint256).max;
                } else {
                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);
                }
                int diff = int(a & mask) - int(b & mask);
                if (diff != 0)
                return diff;
            }
            selfptr += 32;
            otherptr += 32;
        }

        return int(len) - int(otherlen);
    }"
14.md,`BadgerYieldSource` `balanceOfToken` share calculation seems wrong,"When suppling to the `BadgerYieldSource`, some `amount` of `badger` is deposited to `badgerSett` and one receives `badgerSett` share tokens in return which are stored in the `balances` mapping of the user. So far this is correct.

The `balanceOfToken` function should then return the redeemable balance in `badger` for the user's `badgerSett` balance.
It computes it as the pro-rata share of the user balance (compared to the total-supply of `badgerSett`) on the `badger` in the vault:

```solidity
balances[addr].mul(
  badger.balanceOf(address(badgerSett))
).div(
  badgerSett.totalSupply()
)
```

However, `badger.balanceOf(address(badgerSett))` is only a small amount of badger that is deployed in the vault (""Sett"") due to most of the capital being deployed to the _strategies_. Therefore, it under-reports the actual balance:

> Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. Badger Docs

Any contract or user calling the `balanceOf` function will receive a value that is far lower than the actual balance.
Using this value as a basis for computations will lead to further errors in the integrations.",high,"Recommend using `badgerSett.balance()` instead of `badger.balanceOf(address(badgerSett))` to also account for ""the balance in the Sett, the Controller, and the Strategy"".","function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }"
83.md,Repeated Calls to Shelter.withdraw Can Drain All Funds in Shelter,"Anyone who can call `withdraw` to withdraw their own funds can call it repeatedly to withdraw the funds of others. `withdraw` should only succeed if the user hasn't withdrawn the token already.

The shelter can be used for users to withdraw funds in the event of an emergency. The `withdraw` function allows callers to withdraw tokens based on the tokens they have deposited into the shelter client: ConvexStakingWrapper. However, `withdraw` does not check if a user has already withdrawn their tokens. Thus a user that can `withdraw` tokens, can call withdraw repeatedly to steal the tokens of others.

Proof of Concept

An attacker that can successfully call `withdraw` once on a shelter, can call it repeatedly to steal the funds of others. Below is a detailed scenario where this situation can be exploited.

1.  Mallory deposits 1 `wETH` into `ConvexStakingWrapper` using `deposit`. Let's also assume that other users have deposited 2 `wETH` into the same contract.
2.  An emergency happens and the owner of `ConvexStakingWrapper` calls `setShelter(shelter)` and `enterShelter([pidOfWETHToken, ...])`. Now `shelter` has 3 `wETH` and is activated for `wETH`.
3.  Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)`, Mallory will rightfully receive 1 wETH because her share of wETH in the shelter is 1/3.
4.  Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)` again, receiving 1/3*2 = 2/3 wETH. `withdraw` does not check that she has already withdrawn. This time, the wETH does not belong to her, she has stolen the wETH of the other users. She can continue calling `withdraw` to steal the rest of the funds.",high,"To mitigate this, `withdraw` must first check that `msg.sender` has not withdrawn this token before and `withdraw` must also record that `msg.sender` has withdrawn the token.
The exact steps for this are below:

1.  Add the following line to the beginning of `withdraw` (line 53):

    require(!claimed[_token][msg.sender], ""already claimed"")

2.  Replace line 55 with the following:

    claimed[_token][msg.sender] = true;

This replacement is necessary because we want to record who is withdrawing, not where they are sending the token which isn't really useful info.","function withdraw(IERC20 _token, address _to) external override {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, ""shelter not activated"");
        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);
        claimed[_token][_to] = true;
        emit ExitShelter(_token, msg.sender, _to, amount);
        _token.safeTransfer(_to, amount);
    }"
7.md,uint[] memory parameter is tricky,"Using memory array parameters (e.g. uint[] memory) as function parameters can be tricky in Solidity, because an attack is possible with a very large array which will overlap with other parts of the memory. The function `propose` of GovernorAlpha.sol seems most vulnerable because this function does not check the validity of the array lengths. Most other functions do a loop over the array, which will fail with a large array (due to out of gas).

This an example to show the exploit:

```solidity
// based on a known exploit from a Solidity CTF

pragma solidity ^0.4.24; // only works with low solidity version

contract test{
    struct Overlap {
        uint field0;
    }
    event log(uint);

  function mint(uint[] memory amounts) public  returns (uint) {   // this can be in any solidity version
       Overlap memory v;
       v.field0 = 1234;
       emit log(amounts[0]); // would expect to be 0 however is 1234
       return 1;
     }

  function go() public { // this part requires the low solidity version
      uint x=0x800000000000000000000000000000000000000000000000000000000000000; // 2^251
      bytes memory payload = abi.encodeWithSelector(this.mint.selector, 0x20, x);
      bool success=address(this).call(payload);
  }
}
```",low,Recommend adding checks on the size of the array parameters to make sure they are not absurdly long.,"function addTokens(TokenConfig[] memory configs) public onlyOwner {
        for (uint i = 0; i < configs.length; i++) {
            TokenConfig memory config = configs[i];
            bytes32 symbolHash = config.symbolHash;
            require(config.baseUnit > 0, ""baseUnit must be greater than zero"");
            require(newObservations[symbolHash].timestamp == uint(0), ""cannot change current token"");
            address uniswapMarket = config.uniswapMarket;
            if (config.priceSource == PriceSource.REPORTER) {
                require(uniswapMarket != address(0), ""reported prices must have an anchor"");
                uint cumulativePrice = currentCumulativePrice(config);
                oldObservations[symbolHash].timestamp = block.timestamp;
                newObservations[symbolHash].timestamp = block.timestamp;
                oldObservations[symbolHash].acc = cumulativePrice;
                newObservations[symbolHash].acc = cumulativePrice;
                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);
            } else {
                require(uniswapMarket == address(0), ""only reported prices utilize an anchor"");
            }
        }

        _addTokensInternal(configs);
    }function enterMarkets(address[] memory cTokens) public override returns (uint[] memory) {
        uint len = cTokens.length;

        uint[] memory results = new uint[](len);
        for (uint i = 0; i < len; i++) {
            CToken cToken = CToken(cTokens[i]);

            results[i] = uint(addToMarketInternal(cToken, msg.sender));
        }

        return results;
    }

function claimComp(address holder) public {
        return claimComp(holder, allMarkets);
    }

function claimComp(address holder, CToken[] memory cTokens) public {
        address[] memory holders = new address[](1);
        holders[0] = holder;
        claimComp(holders, cTokens, true, true);
    }

function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {
        for (uint i = 0; i < cTokens.length; i++) {
            CToken cToken = cTokens[i];
            require(markets[address(cToken)].isListed, ""market must be listed"");
            if (borrowers == true) {
                Exp memory borrowIndex = Exp({mantissa: cToken.borrowIndex()});
                updateCompBorrowIndex(address(cToken), borrowIndex);
                for (uint j = 0; j < holders.length; j++) {
                    distributeBorrowerComp(address(cToken), holders[j], borrowIndex, true);
                }
            }
            if (suppliers == true) {
                updateCompSupplyIndex(address(cToken));
                for (uint j = 0; j < holders.length; j++) {
                    distributeSupplierComp(address(cToken), holders[j], true);
                }
            }
        }
    }

function _addCompMarkets(address[] memory cTokens) public {
        require(adminOrInitializing(), ""not an admin"");

        for (uint i = 0; i < cTokens.length; i++) {
            _addCompMarketInternal(cTokens[i]);
        }

        refreshCompSpeedsInternal();
    }function _addTokensInternal(TokenConfig[] memory configs) internal {
        for (uint i = 0; i < configs.length; i++) {
            uint index = i + numTokens;
            tokens[index] = configs[i];
            cTokenIndex[configs[i].cToken] = index;
            underlyingIndex[configs[i].underlying] = index;
            symbolHashIndex[configs[i].symbolHash] = index;
        }

        numTokens = numTokens + configs.length;
    }function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {
        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), ""GovernorAlpha::propose: proposer votes below proposal threshold"");
        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, ""GovernorAlpha::propose: proposal function information arity mismatch"");
        require(targets.length != 0, ""GovernorAlpha::propose: must provide actions"");
        require(targets.length <= proposalMaxOperations(), ""GovernorAlpha::propose: too many actions"");

        uint latestProposalId = latestProposalIds[msg.sender];
        if (latestProposalId != 0) {
          ProposalState proposersLatestProposalState = state(latestProposalId);
          require(proposersLatestProposalState != ProposalState.Active, ""GovernorAlpha::propose: one live proposal per proposer, found an already active proposal"");
          require(proposersLatestProposalState != ProposalState.Pending, ""GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal"");
        }

        uint startBlock = add256(block.number, votingDelay());
        uint endBlock = add256(startBlock, votingPeriod());

        proposalCount++;
        Proposal memory newProposal = Proposal({
            id: proposalCount,
            proposer: msg.sender,
            eta: 0,
            targets: targets,
            values: values,
            signatures: signatures,
            calldatas: calldatas,
            startBlock: startBlock,
            endBlock: endBlock,
            forVotes: 0,
            againstVotes: 0,
            canceled: false,
            executed: false
        });

        proposals[newProposal.id] = newProposal;
        latestProposalIds[newProposal.proposer] = newProposal.id;

        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);
        return newProposal.id;
    }"
83.md,"`StakingRewards.setRewardsDuration` allows setting near zero or enormous `rewardsDuration`, which breaks reward logic","notifyRewardAmount will be inoperable if rewardsDuration is set to zero. It will cease to produce meaningful results if rewardsDuration is too small or too big.

Proof of Concept

The setter does not control the value, allowing zero/near zero/enormous duration:

Division by the duration is used in notifyRewardAmount.",medium,"Check for min and max range in the rewardsDuration setter, as too small or too big rewardsDuration breaks the logic.","function notifyRewardAmount(uint256 reward)
        external
        updateReward(address(0))
    {
        require(
            msg.sender == rewardsDistribution,
            ""Caller is not RewardsDistribution contract""
        );

        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - block.timestamp;
            uint256 leftover = remaining * rewardRate;
            rewardRate = (reward + leftover) / rewardsDuration;
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint256 balance = rewardsToken.balanceOf(address(this));
        require(
            rewardRate <= balance / rewardsDuration,
            ""Provided reward too high""
        );

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp + rewardsDuration;
        emit RewardAdded(reward);
    }"
28.md,"Last person to withdraw his tokens might not be able to do this, in Crowdsale (edge case)","Suppose a Crowdsale is successful and enough commitments are made before the marketInfo.endTime.
Suppose marketStatus.commitmentsTotal  == marketInfo.totalTokens -1      // note this is an edge case, but can be constructed by an attacker
Then the function auctionEnded() returns true
Assume auctionSuccessful() is also true (might depend on the config of marketPrice.goal and marketInfo.totalTokens)
Then an admin can call finalize() to finalize the Crowdsale.
The function finalize distributes the funds and the unsold tokens and sets status.finalized = true so that finalized cannot be called again.
Now we have ""marketInfo.totalTokens -1"" tokens left in the contract

However commitEth() or commitTokens() can still be called (they give no error message that the auction has ended)
Then functions call calculateCommitment, which luckily prevent from buying too much, however 1 token can still be bought
These functions also call _addCommitment(), which only checks for marketInfo.endTime, which hasn't passed yet.

Now an extra token is sold and the contract has 1 token short. So the last person to withdraw his tokens cannot withdraw them (because you cannot specify how much you want to withdraw)

Also the revenues for the last token cannot be retrieved as finalize() cannot be called again.",high,"In the function _addCommitment, add a check on auctionEnded() or status.finalized","function commitEth(
        address payable _beneficiary,
        bool readAndAgreedToMarketParticipationAgreement
    ) 
        public payable   nonReentrant    
    {
        require(paymentCurrency == ETH_ADDRESS, ""Crowdsale: Payment currency is not ETH""); 
        if(readAndAgreedToMarketParticipationAgreement == false) {
            revertBecauseUserDidNotProvideAgreement();
        }

        /// @dev Get ETH able to be committed.
        uint256 ethToTransfer = calculateCommitment(msg.value);

        /// @dev Accept ETH Payments.
        uint256 ethToRefund = msg.value.sub(ethToTransfer);
        if (ethToTransfer > 0) {
            _addCommitment(_beneficiary, ethToTransfer);
        }

        /// @dev Return any ETH to be refunded.
        if (ethToRefund > 0) {
            _beneficiary.transfer(ethToRefund);
        }

        /// @notice Revert if commitmentsTotal exceeds the balance
        require(marketStatus.commitmentsTotal <= address(this).balance, ""DutchAuction: The committed ETH exceeds the balance"");
    }

function calculateCommitment(uint256 _commitment)
        public
        view
        returns (uint256 committed)
    {
        uint256 tokens = _getTokenAmount(_commitment);
        uint256 tokensCommited =_getTokenAmount(uint256(marketStatus.commitmentsTotal));
        if ( tokensCommited.add(tokens) > uint256(marketInfo.totalTokens)) {
            return _getTokenPrice(uint256(marketInfo.totalTokens).sub(tokensCommited));
        }
        return _commitment;
    }

function _addCommitment(address _addr, uint256 _commitment) internal {
        require(block.timestamp >= uint256(marketInfo.startTime) && block.timestamp <= uint256(marketInfo.endTime), ""Crowdsale: outside auction hours"");
        require(_addr != address(0), ""Crowdsale: beneficiary is the zero address"");

        uint256 newCommitment = commitments[_addr].add(_commitment);
        if (marketStatus.usePointList) {
            require(IPointList(pointList).hasPoints(_addr, newCommitment));
        }

        commitments[_addr] = newCommitment;

        /// @dev Update state.
        marketStatus.commitmentsTotal = BoringMath.to128(uint256(marketStatus.commitmentsTotal).add(_commitment));

        emit AddedCommitment(_addr, _commitment);
    }

function withdrawTokens() public  {
        withdrawTokens(msg.sender);
    }

function withdrawTokens(address payable beneficiary) public   nonReentrant  {    
        if (auctionSuccessful()) {
            require(marketStatus.finalized, ""Crowdsale: not finalized"");
            /// @dev Successful auction! Transfer claimed tokens.
            uint256 tokensToClaim = tokensClaimable(beneficiary);
            require(tokensToClaim > 0, ""Crowdsale: no tokens to claim""); 
            claimed[beneficiary] = claimed[beneficiary].add(tokensToClaim);
            _safeTokenPayment(auctionToken, beneficiary, tokensToClaim);
        } else {
            /// @dev Auction did not meet reserve price.
            /// @dev Return committed funds back to user.
            require(block.timestamp > uint256(marketInfo.endTime), ""Crowdsale: auction has not finished yet"");
            uint256 accountBalance = commitments[beneficiary];
            commitments[beneficiary] = 0; // Stop multiple withdrawals and free some gas
            _safeTokenPayment(paymentCurrency, beneficiary, accountBalance);
        }
    }

function finalize() public nonReentrant {
        require(            
            hasAdminRole(msg.sender) 
            || wallet == msg.sender
            || hasSmartContractRole(msg.sender) 
            || finalizeTimeExpired(),
            ""Crowdsale: sender must be an admin""
        );
        MarketStatus storage status = marketStatus;
        require(!status.finalized, ""Crowdsale: already finalized"");
        MarketInfo storage info = marketInfo;
        require(auctionEnded(), ""Crowdsale: Has not finished yet""); 

        if (auctionSuccessful()) {
            /// @dev Successful auction
            /// @dev Transfer contributed tokens to wallet.
            _safeTokenPayment(paymentCurrency, wallet, uint256(status.commitmentsTotal));
            /// @dev Transfer unsold tokens to wallet.
            uint256 soldTokens = _getTokenAmount(uint256(status.commitmentsTotal));
            uint256 unsoldTokens = uint256(info.totalTokens).sub(soldTokens);
            if(unsoldTokens > 0) {
                _safeTokenPayment(auctionToken, wallet, unsoldTokens);
            }
        } else {
            /// @dev Failed auction
            /// @dev Return auction tokens back to wallet.
            _safeTokenPayment(auctionToken, wallet, uint256(info.totalTokens));
        }

        status.finalized = true;

        emit AuctionFinalized();
    }

function auctionSuccessful() public view returns (bool) {
        return uint256(marketStatus.commitmentsTotal) >= uint256(marketPrice.goal);
    }

function auctionEnded() public view returns (bool) {
        return block.timestamp > uint256(marketInfo.endTime) || 
        _getTokenAmount(uint256(marketStatus.commitmentsTotal) + 1) >= uint256(marketInfo.totalTokens);
    }"
29.md,absolute difference is not calculated properly when a > b in MathUtils,"the difference is computed incorrectly when a > b. As it only used in within1 function, scope narrows down to where difference(a, b) <= 1; is exploitable.

cases where difference(a, b) <= 1 should be true but is reported false:

*   where b = a-1 (returned value is type(uint256).max)

cases where difference(a, b) <= 1 should be false but is reported true:

*   where a = type(uint256).max and b = 0, it returns 1 but it should ideally return type(uint256).max

within1 is used at the following locations:
*   HybridPool.sol L359
*   HybridPool.sol L383
*   HybridPool.sol L413

It is possible to decrease the denominator and increase the value of the numerator (when calculating y) using constants and input to make within1 fail",high,"Add else condition to mitigate it.

unchecked {
    if (a > b) {
        diff = a - b;
    }
    else {
        diff = b - a;
    }
}","function within1(uint256 a, uint256 b) internal pure returns (bool wn) {
        wn = difference(a, b) <= 1;
    }

function difference(uint256 a, uint256 b) internal pure returns (uint256 diff) {
        unchecked {
            if (a > b) {
                diff = a - b;
            }
            diff = b - a;
        }
    }"
74.md,Manipulation of the Y State Results in Interest Rate Manipulation,"Due to lack of constraints on user input in the `TimeswapPair.sol#mint` function, an attacker can arbitrarily modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token.

#### Proof of Concept

The attack scenario is this: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.

First, the LP deploys their pool and contributes their desired amount of tokens. With the provided configuration, the interest rate to borrow on this pool is calculated to be between 1% to 15%.

Then, the attacker deploys a contract and calls the mint function with manipulated parameters:

```solidity
uint112 xIncrease = 3;
uint112 yIncrease = 1000000000000000;
uint112 zIncrease = 5; //Static 167% CDP
```

The attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. However, after the attacker's malicious mint, the interest rate becomes:

```
yMax: 0.0002047533146923118
Min Interest Rate: 0.40383657499999975
Max Interest Rate: 6.461385199999996
zMax: 1666.6666666666667
```

This results in the interest rate jumping to between 40% and 646%, effectively destroying the pool.",high,"Add proper input validation and constraints in the `mint` function of TimeswapPair.sol to prevent users from arbitrarily setting parameters that can drastically alter the interest rate or other critical pool variables. Ensure that the function checks for reasonable and safe ranges for all user-supplied values, especially those that impact the pool's financial parameters.","function mint(
        uint256 maturity,
        address liquidityTo,
        address dueTo,
        uint112 xIncrease,
        uint112 yIncrease,
        uint112 zIncrease,
        bytes calldata data
    )
        external
        override
        lock
        returns (
            uint256 liquidityOut,
            uint256 id,
            Due memory dueOut
        )
    {
        require(block.timestamp < maturity, 'E202');
        require(maturity - block.timestamp < 0x100000000, 'E208');
        require(liquidityTo != address(0) && dueTo != address(0), 'E201');
        require(liquidityTo != address(this) && dueTo != address(this), 'E204');
        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205');
        
        Pool storage pool = pools[maturity];

        if (pool.state.totalLiquidity == 0) {
            uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);
            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);

            pool.state.totalLiquidity += liquidityTotal;
            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;
        } else {
            uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);
            liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);

            pool.state.totalLiquidity += liquidityTotal;
            pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut;
        }
        require(liquidityOut > 0, 'E212');
        pool.liquidities[liquidityTo] += liquidityOut;

        dueOut.debt = MintMath.getDebt(maturity, xIncrease, yIncrease);
        dueOut.collateral = MintMath.getCollateral(maturity, zIncrease);
        dueOut.startBlock = BlockNumber.get();

        Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data);

        id = pool.dues[dueTo].insert(dueOut);

        pool.state.reserves.asset += xIncrease;
        pool.state.reserves.collateral += dueOut.collateral;
        pool.state.totalDebtCreated += dueOut.debt;

        pool.state.x += xIncrease;
        pool.state.y += yIncrease;
        pool.state.z += zIncrease;

        emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Mint(maturity, msg.sender, liquidityTo, dueTo, xIncrease, liquidityOut, id, dueOut);
    }"
59.md,_notSameBlock() can be circumvented in bondToAccount(),"The function bondToAccount() of Bonding.sol has a check based on _notSameBlock(). _notSameBlock() makes sure the same msg.sender cannot do 2 actions within the same block. However this can be circumvented in this case: Suppose you call bondToAccount() via a (custom) smart contract, then the msg.sender will be the address of the smart contract. For a pseudo code proof of concept see below.

Proof of Concept

call function attack1.attack()

contract attack1 {
   function attack(address account, uint256 amount) {
         call attack2.forward(account, amount);
         call any other function of malt
  }
}

contract attack2 {
   function forward(address account, uint256 amount) {
       call bonding.bondToAccount(account, amount); // uses msg.sender of attack2
   }
}

function bondToAccount(address account, uint256 amount) public {
    if (msg.sender != offering) {
         _notSameBlock();
    }
    ...

function _notSameBlock() internal {
    require( block.number > lastBlock[_msgSender()],""Can't carry out actions in the same block"" );
    lastBlock[_msgSender()] = block.number;
  }

I'm not sure what the deeper reason is for the _notSameBlock() in bondToAccount(). But if it is important then circumventing this check it will pose a risk.",medium,Add access controls to the function bondToAccount(). An end-user could still call bond().,"function bondToAccount(address account, uint256 amount)
    public
  {
    if (msg.sender != offering) {
      _notSameBlock();
    }
    require(amount > 0, ""Cannot bond 0"");

    miningService.onBond(account, amount);

    _bond(account, amount);
  }"
14.md,Missing calls to `init` functions of inherited contracts,"Most contracts use the `delegateCall` proxy pattern and hence their implementations require the use of `initialize()` functions instead of constructors. This requires derived contracts to call the corresponding `init` functions of their inherited base contracts. This is done in most places except a few.

The inherited base classes do not get initialized which may lead to undefined behavior.
- Missing call to `__ReentrancyGuard_init` in `ATokenYieldSource.sol` (lines 99-102) and (lines 59-61 in IdleYieldSource.sol)
- Missing call to `__ERC20_init` in `ATokenYieldSource.sol` (lines 59-61 in IdleYieldSource.sol) and (lines 83-86 in YearnV2YieldSource.sol)",low,Recommend adding missing calls to init functions of inherited contracts.,"function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }function initialize(
    ATokenInterface _aToken,
    ILendingPoolAddressesProviderRegistry _lendingPoolAddressesProviderRegistry,
    uint8 _decimals,
    string calldata _symbol,
    string calldata _name,
    address _owner
  )
    public
    initializer
    returns (bool)
  {
    aToken = _aToken;
    lendingPoolAddressesProviderRegistry = _lendingPoolAddressesProviderRegistry;

    __Ownable_init();
    transferOwnership(_owner);

    __ERC20_init(_name,_symbol);
    require(_decimals > 0, ""ATokenYieldSource/decimals-gt-zero"");
    _setupDecimals(_decimals);

    emit ATokenYieldSourceInitialized (
      _aToken,
      _lendingPoolAddressesProviderRegistry,
      _decimals,
      _name,
      _symbol,
      _owner
    );

    return true;
  }function initialize(
        IYVaultV2 _vault,
        IERC20Upgradeable _token
    ) 
        public 
        initializer
    {
        require(address(vault) == address(0), ""YearnV2YieldSource:: already initialized"");
        require(_vault.token() == address(_token), ""YearnV2YieldSource:: incorrect vault"");
        require(_vault.activation() != uint256(0), ""YearnV2YieldSource:: vault not initialized"");
        // NOTE: Vaults from 0.3.2 to 0.3.4 have dips in shareValue
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.2""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.3""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.4""), ""YearnV2YieldSource:: vault not compatible"");

        vault = _vault;
        token = _token;

        __Ownable_init();
        __ReentrancyGuard_init();

        _token.safeApprove(address(vault), type(uint256).max);

        emit YieldSourceYearnV2Initialized(
            _vault,
            _token
        );
    }"
21.md,Possible divide-by-zero error in `PoolBase`,"A possible divide-by-zero error could happen in the `getSherXPerBlock(uint256, IERC20)` function of `PoolBase` when the `totalSupply` of `lockToken` and `_lock` are both 0.",low,"Check if `baseData().lockToken.totalSupply().add(_lock)` equals to 0 before line 214. If so, then return 0.","function getSherXPerBlock(IERC20 _token) external view override returns (uint256) {
    return getSherXPerBlock(msg.sender, _token);
  }

function getSherXPerBlock(address _user, IERC20 _token) public view override returns (uint256) {
    PoolStorage.Base storage ps = baseData();
    if (ps.lockToken.totalSupply() == 0) {
      return 0;
    }
    return
      getTotalSherXPerBlock(_token).mul(ps.lockToken.balanceOf(_user)).div(
        ps.lockToken.totalSupply()
      );
  }

function getSherXPerBlock(uint256 _lock, IERC20 _token) external view override returns (uint256) {
    // simulates staking (adding lock)
    return
      getTotalSherXPerBlock(_token).mul(_lock).div(baseData().lockToken.totalSupply().add(_lock));
  }"
131.md,There are multiple ways for admins/governance to rug users,"A malicious admin can steal user funds or lock their balances forever.

Even if the user is benevolent the fact that there is a rug vector available may negatively impact the protocol's reputation.

Unlike the original Convex code that goes to great lengths to prevent users having the ability to transfer funds/mint things, this project introduces multiple roles and new abilities that require users to place more trust in governance:

1.  Admins can initiate migrations and set the `newPool_` to be a contract that forwards funds to accounts they control

2.  Admins can add infinite `newRewardToken`s so that `_userCheckpoint()`s, which are required to withdraw funds, revert because they run out of gas iterating over the tokens.

3.  Admins can set a malicious `feeBurner`, via the addressProvider, which just takes the fees for itself.

4.  Admins can set an oracle that provides the wrong answers.",medium,"The trust-minimizing approach that Convex took was to not allow admins to change addresses. In order for things to change, an admin is allowed to completely shut everything down, and during the shut down state, users are still able to withdraw their funds. Later, the admins spin up a whole new set of contracts, and let users migrate things themselves. Something similar can be done here by having the DAO accept proposals to spawn specific contracts, and hook up specific addresses in certain ways in the new deployment.","function migrate(address newRewardToken) external override onlyGovernance {
        _replacedRewardTokens.remove(newRewardToken);
        _replacedRewardTokens.set(rewardToken, block.timestamp);
        lastMigrationEvent = block.timestamp;
        rewardToken = newRewardToken;
    }

function _userCheckpoint(
        address user,
        uint256 amountAdded,
        uint256 newTotal
    ) internal {
        RewardTokenData storage curRewardTokenData = rewardTokenData[rewardToken];

        // Compute the share earned by the user since they last updated
        uint256 userBalance = balances[user];
        if (userBalance > 0) {
            curRewardTokenData.userShares[user] += (curRewardTokenData.feeIntegral -
                curRewardTokenData.userFeeIntegrals[user]).scaledMul(
                    userBalance.scaledMul(boostFactors[user])
                );

            // Update values for previous rewardTokens
            if (lastUpdated[user] < lastMigrationEvent) {
                uint256 length = _replacedRewardTokens.length();
                for (uint256 i; i < length; i = i.uncheckedInc()) {
                    (address token, uint256 replacedAt) = _replacedRewardTokens.at(i);
                    if (lastUpdated[user] < replacedAt) {
                        RewardTokenData storage prevRewardTokenData = rewardTokenData[token];
                        prevRewardTokenData.userShares[user] += (prevRewardTokenData.feeIntegral -
                            prevRewardTokenData.userFeeIntegrals[user]).scaledMul(
                                userBalance.scaledMul(boostFactors[user])
                            );
                        prevRewardTokenData.userFeeIntegrals[user] = prevRewardTokenData
                            .feeIntegral;
                    }
                }
            }
        }

        uint256 newBoost = computeNewBoost(user, amountAdded, newTotal);
        totalLockedBoosted =
            totalLockedBoosted +
            newTotal.scaledMul(newBoost) -
            balances[user].scaledMul(boostFactors[user]);

        // Update user values
        curRewardTokenData.userFeeIntegrals[user] = curRewardTokenData.feeIntegral;
        lastUpdated[user] = block.timestamp;
        boostFactors[user] = newBoost;
        balances[user] = newTotal;
    }"
17.md,initialize `maxPercentForWithdraw` and `maxPercentForDeposit`?,"The parameters `maxPercentForWithdraw` and `maxPercentForDeposit`, which are not directly initialized, will work in a suboptimal way if the functions which rely on these parameters are called before `setWhaleThresholdWithdraw` or `setWhaleThresholdDeposit`.",low,"Recommend assigning a default value to `maxPercentForWithdraw` and `maxPercentForDeposit`. Or alternatively, initializing the values via the constructor.","function setWhaleThresholdWithdraw(uint256 _maxPercentForWithdraw) external onlyOwner {
        maxPercentForWithdraw = _maxPercentForWithdraw;
        emit LogNewVaultMax(false, _maxPercentForWithdraw);
    }

function setWhaleThresholdDeposit(uint256 _maxPercentForDeposit) external onlyOwner {
        maxPercentForDeposit = _maxPercentForDeposit;
        emit LogNewVaultMax(true, _maxPercentForDeposit);
    }"
36.md,Fee on transfer tokens can lead to incorrect approval,"The function `safeTransferFrom` may not transfer exactly `bProposal.weights[i]` amount of tokens, for tokens with a fee on transfer. This means that the `safeApprove` call in the next line would be approving more tokens than what was received, leading to accounting issues.",medium,"It is recommended to find the balance of the current contract before and after the `transferFrom` to see how much tokens were received, and approve only what was received.","function createBasket(uint256 idNumber) external override returns (IBasket) {
        Proposal memory bProposal = _proposals[idNumber];
        require(bProposal.basket == address(0));

        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));
        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));

        newAuction.initialize(address(newBasket), address(this));
        newBasket.initialize(bProposal, newAuction);

        for (uint256 i = 0; i < bProposal.weights.length; i++) {
            IERC20 token = IERC20(bProposal.tokens[i]);
            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);
            token.safeApprove(address(newBasket), bProposal.weights[i]);
        }

        newBasket.mintTo(BASE, msg.sender);

        _proposals[idNumber].basket = address(newBasket);

        emit BasketCreated(address(newBasket));

        return newBasket;
    }"
52.md,`VaderRouter.calculateOutGivenIn` calculates wrong swap,"The 3-path hop in `VaderRouter.calculateOutGivenIn` is supposed to first swap **foreign** assets to native assets **in pool0**, and then the received native assets to different foreign assets again **in pool1**.

The first argument of `VaderMath.calculateSwap(amountIn, reserveIn, reserveOut)` must refer to the same token as the second argument `reserveIn`.
The code however mixes these positions up and first performs a swap in `pool1` instead of `pool0`:

```solidity
function calculateOutGivenIn(uint256 amountIn, address[] calldata path)
    external
    view
    returns (uint256 amountOut)
{
  if(...) {
  } else {
    return
        VaderMath.calculateSwap(
            VaderMath.calculateSwap(
                // @audit the inner trade should not be in pool1 for a forward swap. amountIn foreign => next param should be foreignReserve0
                amountIn,
                nativeReserve1,
                foreignReserve1
            ),
            foreignReserve0,
            nativeReserve0
        );
  }

 /** @audit instead should first be trading in pool0!
    VaderMath.calculateSwap(
        VaderMath.calculateSwap(
            amountIn,
            foreignReserve0,
            nativeReserve0
        ),
        nativeReserve1,
        foreignReserve1
    );
  */
```

#### Impact

All 3-path swaps computations through `VaderRouter.calculateOutGivenIn` will return the wrong result.
Smart contracts or off-chain scripts/frontends that rely on this value to trade will have their transaction reverted, or in the worst case lose funds.",high,"Return the following code instead which first trades in `pool0` and then in `pool1`:

```solidity
return
  VaderMath.calculateSwap(
      VaderMath.calculateSwap(
          amountIn,
          foreignReserve0,
          nativeReserve0
      ),
      nativeReserve1,
      foreignReserve1
  );
```","function calculateOutGivenIn(uint256 amountIn, address[] calldata path)
        external
        view
        returns (uint256 amountOut)
    {
        if (path.length == 2) {
            address nativeAsset = factory.nativeAsset();
            IVaderPool pool = factory.getPool(path[0], path[1]);
            (uint256 nativeReserve, uint256 foreignReserve, ) = pool
                .getReserves();
            if (path[0] == nativeAsset) {
                return
                    VaderMath.calculateSwap(
                        amountIn,
                        nativeReserve,
                        foreignReserve
                    );
            } else {
                return
                    VaderMath.calculateSwap(
                        amountIn,
                        foreignReserve,
                        nativeReserve
                    );
            }
        } else {
            IVaderPool pool0 = factory.getPool(path[0], path[1]);
            IVaderPool pool1 = factory.getPool(path[1], path[2]);
            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0
                .getReserves();
            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1
                .getReserves();

            return
                VaderMath.calculateSwap(
                    VaderMath.calculateSwap(
                        amountIn,
                        nativeReserve1,
                        foreignReserve1
                    ),
                    foreignReserve0,
                    nativeReserve0
                );
        }
    }"
72.md,`UniV2ClassDex.sol#uniClassSell()` Tokens with fee on transfer are not fully supported,"While `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.

It's fair to say that this will lead to value leakage, so I think `medium` severity is justified.",medium,"Change to:

```solidity
function uniClassSell(DexInfo memory dexInfo,
    address buyToken,
    address sellToken,
    uint sellAmount,
    uint minBuyAmount,
    address payer,
    address payee
) internal returns (uint bought){
    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);
    IUniswapV2Pair(pair).sync();
    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();
    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);
    uint balanceBefore = IERC20(buyToken).balanceOf(payee);
    dexInfo.fees = getPairFees(dexInfo, pair);
    if (buyToken < sellToken) {
        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);
        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, """");
    } else {
        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);
        IUniswapV2Pair(pair).swap(0, buyAmount, payee, """");
    }
    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);
    require(bought >= minBuyAmount, 'buy amount less than min');
}
```","function uniClassSell(DexInfo memory dexInfo,
        address buyToken,
        address sellToken,
        uint sellAmount,
        uint minBuyAmount,
        address payer,
        address payee
    ) internal returns (uint buyAmount){
        address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);
        IUniswapV2Pair(pair).sync();
        (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();
        sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);
        uint balanceBefore = IERC20(buyToken).balanceOf(payee);
        dexInfo.fees = getPairFees(dexInfo, pair);
        if (buyToken < sellToken) {
            buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);
            IUniswapV2Pair(pair).swap(buyAmount, 0, payee, """");
        } else {
            buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);
            IUniswapV2Pair(pair).swap(0, buyAmount, payee, """");
        }

        require(buyAmount >= minBuyAmount, 'buy amount less than min');
        uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);
        return bought;
    }"
17.md,`sortVaultsByDelta` doesn't work as expected,"The function `sortVaultsByDelta` doesn't always work as expected.

Suppose all the delta's are positive, and delta1 >= delta2 >= delta3 > 0. Then `maxIndex = 0`. And `(delta < minDelta (==0) )` is never true, so `minIndex = 0`.

Then (assuming `bigFirst==true`):

vaultIndexes[0] = maxIndex = 0
vaultIndexes[2] = minIndex = 0
vaultIndexes[1] = N_COINS - maxIndex - minIndex = 3-0-0 = 3

This is clearly not what is wanted, all `vaultIndexes` should be different and should be in the range [0..2]. This is due to the fact that `maxDelta` and `minDelta` are initialized with the value 0. This all could results in withdrawing from the wrong vaults and reverts (because `vaultIndexes`[1]  is out of range).",high,"Recommend the following
1. Initializing `maxDelta` and `minDelta`:
        int256 maxDelta = -2**255; // or type(int256).min when using a newer solidity version
        int256 minDelta  = 2**255; // or type(int256).max when using a newer solidity version
2. Check that `maxIndex` and `minIndex` are not the same
3. require (`maxIndex` != `minIndex`);","function sortVaultsByDelta(
        bool bigFirst,
        uint256 unifiedTotalAssets,
        uint256[N_COINS] calldata unifiedAssets,
        uint256[N_COINS] calldata targetPercents
    ) external pure override returns (uint256[N_COINS] memory vaultIndexes) {
        uint256 maxIndex;
        uint256 minIndex;
        int256 maxDelta;
        int256 minDelta;
        for (uint256 i = 0; i < N_COINS; i++) {
            // Get difference between vault current assets and vault target
            int256 delta = int256(
                unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)
            );
            // Establish order
            if (delta > maxDelta) {
                maxDelta = delta;
                maxIndex = i;
            } else if (delta < minDelta) {
                minDelta = delta;
                minIndex = i;
            }
        }
        if (bigFirst) {
            vaultIndexes[0] = maxIndex;
            vaultIndexes[2] = minIndex;
        } else {
            vaultIndexes[0] = minIndex;
            vaultIndexes[2] = maxIndex;
        }
        vaultIndexes[1] = N_COINS - maxIndex - minIndex;
    }"
104.md,Gas costs will likely result in any fees sent to the Splitter being economically unviable to recover.,"Collection owners will likely lose money by claiming fees unless the fees from a single NFT sale outweighs the cost of claiming it (not guaranteed).

Consider a new Collection with a RoyaltyVault and Splitter set and a nonzero mint fee.

When calling mintToken, the _handlePayment function is called. This will transfer the minting fee to the RoyaltyVault contract.

On each transfer of an NFT within the collection (for instance in the _mint call which occurs directly after calling _handlePayment), the Collection contract will call sendToSplitter on the RoyaltyVault. This function will forward the collection owners' portion of the minting on to the Splitter contract but another important thing to note is that we call Splitter.incrementWindow.

This results in the fees newly deposited into the Splitter contract being held in a separate ""window"" to the fees from previous or later mints and need to be claimed separately. Remember that this process happens on every NFT sale so the only funds which will be held in this window will be the minting fees for this particular mint.

From this we can see that the claim function will only claim the fraction of the fees which are owed to the caller from a single NFT mint.

Note that we can attempt to claim from multiple windows in a single transaction using claimForAllWindow but as the name suggests it performs an unbounded loop trying to claim all previous windows (even ones which have already been claimed!) and it is likely that with a new window for every NFT sold this function will exceed the gas limit (consider an 10k token collection resulting in trying to do 10k SSTOREs at 20k gas each.), leaving us to claim each window individually with claim.

We're then forced to claim the royalties from each NFT sold one by one, having to send huge numbers of calls to claim incurring the base transaction cost many times over and performing many ERC20 transfers when we could have just performed one.

Compound on this that this needs to be repeated by everyone included in the split, multiplying the costs of claiming.

Medium risk as it's gas inefficiency to the point of significant value leakage where collection owners will lose a large fraction of their royalties.",medium,"It doesn't seem like the ""window"" mechanism does anything except raise gas costs to the extent that it will be very difficult to withdraw fees so it should be removed.","function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();

        require(
            balanceOfVault > 0,
            ""Vault does not have enough royalty Asset to send""
        );
        require(splitterProxy != address(0), ""Splitter is not set"");

        uint256 platformShare = (balanceOfVault * platformFee) / 10000;
        uint256 splitterShare = balanceOfVault - platformShare;

        require(
            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
            ""Failed to transfer royalty Asset to splitter""
        );
        require(
            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
            ""Failed to increment splitter window""
        );
        require(
            IERC20(royaltyAsset).transfer(
                platformFeeRecipient,
                platformShare
            ) == true,
            ""Failed to transfer royalty Asset to platform fee recipient""
        );

        emit RoyaltySentToSplitter(splitterProxy, splitterShare);
        emit FeeSentToPlatform(platformFeeRecipient, platformShare);
    }"
105.md,Users with large `cooldown`s can grief other users,"If an account has a large cooldown, that account can grief other accounts that are waiting for their own cooldowns, by sending small amounts to them.

Every transfer to an account increases the cooldown

```solidity
    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }
```

The amount of the increase is proportional to the sender's cooldown:

```solidity
        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);
```",medium,Only allow a total of one cooldown increase when the sender is not the recipient.,"function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }"
112.md,ERC777 tokens can bypass `depositCap` guard,"When ERC777 token is used as the underlying token for a `LiquidityPool`, a depositor can reenter `depositFor` and bypass the `depositCap` requirement check, resulting in higher total deposit than intended by governance.

Proof of Concept

*   An empty ERC777 liquidity pool is capped at 1.000 token.
*   Alice deposits 1.000 token. Before the token is actually sent to the contract, `tokensToSend` ERC777 hook is called and Alice reenters `depositFor`.
*   As the previous deposit hasn't been taken into account, the reentrancy passes the `depositCap` check.
*   Pool has 2.000 token now, despite the 1.000 deposit cap.",medium,Add reentrancy guards to `depositFor`.,"function depositFor(address account, uint256 depositAmount)
        external
        payable
        override
        returns (uint256)
    {
        return depositFor(account, depositAmount, 0);
    }

function depositFor(
        address account,
        uint256 depositAmount,
        uint256 minTokenAmount
    ) public payable override notPaused returns (uint256) {
        uint256 rate = exchangeRate();

        if (isCapped()) {
            uint256 lpBalance = lpToken.balanceOf(account);
            uint256 stakedAndLockedBalance = staker.stakedAndActionLockedBalanceOf(account);
            uint256 currentUnderlyingBalance = (lpBalance + stakedAndLockedBalance).scaledMul(rate);
            require(
                currentUnderlyingBalance + depositAmount <= depositCap,
                Error.EXCEEDS_DEPOSIT_CAP
            );
        }

        _doTransferIn(msg.sender, depositAmount);
        uint256 mintedLp = depositAmount.scaledDiv(rate);
        require(mintedLp >= minTokenAmount, Error.INVALID_AMOUNT);

        lpToken.mint(account, mintedLp);
        _rebalanceVault();

        if (msg.sender == account || address(this) == account) {
            emit Deposit(msg.sender, depositAmount, mintedLp);
        } else {
            emit DepositFor(msg.sender, account, depositAmount, mintedLp);
        }
        return mintedLp;
    }"
17.md,implicit underflows,"There are a few underflows that are converted via a typecast afterwards to the expected value. If solidity 0.8.x would be used, then the code would revert.
* `int256(a-b)` where a and b are uint: For example, if `a=1` and `b=2`, then the intermediate result would be `uint(-1) == 2**256-1`
* `int256(-x)` where x is a uint. For example, if `x=1`, then the intermediate result would be `uint(-1) == 2**256-1`

From Exposure.sol L178:
```solidity
function sortVaultsByDelta(..)
..
    for (uint256 i = 0; i < N_COINS; i++) {
        // Get difference between vault current assets and vault target
        int256 delta = int256(unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)); // underflow in intermediate result
```

From PnL.sol L112:
```solidity
 function decreaseGTokenLastAmount(bool pwrd, uint256 dollarAmount, uint256 bonus)...
..
 emit LogNewGtokenChange(pwrd, int256(-dollarAmount)); // underflow in intermediate result
```

From Buoy3Pool.sol L87:
```solidity
function safetyCheck() external view override returns (bool) {
    ...
        _ratio = abs(int256(_ratio - lastRatio[i])); // underflow in intermediate result
```",high,"It's better not to have underflows by using the appropriate typecasts. This is especially relevant when moving to solidity 0.8.x.

Recommend replacing `int256(a-b)` with `int256(a)-int256(b)`, and replacing `int256(-x)` with `-int256(x)`","function safetyCheck() external view override returns (bool) {
        for (uint256 i = 1; i < N_COINS; i++) {
            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));
            _ratio = abs(int256(_ratio - lastRatio[i]));
            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {
                return false;
            }
        }
        return true;
    }function sortVaultsByDelta(
        bool bigFirst,
        uint256 unifiedTotalAssets,
        uint256[N_COINS] calldata unifiedAssets,
        uint256[N_COINS] calldata targetPercents
    ) external pure override returns (uint256[N_COINS] memory vaultIndexes) {
        uint256 maxIndex;
        uint256 minIndex;
        int256 maxDelta;
        int256 minDelta;
        for (uint256 i = 0; i < N_COINS; i++) {
            // Get difference between vault current assets and vault target
            int256 delta = int256(
                unifiedAssets[i] - unifiedTotalAssets.mul(targetPercents[i]).div(PERCENTAGE_DECIMAL_FACTOR)
            );
            // Establish order
            if (delta > maxDelta) {
                maxDelta = delta;
                maxIndex = i;
            } else if (delta < minDelta) {
                minDelta = delta;
                minIndex = i;
            }
        }
        if (bigFirst) {
            vaultIndexes[0] = maxIndex;
            vaultIndexes[2] = minIndex;
        } else {
            vaultIndexes[0] = minIndex;
            vaultIndexes[2] = maxIndex;
        }
        vaultIndexes[1] = N_COINS - maxIndex - minIndex;
    }function decreaseGTokenLastAmount(
        bool pwrd,
        uint256 dollarAmount,
        uint256 bonus
    ) external override {
        require(msg.sender == controller, ""decreaseGTokenLastAmount: !controller"");
        uint256 lastGA = lastGvtAssets;
        uint256 lastPA = lastPwrdAssets;
        if (!pwrd) {
            lastGA = dollarAmount > lastGA ? 0 : lastGA.sub(dollarAmount);
        } else {
            lastPA = dollarAmount > lastPA ? 0 : lastPA.sub(dollarAmount);
        }
        if (bonus > 0) {
            uint256 preGABeforeBonus = lastGA;
            uint256 prePABeforeBonus = lastPA;
            uint256 preTABeforeBonus = preGABeforeBonus.add(prePABeforeBonus);
            if (rebase) {
                lastGA = preGABeforeBonus.add(bonus.mul(preGABeforeBonus).div(preTABeforeBonus));
                lastPA = prePABeforeBonus.add(bonus.mul(prePABeforeBonus).div(preTABeforeBonus));
            } else {
                lastGA = preGABeforeBonus.add(bonus);
            }
            emit LogPnLExecution(0, int256(bonus), 0, 0, bonus, 0, preGABeforeBonus, prePABeforeBonus, lastGA, lastPA);
        }

        lastGvtAssets = lastGA;
        lastPwrdAssets = lastPA;
        emit LogNewGtokenChange(pwrd, int256(-dollarAmount));
    }"
107.md,Reentrancy issue in `yVault.deposit`,"In `deposit`, the balance is cached and then a `token.transferFrom` is triggered which can lead to exploits if the `token` is a token that gives control to the sender, like ERC777 tokens.

Proof of Concept

Initial state: `balance() = 1000`, shares `supply = 1000`.
Depositing 1000 amount should mint 1000 supply, but one can split the 1000 amounts into two 500 deposits and use re-entrancy to profit.

*   Outer `deposit(500)`: `balanceBefore = 1000`. Control is given to attacker ...
*   Inner `deposit(500)`: `balanceBefore = 1000`. `shares = (_amount * supply) / balanceBefore = 500 * 1000 / 1000 = 500` shares are minted ...
*   Outer `deposit(500)` continues with the mint: `shares = (_amount * supply) / balanceBefore = 500 * 1500 / 1000 = 750` are minted.
*   Withdrawing the `500 + 750 = 1250` shares via `withdraw(1250)`, the attacker receives `backingTokens = (balance() * _shares) / supply = 2000 * 1250 / 2250 = 1111.111111111`. The attacker makes a profit of `1111 - 1000 = 111` tokens.
*   They repeat the attack until the vault is drained.",high,The `safeTransferFrom` should be the last call in `deposit`.,"function deposit(uint256 _amount) public noContract(msg.sender) {
        require(_amount > 0, ""INVALID_AMOUNT"");
        uint256 balanceBefore = balance();
        token.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 supply = totalSupply();
        uint256 shares;
        if (supply == 0) {
            shares = _amount;
        } else {
            //balanceBefore can't be 0 if totalSupply is > 0
            shares = (_amount * supply) / balanceBefore;
        }
        _mint(msg.sender, shares);

        emit Deposit(msg.sender, _amount);
    }"
26.md,`getMostRecentMarket` can revert,"The function `getMostRecentMarket` of `RCFactory.sol` will revert if no markets of the specific mode are created yet.

function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address)
{
    return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
}",low,"Recommend changing the function `getMostRecentMarket` to something like:

function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address) {
    if ( marketAddresses[_mode].length ==0) return address(0);
    return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
}","function getMostRecentMarket(IRCMarket.Mode _mode)
        external
        view
        override
        returns (address)
    {
        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];
    }"
26.md,use of array without checking its length,"Since no limit is mentioned in `batchWhitelist()` for the input of `_users` array , it may run out of gas if array length become large. See RCTreasury.sol L249.",low,"Recommend adding a limitation for which, this number of address can be whitelisted at a time.","function batchWhitelist(address[] calldata _users, bool add)
        external
        override
        onlyRole(GOVERNOR)
    {
        if (add) {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.grantRole(WHITELIST, _users[index]);
            }
        } else {
            for (uint256 index = 0; index < _users.length; index++) {
                RCTreasury.revokeRole(WHITELIST, _users[index]);
            }
        }
    }"
145.md,Renew of 2nd level domain is not done properly,"The ETHRegistrarController is calling renew from base registrar and not through Namewrapper. This means the fuses for the subdomain will not be updated via _setData. This impacts the permission model set over subdomain and could lead to takeover

Proof of Concept

1.  Observe the renew function

    function renew(string calldata name, uint256 duration)
            external
            payable
            override
        {
            ...

            uint256 expires = base.renew(uint256(label), duration);

            ....
        }

2.  As we can see this is calling renew function of Base Registrar instead of NameWrapper. Since this is not going via NameWrapper fuses will not be set

3.  Also since renew in NameWrapper can only be called via Controller which is ETHRegistrarController so there is no way to renew subdomain",medium,The ETHRegistrarController must renew using Namewrapper's renew contract.,"function renew(
        uint256 tokenId,
        uint256 duration,
        uint64 expiry
    ) external override onlyController returns (uint256 expires) {
        bytes32 node = _makeNode(ETH_NODE, bytes32(tokenId));

        expires = registrar.renew(tokenId, duration);
        (address owner, uint32 fuses, uint64 oldExpiry) = getData(
            uint256(node)
        );
        expiry = _normaliseExpiry(expiry, oldExpiry, uint64(expires));

        _setData(node, owner, fuses, expiry);
    }"
123.md,User can forfeit other user rewards,"User can forfeit other user rewards by giving a higher _startIndex in getReward function.

Proof of Concept

1.  Assume User B has not received any reward yet so that his userClaims[_token][User B]=0
2.  User A calls getReward function with _account as User B and _startIndex as 5
3.  This eventually calls _allClaimableRewards at ExtraRewardsDistributor.sol#L213 which computes epochIndex =5>0?5:0 = 5
4.  Assuming tokenEpochs is 10 and latestEpoch is 8, so reward will computed from epoch 5 till epoch index 7 and _allClaimableRewards will return index as 7
5.  _getReward will simply update userClaims[_token][User B] with 7
6.  This is incorrect because as per contract User B has received reward from epoch 0-7 even though he only received reward for epoch 5-7",high,Do not allow users to call getReward function for other users.,"function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }"
18.md,`LendingPair.liquidateAccount` does not accrue and update `cumulativeInterestRate`,"The `LendingPair.liquidateAccount` function does not accrue and update the `cumulativeInterestRate` first, it only calls `_accrueAccountInterest` which does not update and instead uses the old `cumulativeInterestRate`.

The liquidatee (borrower)'s state will not be up-to-date.
I could skip some interest payments by liquidating myself instead of repaying if I'm under-water.
As the market interest index is not accrued, the borrower does not need to pay any interest accrued from the time of the last accrual until now.",high,Recommend calling `accrueAccount` instead of `_accrueAccountInterest`,"function liquidateAccount(
    address _account,
    address _repayToken,
    uint    _repayAmount,
    uint    _minSupplyOutput
  ) external {

    // Input validation and adjustments

    _validateToken(_repayToken);
    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;

    // Check account is underwater after interest

    _accrueAccountInterest(_account);
    _accrueAccountInterest(feeRecipient());
    uint health = accountHealth(_account);
    require(health < controller.LIQ_MIN_HEALTH(), ""LendingPair: account health > LIQ_MIN_HEALTH"");

    // Calculate balance adjustments

    _repayAmount = Math.min(_repayAmount, debtOf[_repayToken][_account]);

    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount);
    uint callerFee    = supplyDebt * controller.liqFeeCaller(_repayToken) / 100e18;
    uint systemFee    = supplyDebt * controller.liqFeeSystem(_repayToken) / 100e18;
    uint supplyBurn   = supplyDebt + callerFee + systemFee;
    uint supplyOutput = supplyDebt + callerFee;

    require(supplyOutput >= _minSupplyOutput, ""LendingPair: supplyOutput >= _minSupplyOutput"");

    // Adjust balances

    _burnSupply(supplyToken, _account, supplyBurn);
    _mintSupply(supplyToken, feeRecipient(), systemFee);
    _burnDebt(_repayToken, _account, _repayAmount);

    // Settle token transfers

    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);
    _safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput);

    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);
  }"
94.md,`buyFromPrivateSaleFor()` Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT,"The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient `ETH` is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.",medium,"Consider adding a `_cancelBuyersOffer()` call to the `buyFromPrivateSaleFor()` function. This should be added only to the case where insufficient `ETH` was provided to the trade. By cancelling the buyer's offer on the same NFT, we can guarantee that the user has access to the correct amount of funds.","function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      // The signed message from the seller has expired.
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure
      // that transactions do not fail due to a minor timezone error or similar during signing.

      // This prevents malicious actors from requesting signatures that never expire.
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    // The seller must have the NFT in their wallet when this function is called,
    // otherwise the signature verification below will fail.
    address payable seller = payable(nftContract.ownerOf(tokenId));

    // Scoping this block to avoid a stack too deep error
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    // This should revert if the seller has not given the market contract approval.
    nftContract.transferFrom(seller, msg.sender, tokenId);

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }"
124.md,deposit() and mint() and _redeemInternal() in wfCashERC4626() will revert for all fcash that asset token is underlying token because they always call _mintInternal() with useUnderlying==True,"For some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in `wfCashERC4626` will not work for those `fcash` tokens.

when for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `deposit()` and `mint()` in `wfCashERC4626` contract call `_mintInternal()` with `useUnderlying==True` and it calls `NotionalV2.batchLend()` with `depositUnderlying==true` so the `NotionV2` call will fail for `fcash` tokens that asset token is underlying token and it would cause  that `deposit()` and `mint()`  logic `wfCashERC4626`  will not work and contract will be useless for those tokens.
`_redeemInternal()` issue is similar and it calls `_burn()` with `redeemToUnderlying: true` which execution eventually calls `NotionalV2.batchBalanceAndTradeAction()` with `toUnderlying=True` which will revert so `_redeemInternal()` will fail and because `withdraw()` and `redeem` use it, so they will not work too for those `fcash` tokens that asset token is underlying token.

As you can see they both call `_mintInternal()` with last parameter as `true` which is `useUnderlying`'s value. This is `_mintInternal()` code:

As you can see it calls `NotionalV2` functions with `useUnderlying=True` but according to sponsor clarification `NotionalV2` would fail and revert for those calls because `useUnderlying=True` and `fcash`'s asset token is underlying token (`asset.tokenType == TokenType.NonMintable`).
So in summery for `fcash` tokens which asset token is underlying token `NotionalV2` won't handle calls which include `useUnderlying==True` but in `wfCashERC4626` contract functions like `deposit()`, `mint()`, `withdraw()` and `redeem()` they all uses `useUnderlying==True` always so `wfCashERC4626` won't work for those specific type of tokens which asset token is underlying token(`asset.tokenType == TokenType.NonMintable`)

the detail explanations for functions `withdraw()` and `redeem()` are similar.",medium,Check that if for that `fcash` token asset token  is underlying token or not and set `useUnderlying` based on that.,"function deposit(uint256 assets, address receiver) public override returns (uint256) {
        uint256 shares = previewDeposit(assets);
        // Will revert if matured
        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);
        emit Deposit(msg.sender, receiver, assets, shares);
        return shares;
    }

function mint(uint256 shares, address receiver) public override returns (uint256) {
        uint256 assets = previewMint(shares);
        // Will revert if matured
        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);
        emit Deposit(msg.sender, receiver, assets, shares);
        return assets;
    }

function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public override returns (uint256) {
        uint256 shares = previewWithdraw(assets);

        if (msg.sender != owner) {
            _spendAllowance(owner, msg.sender, shares);
        }
        _redeemInternal(shares, receiver, owner);

        emit Withdraw(msg.sender, receiver, owner, assets, shares);

        return shares;
    }

function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256) {
        // It is more accurate and gas efficient to check the balance of the
        // receiver here than rely on the previewRedeem method.
        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);

        if (msg.sender != owner) {
            _spendAllowance(owner, msg.sender, shares);
        }
        _redeemInternal(shares, receiver, owner);

        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);
        uint256 assets = balanceAfter - balanceBefore;
        emit Withdraw(msg.sender, receiver, owner, assets, shares);
        return assets;
    }

function _redeemInternal(
        uint256 shares,
        address receiver,
        address owner
    ) private {
        bytes memory userData = abi.encode(
            RedeemOpts({
                redeemToUnderlying: true,
                transferfCash: false,
                receiver: receiver,
                maxImpliedRate: 0
            })
        );

        // No operator data
        _burn(owner, shares, userData, """");
    }"
29.md,`ConstantProductPool` & `HybridPool`: Adding and removing unbalanced liquidity yields slightly more tokens than swap,"A mint fee is applied whenever unbalanced liquidity is added, because it is akin to swapping the excess token amount for the other token.

However, the current implementation distributes the minted fee to the minter as well (when he should be excluded). It therefore acts as a rebate of sorts.

As a result, it makes adding and removing liquidity as opposed to swapping directly (negligibly) more desirable. An example is given below using the Constant Product Pool to illustrate this point. The Hybrid pool exhibits similar behaviour.

1.  Initialize the pool with ETH-USDC sushi pool amounts. As of the time of writing, there is roughly 53586.556 ETH and 165143020.5295 USDC.
2.  Mint unbalanced LP with 5 ETH (& 0 USDC). This gives the user `138573488720892 / 1e18` LP tokens.
3.  Burn the minted LP tokens, giving the user 2.4963 ETH and 7692.40 USDC. This is therefore equivalent to swapping 5 - 2.4963 = 2.5037 ETH for 7692.4044 USDC.
4.  If the user were to swap the 2.5037 ETH directly, he would receive 7692.369221 (0.03 USDC lesser).",medium,"The mint fee should be distributed to existing LPs first, by incrementing `_reserve0` and `_reserve1` with the fee amounts. The rest of the calculations follow after.

For ConstantProductPool:
(uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
// increment reserve amounts with fees
_reserve0 += uint112(fee0);
_reserve1 += uint112(fee1);
unchecked {
    _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);
}
uint256 computed = TridentMath.sqrt(balance0 * balance1);
...
kLast = computed;

For HybridPool:
(uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);
// increment reserve amounts with fees
_reserve0 += uint112(fee0);
_reserve1 += uint112(fee1);
uint256 newLiq = _computeLiquidity(balance0, balance1);
...","function _mintFee(
        uint112 _reserve0,
        uint112 _reserve1,
        uint256 _totalSupply
    ) internal returns (uint256 liquidity) {
        uint256 _kLast = kLast;
        if (_kLast != 0) {
            uint256 computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);
            if (computed > _kLast) {
                // @dev `barFee` % of increase in liquidity.
                // It's going to be slightly less than `barFee` % in reality due to the math.
                liquidity = (_totalSupply * (computed - _kLast) * barFee) / computed / MAX_FEE;
                if (liquidity != 0) {
                    _mint(barFeeTo, liquidity);
                }
            }
        }
    }

function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;
        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }function _computeLiquidity(uint256 _reserve0, uint256 _reserve1) internal view returns (uint256 liquidity) {
        uint256 xp0 = _reserve0 * token0PrecisionMultiplier;
        uint256 xp1 = _reserve1 * token1PrecisionMultiplier;
        liquidity = _computeLiquidityFromAdjustedBalances(xp0, xp1);
    }

function _nonOptimalMintFee(
        uint256 _amount0,
        uint256 _amount1,
        uint256 _reserve0,
        uint256 _reserve1
    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {
        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);
        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;
        
        if (amount1Optimal <= _amount1) {
            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);
        } else {
            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;
            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);
        }
    }"
52.md,`BasePool.swap()` Is Callable By Anyone,The `BasePool.swap()` function differs from its implementation in `BasePoolV2.swap()` in which it lacks an `onlyRouter` modifier. This ensures that users cannot call this function directly as `VaderRouter._swap()` performs some necessary input validation which can be bypassed by directly calling `BasePool.swap()`.,medium,Consider adding an `onlyRouter` modifier to the `BasePool.swap()` functions to ensure users cannot directly call these functions.,"function swap(
        uint256 nativeAmountIn,
        uint256 foreignAmountIn,
        address to,
        bytes calldata
    ) external override returns (uint256) {
        return swap(nativeAmountIn, foreignAmountIn, to);
    }

function swap(
        uint256 nativeAmountIn,
        uint256 foreignAmountIn,
        address to
    ) public override nonReentrant validateGas returns (uint256) {
        require(
            (nativeAmountIn > 0 && foreignAmountIn == 0) ||
                (nativeAmountIn == 0 && foreignAmountIn > 0),
            ""BasePool::swap: Only One-Sided Swaps Supported""
        );
        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings

        uint256 nativeBalance;
        uint256 foreignBalance;
        uint256 nativeAmountOut;
        uint256 foreignAmountOut;
        {
            // scope for _token{0,1}, avoids stack too deep errors
            IERC20 _nativeAsset = nativeAsset;
            IERC20 _foreignAsset = foreignAsset;
            nativeBalance = _nativeAsset.balanceOf(address(this));
            foreignBalance = _foreignAsset.balanceOf(address(this));

            require(
                to != address(_nativeAsset) && to != address(_foreignAsset),
                ""BasePool::swap: Invalid Receiver""
            );

            if (foreignAmountIn > 0) {
                require(
                    foreignAmountIn <= foreignBalance - foreignReserve,
                    ""BasePool::swap: Insufficient Tokens Provided""
                );
                require(
                    foreignAmountIn <= foreignReserve,
                    ""BasePool::swap: Unfavourable Trade""
                );

                nativeAmountOut = VaderMath.calculateSwap(
                    foreignAmountIn,
                    foreignReserve,
                    nativeReserve
                );

                require(
                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,
                    ""BasePool::swap: Swap Impossible""
                );

                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens
            } else {
                require(
                    nativeAmountIn <= nativeBalance - nativeReserve,
                    ""BasePool::swap: Insufficient Tokens Provided""
                );
                require(
                    nativeAmountIn <= nativeReserve,
                    ""BasePool::swap: Unfavourable Trade""
                );

                foreignAmountOut = VaderMath.calculateSwap(
                    nativeAmountIn,
                    nativeReserve,
                    foreignReserve
                );

                require(
                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,
                    ""BasePool::swap: Swap Impossible""
                );

                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens
            }

            nativeBalance = _nativeAsset.balanceOf(address(this));
            foreignBalance = _foreignAsset.balanceOf(address(this));
        }

        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);

        emit Swap(
            msg.sender,
            nativeAmountIn,
            foreignAmountIn,
            nativeAmountOut,
            foreignAmountOut,
            to
        );

        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;
    }"
131.md,Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards.,"Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards.

Also there will be a problem with a rewarding system in LpGauge.sol so that some normal users wouldn't get rewards properly.

Proof of Concept

1.  Strategy A staked amount x and x will be added to StakerVault.strategiesTotalStaked.

2. Strategy A transferred the amount x to non-strategy B and StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked won't be updated.

3. After some time for the larger LpGauge.poolStakedIntegral, B claims rewards using the LpGauge.claimRewards() function.

Inside LpGauge.userCheckPoint(), it's designed not to calculate LpGauge.perUserShare for strategy, but it will pass this condition because B is not a strategy.

Furthermore, when calculate rewards, LpGauge.poolStakedIntegral will be calculated larger than a normal user stakes same amount.
It's because StakerVault._poolTotalStaked wasn't updated when A transfers x amount to B so LpGauge.poolTotalStaked is less than correct value.

Finally B can get more rewards than he should and the reward system will pay more rewards than it's designed.",medium,"I think there will be two methods to fix.

Method 1 is to forbid a transfer between strategy and non-strategy so that strategy can't move funds to non-strategy.

Method 2 is to update StakerVault.strategiesTotalStaked and StakerVault._poolTotalStaked correctly so that strategy won't claim more rewards than he should even though he claims rewards using non-strategy.

Method 1.
You need to modify two functions. StakerVault.transfer(), StakerVault.transferFrom().

1.  You need to add this require() at L112 for transfer().

    require(strategies[msg.sender] == strategies[account], Error.FAILED_TRANSFER);

2.  You need to add this require() at L144 for transferFrom().

    require(strategies[src] == strategies[dst], Error.FAILED_TRANSFER);

Method 2.
You need to modify 3 functions. StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom().

1.  You need to move staked amount from StakerVault._poolTotalStaked to StakerVault.strategiesTotalStaked every time when StakerVault.inflationManager approves a new strategy.

    You can modify addStrategy() at L98-L102 like this.

    function addStrategy(address strategy) external override returns (bool) {
        require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);
        require(!strategies[strategy], Error.ADDRESS_ALREADY_SET);

        strategies[strategy] = true;
        _poolTotalStaked -= balances[strategy];
        strategiesTotalStaked += balances[strategy];

        return true;
    }

2.  You need to add below code at L126 of transfer() function.

    if(strategies[msg.sender] != strategies[account]) {
        if(strategies[msg.sender]) { // from strategy to non-strategy
            _poolTotalStaked += amount;
            strategiesTotalStaked -= amount;
        }
        else { // from non-strategy to strategy
            _poolTotalStaked -= amount;
            strategiesTotalStaked += amount;
        }
    }

3.  You need to add below code at L170 of transferFrom() function.

    if(strategies[src] != strategies[dst]) {
        if(strategies[src]) { // from strategy to non-strategy
            _poolTotalStaked += amount;
            strategiesTotalStaked -= amount;
        }
        else { // from non-strategy to strategy
            _poolTotalStaked -= amount;
            strategiesTotalStaked += amount;
        }
    }","function claimRewards(address beneficiary) external override returns (uint256) {
        require(
            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),
            Error.UNAUTHORIZED_ACCESS
        );
        userCheckpoint(beneficiary);
        uint256 amount = perUserShare[beneficiary];
        if (amount <= 0) return 0;
        perUserShare[beneficiary] = 0;
        _mintRewards(beneficiary, amount);
        return amount;
    }

function userCheckpoint(address user) public override returns (bool) {
        _poolCheckpoint();

        // No checkpoint for the actions and strategies, since this does not accumulate tokens
        if (
            IController(controller).addressProvider().isAction(user) || stakerVault.isStrategy(user)
        ) {
            return false;
        }
        uint256 poolStakedIntegral_ = poolStakedIntegral;
        perUserShare[user] += (
            (stakerVault.stakedAndActionLockedBalanceOf(user)).scaledMul(
                (poolStakedIntegral_ - perUserStakedIntegral[user])
            )
        );

        perUserStakedIntegral[user] = poolStakedIntegral_;

        return true;
    }function addStrategy(address strategy) external override returns (bool) {
        require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);
        strategies[strategy] = true;
        return true;
    }

function transfer(address account, uint256 amount) external override notPaused returns (bool) {
        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);
        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);

        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        pool.handleLpTokenTransfer(msg.sender, account, amount);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(msg.sender);
            ILpGauge(lpGauge).userCheckpoint(account);
        }

        balances[msg.sender] -= amount;
        balances[account] += amount;

        emit Transfer(msg.sender, account, amount);
        return true;
    }

function transferFrom(
        address src,
        address dst,
        uint256 amount
    ) external override notPaused returns (bool) {
        /* Do not allow self transfers */
        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);

        /* Get the allowance, infinite for the account owner */
        uint256 startingAllowance;
        if (msg.sender == src) {
            startingAllowance = type(uint256).max;
        } else {
            startingAllowance = _allowances[src][msg.sender];
        }
        require(startingAllowance >= amount, Error.INSUFFICIENT_ALLOWANCE);

        uint256 srcTokens = balances[src];
        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);

        address lpGauge = currentAddresses[_LP_GAUGE];
        if (lpGauge != address(0)) {
            ILpGauge(lpGauge).userCheckpoint(src);
            ILpGauge(lpGauge).userCheckpoint(dst);
        }
        ILiquidityPool pool = addressProvider.getPoolForToken(token);
        pool.handleLpTokenTransfer(src, dst, amount);

        /* Update token balances */
        balances[src] = srcTokens.uncheckedSub(amount);
        balances[dst] = balances[dst] + amount;

        /* Update allowance if necessary */
        if (startingAllowance != type(uint256).max) {
            _allowances[src][msg.sender] = startingAllowance.uncheckedSub(amount);
        }
        emit Transfer(src, dst, amount);
        return true;
    }"
20.md,_deposit resetting user rewards can be used to grief them and make them loose rewards via `depositForMember`,"The function `_deposit` sets `mapMemberSynth_lastTime` to a date in the future in `synthVault.sol` at line 107. `mapMemberSynth_lastTime` is also used to calculate rewards earned. `depositForMember` allows anyone to ""make a donation"" for the member and cause that member to lose all their accrued rewards. This can't be used for personal gain, but can be used to bring misery to others. `depositForMember` (in `synthVault.sol` on line 95) can be called by anyone. This will set the member and can be continuously exploited to make members never earn any reward.

```solidity
 mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth)
```

This is the second submission under the same exploit.",medium,This can be mitigated by harvesting for the user right before changing `mapMemberSynth_lastTime[_member][_synth]`.,"function depositForMember(address synth, address member, uint256 amount) public {
        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synth), ""!synth""); // Must be a valid synth
        require(iBEP20(synth).transferFrom(msg.sender, address(this), amount)); // Must successfuly transfer in
        _deposit(synth, member, amount); // Assess and record the deposit
    }

function _deposit(address _synth, address _member, uint256 _amount) internal {
        if(!isStakedSynth[_synth]){
            isStakedSynth[_synth] = true; // Record as a staked synth
            stakedSynthAssets.push(_synth); // Add to staked synth array
        }
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth)
        mapMember_depositTime[_member] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member)
        mapMemberSynth_deposit[_member][_synth] += _amount; // Record balance for member
        uint256 _weight = iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount); // Get the SPARTA weight of the deposit
        mapMemberSynth_weight[_member][_synth] += _weight; // Add the weight to the user (scope: member -> synth)
        mapMemberTotal_weight[_member] += _weight; // Add to the user's total weight (scope: member)
        totalWeight += _weight; // Add to the total weight (scope: vault)
        isSynthMember[_member][_synth] = true; // Record user as a member
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }"
114.md,Owner or Managers can rug Aave rewards,"A malicious owner or manager can steal all Aave rewards that are meant for PoolTogether users.

Even if the user is benevolent the fact that there is a rug vector available may negatively impact the protocol's reputation.

The `claimRewards()` function allows the caller to send the rewards to an arbitrary address.",medium,"Use a poolAddressesProviderRegistry-like contract to determine where the rewards should go, instead of letting an address be passed in","function claimRewards(address _to) external onlyManagerOrOwner returns (bool) {
    require(_to != address(0), ""AaveV3YS/payee-not-zero-address"");

    address[] memory _assets = new address[](1);
    _assets[0] = address(aToken);

    (address[] memory _rewardsList, uint256[] memory _claimedAmounts) = rewardsController
      .claimAllRewards(_assets, _to);

    emit Claimed(msg.sender, _to, _rewardsList, _claimedAmounts);
    return true;
  }"
3.md,Different solidity version in UniswapStyleLib.sol,"The solidity version in UniswapStyleLib.sol (>=0.5.0) is different than the solidity version in the other contracts (e.g. ^0.8.0)
Also math actions are present in the functions getAmountOut and getAmountIn that could easily lead to an underflow or division by 0; (note safemath is not used). Note: In solidity 0.8.0 safemath like protections are default.

The impact is low because UniswapStyleLib is a library and the solidity version of the contract that uses the library is used (e.g. ^0.8.0), which has safemath like protections. It is cleaner to have the same solidity version everywhere.

getAmountIn(3,1,1000) would give division by 0
getAmountIn(1,1,1) will underflow denominator",low,It is cleaner to have the same solidity version everywhere.,"function getAmountOut(
        uint256 amountIn,
        uint256 reserveIn,
        uint256 reserveOut
    ) internal pure returns (uint256 amountOut) {
        require(amountIn > 0, ""UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT"");
        require(
            reserveIn > 0 && reserveOut > 0,
            ""UniswapV2Library: INSUFFICIENT_LIQUIDITY""
        );
        uint256 amountInWithFee = amountIn * 997;
        uint256 numerator = amountInWithFee * reserveOut;
        uint256 denominator = reserveIn * 1_000 + amountInWithFee;
        amountOut = numerator / denominator;
    }

function getAmountIn(
        uint256 amountOut,
        uint256 reserveIn,
        uint256 reserveOut
    ) internal pure returns (uint256 amountIn) {
        require(amountOut > 0, ""UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT"");
        require(
            reserveIn > 0 && reserveOut > 0,
            ""UniswapV2Library: INSUFFICIENT_LIQUIDITY""
        );
        uint256 numerator = reserveIn * amountOut * 1_000;
        uint256 denominator = (reserveOut - amountOut) - 997;
        amountIn = (numerator / denominator) + 1;
    }"
52.md,Incorrect Accrual Of `sumNative` and `sumUSD` In Producing Consultation Results,"The `TwapOracle.consult()` function iterates over all token pairs which belong to either `VADER` or `USDV` and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs.

Let's say we wanted to query the price of `USDV`, we would sum up any token pair where `USDV == pairData.token0`.

The sum consists of the following:

* Price of `USDV` denominated in terms of `token1` (`USDV/token1`).
* Price of token1 denominated in terms of `USD` (`token1/USD`).

Consider the following example:

* `SUSHI` and `UNISWAP` are the only registered token pairs that exist alongside `USDV`.
* Hence, calculating `sumNative` gives us an exchange rate that is denominated as the sum of `USDV/SUSHI` and `USDV/UNISWAP`.
* Similarly, `sumUSD` gives us the following denominated pairs, `SUSHI/USD` and `UNISWAP/USD`.
* Summing `sumUSD` and `sumNative` produces an entirely incorrect result as compared to multiplying the two results first and then summing.
* The issue is equivalent to the same issue as performing `(p1 + p2)*(q1 + q2)` as compared to `(p1*q1 + p2*q2)`. Obviously, these two results are not equivalent, however, the `consult()` function treats them as such.
* If we multiply the native price and Chainlink oracle results, then we can correctly calculate the price as such; `(SUSHI/USD * USDV/SUSHI + UNISWAP/USD * USDV/UNISWAP) / 2`, which should correctly give us the correct denomination and average price.

However, the protocol calculates it as `((SUSHI/USD + UNISWAP/USD) * token.decimals()) / (USDV/SUSHI + USDV/UNISWAP)` which gives us an incorrectly denominated result.

I'd classify this issue as high risk as the oracle returns false results upon being consulted. This can lead to issues in other areas of the protocol that use this data in performing sensitive actions.",high,"To calculate the correct consultation of a given token, the returned result should consist of a sum of `priceUSD * token.decimals() * priceNative` divided by the number of calculations. This should correctly take the average token pair price.

The following snippet of code details the relevant fix:

        function consult(address token) public view returns (uint256 result) {
            uint256 pairCount = _pairs.length;

            for (uint256 i = 0; i < pairCount; i++) {
                PairData memory pairData = _pairs[i];

                if (token == pairData.token0) {
                    //
                    // TODO - Review:
                    //   Verify price1Average is amount of USDV against 1 unit of token1
                    //

                    priceNative = pairData.price1Average.mul(1).decode144(); // native asset amount
                    if (pairData.price1Average._x != 0) {
                        require(priceNative != 0);
                    } else {
                        continue; // should skip newly registered assets that have not been updated yet.
                    }

                    (
                        uint80 roundID,
                        int256 price,
                        ,
                        ,
                        uint80 answeredInRound
                    ) = AggregatorV3Interface(_aggregators[pairData.token1])
                            .latestRoundData();

                    require(
                        answeredInRound >= roundID,
                        ""TwapOracle::consult: stale chainlink price""
                    );
                    require(
                        price != 0,
                        ""TwapOracle::consult: chainlink malfunction""
                    );
                    priceUSD = uint256(price) * (10**10);
                    result += ((priceUSD * IERC20Metadata(token).decimals()) * priceNative);
                }
            }
            require(sumNative != 0, ""TwapOracle::consult: Sum of native is zero"");
            return result;
        }

The TWAP oracle module has been completely removed and redesigned from scratch as LBTwap that is subject of the new audit.","function consult(address token) public view returns (uint256 result) {
        uint256 pairCount = _pairs.length;
        uint256 sumNative = 0;
        uint256 sumUSD = 0;

        for (uint256 i = 0; i < pairCount; i++) {
            PairData memory pairData = _pairs[i];

            if (token == pairData.token0) {
                //
                // TODO - Review:
                //   Verify price1Average is amount of USDV against 1 unit of token1
                //

                sumNative += pairData.price1Average.mul(1).decode144(); // native asset amount
                if (pairData.price1Average._x != 0) {
                    require(sumNative != 0);
                }

                (
                    uint80 roundID,
                    int256 price,
                    ,
                    ,
                    uint80 answeredInRound
                ) = AggregatorV3Interface(_aggregators[pairData.token1])
                        .latestRoundData();

                require(
                    answeredInRound >= roundID,
                    ""TwapOracle::consult: stale chainlink price""
                );
                require(
                    price != 0,
                    ""TwapOracle::consult: chainlink malfunction""
                );

                sumUSD += uint256(price) * (10**10);
            }
        }
        require(sumNative != 0, ""TwapOracle::consult: Sum of native is zero"");
        result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);
    }"
35.md,Wrong usage of `positionId` in `ConcentratedLiquidityPoolManager`,"In the `subscribe` function of `ConcentratedLiquidityPoolManager`, the `incentive` to subscribed is determined as follows:

```solidity
Incentive memory incentive = incentives[pool][positionId];
```

However, `positionId` should be `incentiveId`, a counter that increases by one whenever a new incentive is added to the pool. The usage of `positionId` could cause the wrong incentive to be used, and in general, the incentive is not found, and the transaction reverts (the condition `block.timestamp < incentive.endTime` is not met). The `getReward` and `claimReward` functions have the bug of misusing `positionId` as the index of incentives.",high,Change `positionId` to `incentiveId` in the referenced lines of code.,"function subscribe(uint256 positionId, uint256 incentiveId) public {
        Position memory position = positions[positionId];
        IConcentratedLiquidityPool pool = position.pool;
        Incentive memory incentive = incentives[pool][positionId];
        Stake storage stake = stakes[positionId][incentiveId];
        require(position.liquidity != 0, ""INACTIVE"");
        require(stake.secondsInsideLast == 0, ""SUBSCRIBED"");
        require(incentiveId <= incentiveCount[pool], ""NOT_INCENTIVE"");
        require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, ""TIMED_OUT"");
        stakes[positionId][incentiveId] = Stake(uint160(pool.rangeSecondsInside(position.lower, position.upper)), true);
        emit Subscribe(positionId, incentiveId);
    }

function claimReward(
        uint256 positionId,
        uint256 incentiveId,
        address recipient,
        bool unwrapBento
    ) public {
        require(ownerOf[positionId] == msg.sender, ""OWNER"");
        Position memory position = positions[positionId];
        IConcentratedLiquidityPool pool = position.pool;
        Incentive storage incentive = incentives[position.pool][positionId];
        Stake storage stake = stakes[positionId][incentiveId];
        require(stake.initialized, ""UNINITIALIZED"");
        uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;
        uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;
        uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;
        uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);
        uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;
        incentive.rewardsUnclaimed -= rewards;
        incentive.secondsClaimed += uint160(secondsInside);
        stake.secondsInsideLast += uint160(secondsPerLiquidityInside);
        _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);
        emit ClaimReward(positionId, incentiveId, recipient);
    }

function getReward(uint256 positionId, uint256 incentiveId) public view returns (uint256 rewards, uint256 secondsInside) {
        Position memory position = positions[positionId];
        IConcentratedLiquidityPool pool = position.pool;
        Incentive memory incentive = incentives[pool][positionId];
        Stake memory stake = stakes[positionId][incentiveId];
        if (stake.initialized) {
            secondsInside = (pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast) * position.liquidity;
            uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;
            uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);
            rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;
        }
    }"
21.md,Unbounded iteration over all protocols,"The `LibPool.payOffDebtAll` function iterates over all elements of the `ps.protocols` array.

The transactions could fail if the arrays get too big and the transaction would consume more gas than the block limit.
This will then result in a denial of service for the desired functionality and break core functionality.

The severity is low as only governance can whitelist protocols per token but not the protocols themselves.",low,Recommendation is to keep the array size small.,"function payOffDebtAll(IERC20 _token) external {
    PoolStorage.Base storage ps = PoolStorage.ps(_token);
    uint256 blocks = block.number.sub(ps.totalPremiumLastPaid);

    uint256 totalAccruedDebt;
    for (uint256 i = 0; i < ps.protocols.length; i++) {
      totalAccruedDebt = totalAccruedDebt.add(_payOffDebt(ps, ps.protocols[i], blocks));
    }
    // move funds to the sherX etf
    ps.sherXUnderlying = ps.sherXUnderlying.add(totalAccruedDebt);
    ps.totalPremiumLastPaid = uint40(block.number);
  }"
